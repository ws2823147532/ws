<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>努力，奋斗</title>
  
  <subtitle>记录学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shang.at/"/>
  <updated>2020-07-23T01:13:53.160Z</updated>
  <id>https://shang.at/</id>
  
  <author>
    <name>王尚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据-aws</title>
    <link href="https://shang.at/post/%E5%A4%A7%E6%95%B0%E6%8D%AE-aws/"/>
    <id>https://shang.at/post/大数据-aws/</id>
    <published>2020-07-23T01:08:29.000Z</published>
    <updated>2020-07-23T01:13:53.160Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><h3 id="AWS常见命令"><a href="#AWS常见命令" class="headerlink" title="AWS常见命令"></a>AWS常见命令</h3><p>aws s3 [commend] help</p><p>aws s3 ls [—recursive] [—human-readable] [—summarize]</p><p>aws s3 rm s3_path [—recursive]</p><p>aws s3 cp s3_path target_path [—recursive]</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://shang.at/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="aws" scheme="https://shang.at/tags/aws/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-文件操作</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://shang.at/post/Python学习-文件操作/</id>
    <published>2020-07-22T03:24:24.000Z</published>
    <updated>2020-07-22T06:20:32.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p>打开文件：<code>open(filename, &#39;r|w|x|a|b|t|+&#39;, buffering=4096,)</code></p><p>检测路径是否存在：<code>os.path.exists(path)</code></p><p>创建目录：<code>os.mkdir(path)</code>  递归创建路径：<code>os.makedirs(path)</code></p><p>删除目录：<code>os.rmdir(path)</code>  递归删除目录：<code>shutil.rmtree(path)</code></p><p>获取当前的工作目录：<code>os.getcwd()</code></p><p>判断给定的路径是否为目录：<code>os.path.isdir(source)</code></p><p>获取给定文件全路径的一级目录：<code>os.path.dirname(source)</code></p><p>获取给定文件全路径的文件名：<code>os.path.basename(source)</code></p><p>修改工作目录：<code>os.chdir(source_dir)</code></p><p>拼接路径：<code>os.path.join(path1, path2)</code></p><p>执行shell命令：<code>os.system(cmd)</code></p><p>循环遍历指定目录下 的(直属的)所有文件(夹)：<code>os.listdir(path)</code></p><p>递归遍历指定目录下的所有文件(夹)：<code>os.walk(path)</code>，返回的是一个<code>generator</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#conding=utf8  </span></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">for</span> path,dir_list,file_list <span class="keyword">in</span> os.walk(path):  </span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:</span><br><span class="line">        print(os.path.join(path, file_name))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="文件操作" scheme="https://shang.at/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-网络的配置</title>
    <link href="https://shang.at/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BD%91%E7%BB%9C%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://shang.at/post/操作系统-网络的配置/</id>
    <published>2020-07-15T14:24:58.000Z</published>
    <updated>2020-07-15T14:39:06.169Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：本例中以CentOS 7举例说明如何设置Linux开机自动获取IP地址和设置固定IP地址。</p></blockquote><a id="more"></a><h3 id="自动获取动态IP地址"><a href="#自动获取动态IP地址" class="headerlink" title="自动获取动态IP地址"></a>自动获取动态IP地址</h3><p>1.输入“ip addr”并按回车键确定，发现无法获取IP(CentOS 7默认没有ifconfig命令)，记录下网卡名称（本例中为ens33）。 </p><p><img src="/images/CentOSIP1.png"></p><p>2.输入“cd /etc/sysconfig/network-scripts/”按回车键确定，继续输入“ls”按回车键查看文件。 </p><p><img src="/images/CentOSIP2.png"></p><p>3.输入“vi ifcfg-ens33”并按回车键确定（网卡名称可能不同）。亦可在第二步直接输入“cd /etc/sysconfig/network-scripts/ifcfg-ens33”直接编辑文件。 </p><p><img src="/images/CentOSIP3.png"></p><p>4.查看最后一项（蓝色框内），发现为“ONBOOT=no”。 </p><p><img src="/images/CentOSIP4.png"></p><p>5.按“i”键进入编辑状态，将最后一行“no”修改为“yes”，然后按“ESC”键退出编辑状态，并输入“:x”保存退出。 </p><p><img src="/images/CentOSIP5.png"></p><p>6.输入“service network restart”重启服务,亦可输入“systemctl restart netwrok”。 </p><p><img src="/images/CentOSIP6.png"></p><p>7.再次输入“ip addr”查看，现已可自动获取IP地址。 </p><p><img src="/images/CentOSIP7.png"></p><h3 id="设置静态IP地址"><a href="#设置静态IP地址" class="headerlink" title="设置静态IP地址"></a>设置静态IP地址</h3><p>8.输入“cd /etc/sysconfig/network-scripts/”按回车键确定，继续输入“ls”按回车键查看文件，确定网卡名称。 </p><p><img src="/images/CentOSIP2.png"></p><p>9.输入“vi ifcfg-ens33”并按回车键确定（网卡名称可能不同）。如确知网卡名称可直接输入“cd /etc/sysconfig/network-scripts/ifcfg-ens33”编辑文件。 </p><p><img src="/images/CentOSIP3.png"></p><p>10.按“i”进入编辑状态，设置为“BOOTPROTO=’static’”（如设置为none则禁止DHCP，static则启用静态IP地址，设置为dhcp则为开启DHCP服务），并修改其他部分为您的设置，    本例中为192.168.1.200/24，GW:192.168.1.1，可根据您的需要配置IPV6部分。    注意：NM_CONTROLLED=no和ONBOOT=yes可根据您的需求进行设置。 </p><p><img src="/images/CentOSIP8.png"></p><p>11.确认无误后按“ESC”退出编辑状态，并输入“:x”保存退出，输入“service network restart”重启服务后输入“ifconfig”查看网络配置。 </p><p><img src="/images/CentOSIP9.png"></p><p>12.如需设置DNS(需在第9步设置NM_CONTROLLED=no)则输入“vi /etc/resolv.conf”并按回车键执行命令（如已在第9步配置DNS则可省略此步骤）。 </p><p><img src="/images/CentOSIP10.png"></p><p>13.在此文件里面输入DNS服务器地址（本例中以广东电信为例，亦可输入路由器DNS地址）并保存退出。 </p><p><img src="/images/CentOSIP11.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：本例中以CentOS 7举例说明如何设置Linux开机自动获取IP地址和设置固定IP地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://shang.at/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="网络的配置" scheme="https://shang.at/tags/%E7%BD%91%E7%BB%9C%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>工具使用-UML</title>
    <link href="https://shang.at/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-UML/"/>
    <id>https://shang.at/post/工具使用-UML/</id>
    <published>2020-07-15T03:36:56.000Z</published>
    <updated>2020-07-15T04:13:54.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：统一建模语言（Unified Modeling Language，缩写UML），是非专利的第三代建模和规约语言。<br>UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。</p></blockquote><a id="more"></a><p>推荐使用<a href="https://app.lucidchart.com/" target="_blank" rel="noopener">https://app.lucidchart.com/</a>在线工具进行绘制</p><p><strong>UML模型和图形</strong></p><p>UML分为模型和图形两大类。区分UML模型和UML图是非常重要的，UML图（包括用例图、协作图、活动图、序列图、部署图、构件图、类图、状态图）是模型中信息的图表表达形式，但是UML模型独立于UML图存在。</p><p>在UML系统开发中有三个主要的模型：</p><ul><li><strong>功能模型</strong>：从用户的角度展示系统的功能，包括用例图。</li><li><strong>对象模型</strong>：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。</li><li><strong>动态模型</strong>：展现系统的内部行为。包括序列图，活动图，状态图。</li></ul><p>UML2.2中一共定义了14种图示。</p><p>结构性图形（<em>Structure diagrams</em>）强调的是系统式的建模：</p><ul><li>静态图（static diagram)：包括类图、对象图、包图</li><li>实现图（implementation diagram）：包括组件图、部署图</li><li>剖面图</li><li>复合结构图</li></ul><p>行为式图形（<em>Behavior diagrams</em>）强调系统模型中触发的事件</p><ul><li>活动图</li><li>状态图</li><li>用例图</li></ul><p>交互性图形（<em>Interaction diagrams</em>），属于行为图形的子集合，强调系统模型中的资料流程</p><ul><li>通信图</li><li>交互概述图</li><li>时序图</li><li>时间图</li></ul><h4 id="2-UML类图作用"><a href="#2-UML类图作用" class="headerlink" title="2 UML类图作用"></a>2 UML类图作用</h4><p>UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是软件架构层次方面已经被验证有效。</p><p>我们这次介绍的主要是类图，为了解析项目的系统结构和架构层次，可以简洁明了的帮助我们理解项目中类之间的关系。</p><p>类图的作用：<br> （1）：在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；<br> （2）：类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</p><h4 id="3-类图格式"><a href="#3-类图格式" class="headerlink" title="3 类图格式"></a>3 类图格式</h4><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，</p><p>举个栗子。一个Animal类，它包含name,age,state,isPet这4个属性，以及name相关方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> isPet: <span class="type">Bool?</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> state: <span class="type">String?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = <span class="string">"no name"</span></span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">0</span></span><br><span class="line">    <span class="keyword">self</span>.isPet = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.state = <span class="string">"dead"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.name!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">setName</span><span class="params">(name: String?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对应UML类图：</p><p><img src="/images/uml1.png"></p><ul><li>类名：粗体，如果是类是抽象类则类名显示为斜体！</li><li>属性：</li></ul><blockquote><p>可见性 名称：类型[=默认值]</p></blockquote><p>可见性一般为public、private和protected，在类图分别用+、-和#表示，在Swift中没有与protected完全对应的可见控制，因此选用的是internal对应为#；名称为属性的名称；类型为数据类型；默认值如变量 age默认值为0。</p><ul><li>方法：</li></ul><blockquote><p>可见性 名称（参数列表 参数1，参数2） ：返回类型</p></blockquote><p>可见性如上名称表达式的介绍，名称就是方法名，参数列表是可选的项，多参数的话参数直接用英文逗号隔开；返回值也是个可选项，返回值类型可以说基本的数据类型、用户自定义类型和void。如果是构造方法，则无返回类型！</p><h4 id="4类与类之间的关系表达"><a href="#4类与类之间的关系表达" class="headerlink" title="4类与类之间的关系表达"></a>4类与类之间的关系表达</h4><p>类图中类与类之间的关系主要由：继承、实现、依赖、关联、聚合、组合这六大类型。表示方式如下图：</p><p><img src="/images/uml2.png"></p><h5 id="1-继承关系（Generalization-extends）"><a href="#1-继承关系（Generalization-extends）" class="headerlink" title="(1)继承关系（Generalization/extends）"></a>(1)继承关系（Generalization/extends）</h5><p>继承关系也叫泛化关系，指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><p>继承用实线空心箭头表示，由子类指向父类。</p><p>下面写两个子类，Fish和Cat分别继承自Animal。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> fishType: <span class="type">String?</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">swim</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hasFeet: <span class="type">Bool?</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">playToy</span><span class="params">(doll:Doll)</span></span> &#123;</span><br><span class="line">        doll.toyMoved()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/uml3.png"></p><h5 id="2-实现关系（implements）"><a href="#2-实现关系（implements）" class="headerlink" title="(2)实现关系（implements）"></a>(2)实现关系（implements）</h5><p>指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识，在iOS中我将其理解成代理的实现。</p><p>写一个洋娃娃类Doll，该类遵循了ToyAction协议，实现了玩具移动的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ToyAction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toyMoved</span><span class="params">()</span></span> -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doll</span>: <span class="title">NSObject</span>,<span class="title">ToyAction</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> body: <span class="type">Body?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cloth: <span class="type">Cloth?</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toyMoved</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//洋娃娃玩具动作具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/uml4.png"></p><h5 id="3-依赖关系（Dependency）"><a href="#3-依赖关系（Dependency）" class="headerlink" title="(3)依赖关系（Dependency）"></a>(3)依赖关系（Dependency）</h5><p>可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用。</p><p>在我们的上述代码中Cat的playToy方法中参数引用了Doll，因此他们是依赖关系。</p><p><img src="/images/uml5.png"></p><h5 id="4-关联关系（Association）"><a href="#4-关联关系（Association）" class="headerlink" title="(4)关联关系（Association）"></a>(4)关联关系（Association）</h5><p>他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量；</p><p>写一个Person类，他拥有一个宠物猫，他们之间的关系是关联。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> pet: <span class="type">Cat?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> head: <span class="type">Head?</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/uml6.png"></p><h5 id="5-聚合关系（Aggregation）"><a href="#5-聚合关系（Aggregation）" class="headerlink" title="(5)聚合关系（Aggregation）"></a>(5)聚合关系（Aggregation）</h5><p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cloth</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在上述代码中Doll由Body和Cloth组成，且即使失去Cloth，Doll也可以正常存在。</p><p><img src="/images/uml7"></p><h5 id="6-组合关系（Composition）"><a href="#6-组合关系（Composition）" class="headerlink" title="(6)组合关系（Composition）"></a>(6)组合关系（Composition）</h5><p>组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；</p><p>上述代码中的Person拥有Head，并且这个整体和部分是不可分割的。</p><p><img src="/images/uml8.png"></p><p>最后来看看这个例子中的整体关系：</p><p><img src="/images/uml9.png"></p><p>其实理解了之后我们发现还是很简单的，学会了之后就可以投入实践中了，举一个简单第三方库的类图例子，下图是Masonry的类图整理，可以看到项目结构很清晰的展示了出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">转自</span><br><span class="line">作者：zhengyi</span><br><span class="line">链接：https://juejin.im/post/5d318b485188255957377ac3</span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：统一建模语言（Unified Modeling Language，缩写UML），是非专利的第三代建模和规约语言。&lt;br&gt;UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://shang.at/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="UML" scheme="https://shang.at/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-设计模式</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shang.at/post/Java学习-设计模式/</id>
    <published>2020-07-14T09:26:40.000Z</published>
    <updated>2020-07-21T07:13:09.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：Java中23种设计模式，分为创建型、结构型和行为型</p></blockquote><a id="more"></a><p><img src="/images/设计模式.png"></p><h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><blockquote><p><strong>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong></p></blockquote><h2 id="Singleton单例模式"><a href="#Singleton单例模式" class="headerlink" title="Singleton单例模式"></a>Singleton单例模式</h2><blockquote><p>某个类只能有一个实例，提供一个全局的访问点。</p></blockquote><h3 id="实现1-饿汉式"><a href="#实现1-饿汉式" class="headerlink" title="实现1 饿汉式"></a>实现1 饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * 类加载到内存后，就实例化一个单例，JVM保证线程安全</span></span><br><span class="line"><span class="comment"> * 简单实用，推荐使用！</span></span><br><span class="line"><span class="comment"> * 唯一缺点：不管用到与否，类装载时就完成实例化</span></span><br><span class="line"><span class="comment"> * Class.forName("")</span></span><br><span class="line"><span class="comment"> * （话说你不用的，你装载它干啥）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Mgr01 INSTANCE = <span class="keyword">new</span> Mgr01();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr01</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mgr01 m1 = Mgr01.getInstance();</span><br><span class="line">        Mgr01 m2 = Mgr01.getInstance();</span><br><span class="line">        System.out.println(m1 == m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用静态代码块进行初始化，和Mgr01一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Mgr02 INSTANCE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Mgr02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr02</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mgr02 m1 = Mgr02.getInstance();</span><br><span class="line">        Mgr02 m2 = Mgr02.getInstance();</span><br><span class="line">        System.out.println(m1 == m2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加载jdbc驱动的时候，就是用的Class.forName(“com.mysql.jdbc.Driver”)，在com.mysql.jdbc.Driver中就是在静态代码块中对com.mysql.jdbc.Driver进行的注册</p></blockquote><h3 id="实现2-懒汉式"><a href="#实现2-懒汉式" class="headerlink" title="实现2 懒汉式"></a>实现2 懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lazy loading</span></span><br><span class="line"><span class="comment"> * 也称懒汉式，需要时才加载</span></span><br><span class="line"><span class="comment"> * 需要注意的点：</span></span><br><span class="line"><span class="comment"> * 1、DCL</span></span><br><span class="line"><span class="comment"> * 2、实例需要加volatile修饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Mgr06 INSTANCE; <span class="comment">//JIT</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr06 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//双重检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Mgr06<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Mgr06();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Mgr06.getInstance().hashCode());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于懒汉式的单例模式的详细解读：<br>1、懒汉式一：synchronized加在getInstance()上，每次调用getInstance都会进行一次加锁行为，会导致效率低下<br>2、懒汉式二：DCL模式，Double Check Lock，双重检查锁定<br>​    a. 第一步检查，如果发现INSTANCE不为null，直接返回，不会产生加锁的行为，提高效率<br>​    b. 第二步加锁，同时只能由一个线程获得锁，也只有一个线程能最终创建实例对象<br>​    c. 第三步检查，加完锁之后再次检查，防止有多个线程在第一步检查时同时竞争锁，当一个线程完成了实例的创建，那么其他的线程再次获得锁时，发现实例已经不为空，那么退出临界区且返回实例对象<br>3、INSTANCE对象需要使用volatile关键字修饰<br>​    貌似以上的操作已经没有什么问题了。但是这里还是有一个隐藏的bug：也就是<font color="red">CPU的乱序执行，指令重拍</font>。由于CPU的乱序执行会导致实例对象的半初始化状态：即对象实例虽已创建，在内存中有对应的空间，但是这时候是还没有初始化实例属性，实例属性都是初始值。在java中，基础类型的变量都有各自的初始值，但是引用类型的初始值都是null，这个时候如果其他的线程拿到了实例对象，就会导致NullPointerException。所以INSTANCE对象需要增加volatile关键字修饰，valatile关键字可以禁用CPU的乱序执行。<a href="/post/Java学习-class文件格式">具体详情需要结合编译成的jvm指令集查看</a></p><h3 id="实现3-静态内部类"><a href="#实现3-静态内部类" class="headerlink" title="实现3 静态内部类"></a>实现3 静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * JVM保证单例</span></span><br><span class="line"><span class="comment"> * 加载外部类时不会加载内部类，这样可以实现懒加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr07</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr07Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Mgr07 INSTANCE = <span class="keyword">new</span> Mgr07();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr07 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mgr07Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Mgr07.getInstance().hashCode());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现4-枚举单例"><a href="#实现4-枚举单例" class="headerlink" title="实现4 枚举单例"></a>实现4 枚举单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不仅可以解决线程同步，还可以防止反序列化。</span></span><br><span class="line"><span class="comment"> * JVM 会阻止反射获取枚举类的私有构造方法，即可以 避免使用者使用反射的方式破坏单例的唯一性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Mgr08 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Mgr08.INSTANCE.hashCode());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部隐藏的enum来生成单例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject7</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型是线程安全的，并且只会装载一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingletonObject7 instance;</span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不能设置属性呢？？？？？？</p><p>如何防止用户破坏单例的唯一性？</p><p>1、通过反射的方式破坏单例,反射是通过调用构造方法生成新的对象</p><p>2、如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例，</p><p>3、使用枚举单例</p><h2 id="FactoryMethod工厂模式"><a href="#FactoryMethod工厂模式" class="headerlink" title="FactoryMethod工厂模式"></a>FactoryMethod工厂模式</h2><h2 id="AbstractFactory抽象工厂模式"><a href="#AbstractFactory抽象工厂模式" class="headerlink" title="AbstractFactory抽象工厂模式"></a>AbstractFactory抽象工厂模式</h2><h2 id="Builder构建器"><a href="#Builder构建器" class="headerlink" title="Builder构建器"></a>Builder构建器</h2><h2 id="Prototype原型"><a href="#Prototype原型" class="headerlink" title="Prototype原型"></a>Prototype原型</h2><h1 id="结构性"><a href="#结构性" class="headerlink" title="结构性"></a>结构性</h1><blockquote><p><strong>把类或对象结合在一起形成一个更大的结构。</strong></p></blockquote><h2 id="Facade门面-模式"><a href="#Facade门面-模式" class="headerlink" title="Facade门面 模式"></a>Facade门面 模式</h2><h2 id="Decorator装饰器-模式"><a href="#Decorator装饰器-模式" class="headerlink" title="Decorator装饰器 模式"></a>Decorator装饰器 模式</h2><h2 id="Composite组合模式"><a href="#Composite组合模式" class="headerlink" title="Composite组合模式"></a>Composite组合模式</h2><h2 id="Flyweight享元"><a href="#Flyweight享元" class="headerlink" title="Flyweight享元"></a>Flyweight享元</h2><h2 id="Adapter适配器"><a href="#Adapter适配器" class="headerlink" title="Adapter适配器"></a>Adapter适配器</h2><h2 id="Bridge桥接"><a href="#Bridge桥接" class="headerlink" title="Bridge桥接"></a>Bridge桥接</h2><h2 id="Proxy静态代理与动态代理"><a href="#Proxy静态代理与动态代理" class="headerlink" title="Proxy静态代理与动态代理"></a>Proxy静态代理与动态代理</h2><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><blockquote><p><strong>类和对象如何交互，及划分责任和算法。</strong></p></blockquote><h2 id="Strategry策略模式"><a href="#Strategry策略模式" class="headerlink" title="Strategry策略模式"></a>Strategry策略模式</h2><h2 id="ChainOfResponsibility责任链-模式"><a href="#ChainOfResponsibility责任链-模式" class="headerlink" title="ChainOfResponsibility责任链 模式"></a>ChainOfResponsibility责任链 模式</h2><h2 id="Observer观察者-模式"><a href="#Observer观察者-模式" class="headerlink" title="Observer观察者 模式"></a>Observer观察者 模式</h2><h2 id="Mediator调停者-模式"><a href="#Mediator调停者-模式" class="headerlink" title="Mediator调停者 模式"></a>Mediator调停者 模式</h2><h2 id="Iterator迭代器-模式"><a href="#Iterator迭代器-模式" class="headerlink" title="Iterator迭代器 模式"></a>Iterator迭代器 模式</h2><h2 id="Visitor访问者-模式"><a href="#Visitor访问者-模式" class="headerlink" title="Visitor访问者 模式"></a>Visitor访问者 模式</h2><h2 id="Command命令-模式"><a href="#Command命令-模式" class="headerlink" title="Command命令 模式"></a>Command命令 模式</h2><h2 id="Memento备忘录-模式"><a href="#Memento备忘录-模式" class="headerlink" title="Memento备忘录 模式"></a>Memento备忘录 模式</h2><h2 id="TemplateMethod模板方法"><a href="#TemplateMethod模板方法" class="headerlink" title="TemplateMethod模板方法"></a>TemplateMethod模板方法</h2><h2 id="State状态-模式"><a href="#State状态-模式" class="headerlink" title="State状态 模式"></a>State状态 模式</h2><h2 id="Intepreter解释器-模式"><a href="#Intepreter解释器-模式" class="headerlink" title="Intepreter解释器 模式"></a>Intepreter解释器 模式</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：Java中23种设计模式，分为创建型、结构型和行为型&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="设计模式" scheme="https://shang.at/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机-Docker</title>
    <link href="https://shang.at/post/%E8%99%9A%E6%8B%9F%E6%9C%BA-Docker/"/>
    <id>https://shang.at/post/虚拟机-Docker/</id>
    <published>2020-07-13T23:36:10.000Z</published>
    <updated>2020-07-13T23:36:53.601Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="虚拟机" scheme="https://shang.at/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Docker" scheme="https://shang.at/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-CentOS7上的开发环境配置</title>
    <link href="https://shang.at/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-CentOS7%E4%B8%8A%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://shang.at/post/操作系统-CentOS7上的开发环境配置/</id>
    <published>2020-07-13T14:02:29.000Z</published>
    <updated>2020-07-16T07:05:38.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：在Centos上进行开发的环境搭建</p></blockquote><a id="more"></a><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html" target="_blank" rel="noopener">Linux Tools Quick Tutorial</a></p><h1 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h1><h2 id="升级-yum源-amp-安装相关依赖包"><a href="#升级-yum源-amp-安装相关依赖包" class="headerlink" title="升级 yum源&amp;安装相关依赖包"></a>升级 yum源&amp;安装相关依赖包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br><span class="line"></span><br><span class="line">yum install -y net-tools rsync mlocate wget vim ntpdate telnet gcc zlib-dev openssl-devel sqlite-devel bzip2-devel binutils qt  make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms strace</span><br></pre></td></tr></table></figure><h2 id="虚拟机软件"><a href="#虚拟机软件" class="headerlink" title="虚拟机软件"></a>虚拟机软件</h2><h3 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h3><p><a href="/post/虚拟机-Vagrant使用">这里查看vagrant的详细使用 </a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://releases.hashicorp.com/vagrant/2.2.9/vagrant_2.2.9_x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh vagrant_2.2.9_x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="VirualBox"><a href="#VirualBox" class="headerlink" title="VirualBox"></a>VirualBox</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.virtualbox.org/virtualbox/6.1.10/VirtualBox-6.1-6.1.10_138449_el7-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>rpm -ivh VirtualBox-6.1-6.1.10_138449_el7-1.x86_64.rpm 报错如下：libSDL-1.2.so.0()(64bit) 被 VirtualBox-6.1-6.1.10_138449_el7-1.x86_64 需要<br>那么，需要安装SDL，<code>yum install -y SDL</code></p><p>同时要保证安装的kernel-header和kernel的版本一致。安装完kernel之后，需要重启，可以使用<code>uname -r</code> 查看kernel版本</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a href="/post/虚拟机-Docker">这里查看Docker的详细使用 </a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装工具包</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装ali源</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 刷新安装源</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装 docker-ce</span><br><span class="line">yum -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span> 停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 开机自启动</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置aliyun的容器镜像加速器   </span><br><span class="line"><span class="meta">#</span> 登录aliyun.com 搜索容器镜像服务，进入管理后台，在左侧菜单栏下面可以找到 镜像加速器 选项</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://oooxxxoox.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="实时监控网速"><a href="#实时监控网速" class="headerlink" title="实时监控网速"></a>实时监控网速</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装之前均需要安装epel源，</span><br><span class="line">yum -y install epel-release</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装iftop工具</span><br><span class="line">yum install iftop -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看开启的网卡</span><br><span class="line">ifconfig </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用iftop监控，会进入一个类似top命令的界面，监控连接的地址以及网速</span><br><span class="line">iftop -i em4</span><br></pre></td></tr></table></figure><h2 id="systemctl命令详解"><a href="#systemctl命令详解" class="headerlink" title="systemctl命令详解"></a>systemctl命令详解</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">Systemctl是一个系统管理守护进程、工具和库的集合，用于取代System V、service和chkconfig命令，初始进程主要负责控制systemd系统和服务管理器。通过Systemctl –help可以看到该命令主要分为：查询或发送控制命令给systemd服务，管理单元服务的命令，服务文件的相关命令，任务、环境、快照相关命令，systemd服务的配置重载，系统开机关机相关的命令。 </span><br><span class="line"></span><br><span class="line">1. 列出所有可用单元 </span><br><span class="line"><span class="meta">#</span> systemctl list-unit-files</span><br><span class="line"></span><br><span class="line">2. 列出所有运行中单元 </span><br><span class="line"><span class="meta">#</span> systemctl list-units</span><br><span class="line"></span><br><span class="line">3. 列出所有失败单元 </span><br><span class="line"><span class="meta">#</span> systemctl –failed</span><br><span class="line"></span><br><span class="line">4. 检查某个单元（如 crond.service）是否启用 </span><br><span class="line"><span class="meta">#</span> systemctl is-enabledcrond.service </span><br><span class="line"></span><br><span class="line">5. 列出所有服务 </span><br><span class="line"><span class="meta">#</span> systemctl list-unit-files –type=service</span><br><span class="line"></span><br><span class="line">6. Linux中如何启动、重启、停止、重载服务以及检查服务（如 httpd.service）状态 </span><br><span class="line"><span class="meta">#</span> systemctl start httpd.service</span><br><span class="line"><span class="meta">#</span> systemctl restart httpd.service</span><br><span class="line"><span class="meta">#</span> systemctl stop httpd.service</span><br><span class="line"><span class="meta">#</span> systemctl reload httpd.service</span><br><span class="line"><span class="meta">#</span> systemctl status httpd.service</span><br><span class="line"></span><br><span class="line">注意：当我们使用systemctl的start，restart，stop和reload命令时，终端不会输出任何内容，只有status命令可以打印输出。</span><br><span class="line"></span><br><span class="line">7. 如何激活服务并在开机时启用或禁用服务（即系统启动时自动启动mysql.service服务） </span><br><span class="line"><span class="meta">#</span> systemctl is-active mysql.service</span><br><span class="line"><span class="meta">#</span> systemctl enable mysql.service</span><br><span class="line"><span class="meta">#</span> systemctl disable mysql.service</span><br><span class="line"></span><br><span class="line">8. 如何屏蔽（让它不能启动）或显示服务（如ntpdate.service） </span><br><span class="line"><span class="meta">#</span> systemctl mask ntpdate.service</span><br><span class="line">ln -s ‘/dev/null”/etc/systemd/system/ntpdate.service’</span><br><span class="line"><span class="meta">#</span> systemctl unmask ntpdate.service</span><br><span class="line">rm ‘/etc/systemd/system/ntpdate.service’</span><br><span class="line"></span><br><span class="line">9. 使用systemctl命令杀死服务 </span><br><span class="line"><span class="meta">#</span> systemctl killcrond </span><br><span class="line"></span><br><span class="line">10. 列出所有系统挂载点 </span><br><span class="line"><span class="meta">#</span> systemctl list-unit-files –type=mount</span><br><span class="line"></span><br><span class="line">11. 挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态 </span><br><span class="line"><span class="meta">#</span> systemctl start tmp.mount</span><br><span class="line"><span class="meta">#</span> systemctl stop tmp.mount</span><br><span class="line"><span class="meta">#</span> systemctl restart tmp.mount</span><br><span class="line"><span class="meta">#</span> systemctl reload tmp.mount</span><br><span class="line"><span class="meta">#</span> systemctl status tmp.mount</span><br><span class="line"></span><br><span class="line">12. 在启动时激活、启用或禁用挂载点（系统启动时自动挂载） </span><br><span class="line"><span class="meta">#</span> systemctl is-active tmp.mount</span><br><span class="line"><span class="meta">#</span> systemctl enable tmp.mount</span><br><span class="line"><span class="meta">#</span> systemctl disable tmp.mount</span><br><span class="line"></span><br><span class="line">13. 在Linux中屏蔽（让它不能启用）或可见挂载点 </span><br><span class="line"><span class="meta">#</span> systemctl mask tmp.mount</span><br><span class="line">ln -s ‘/dev/null”/etc/systemd/system/tmp.mount’</span><br><span class="line"><span class="meta">#</span> systemctl unmask tmp.mount</span><br><span class="line">rm ‘/etc/systemd/system/tmp.mount’</span><br><span class="line"></span><br><span class="line">14. 列出所有可用系统套接口 </span><br><span class="line"><span class="meta">#</span> systemctl list-unit-files –type=socket</span><br><span class="line"></span><br><span class="line">15. 检查某个服务的所有配置细节 </span><br><span class="line"><span class="meta">#</span> systemctl show mysql </span><br><span class="line"></span><br><span class="line">16. 获取某个服务（httpd）的依赖性列表 </span><br><span class="line"><span class="meta">#</span> systemctl list-dependencies httpd.service</span><br><span class="line"></span><br><span class="line">17. 启动救援模式 </span><br><span class="line"><span class="meta">#</span> systemctl rescue</span><br><span class="line"></span><br><span class="line">18. 进入紧急模式 </span><br><span class="line"><span class="meta">#</span> systemctl emergency</span><br><span class="line"></span><br><span class="line">19. 列出当前使用的运行等级 </span><br><span class="line"><span class="meta">#</span> systemctl get-default</span><br><span class="line"></span><br><span class="line">20. 启动运行等级5，即图形模式 </span><br><span class="line"><span class="meta">#</span> systemctl isolate runlevel5.target</span><br><span class="line">或</span><br><span class="line"><span class="meta">#</span> systemctl isolate graphical.target</span><br><span class="line"></span><br><span class="line">21. 启动运行等级3，即多用户模式（命令行） </span><br><span class="line"><span class="meta">#</span> systemctl isolate runlevel3.target</span><br><span class="line">或</span><br><span class="line"><span class="meta">#</span> systemctl isolate multiuser.target</span><br><span class="line"></span><br><span class="line">22. 设置多用户模式或图形模式为默认运行等级 </span><br><span class="line"><span class="meta">#</span> systemctl set-default runlevel3.target</span><br><span class="line"><span class="meta">#</span> systemctl set-default runlevel5.target</span><br><span class="line"></span><br><span class="line">23. 重启、停止、挂起、休眠系统或使系统进入混合睡眠 </span><br><span class="line"><span class="meta">#</span> systemctl reboot</span><br><span class="line"><span class="meta">#</span> systemctl halt</span><br><span class="line"><span class="meta">#</span> systemctl suspend</span><br><span class="line"><span class="meta">#</span> systemctl hibernate</span><br><span class="line"><span class="meta">#</span> systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line">对于不知运行等级为何物的人，说明如下。</span><br><span class="line">Runlevel 0 : 关闭系统</span><br><span class="line">Runlevel 1 : 救援，维护模式</span><br><span class="line">Runlevel 3 : 多用户，无图形系统</span><br><span class="line">Runlevel 4 : 多用户，无图形系统</span><br><span class="line">Runlevel 5 : 多用户，图形化系统</span><br><span class="line">Runlevel 6 : 关闭并重启机器</span><br></pre></td></tr></table></figure><h2 id="Centos重启与关机"><a href="#Centos重启与关机" class="headerlink" title="Centos重启与关机"></a>Centos重启与关机</h2><p>　Linux centos重启命令：</p><ul><li>　　1、reboot</li><li>　　2、shutdown -r now 立刻重启(root用户使用)</li><li>　　3、shutdown -r 10 过10分钟自动重启(root用户使用)</li><li>　　4、shutdown -r 20:35 在时间为20:35时候重启(root用户使用)</li></ul><p>　　如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启</p><p>　Linux centos关机命令：</p><ul><li>　　1、halt 立刻关机</li><li>　　2、poweroff 立刻关机</li><li>　　3、shutdown -h now 立刻关机(root用户使用)</li><li>　　4、shutdown -h 10 10分钟后自动关机</li></ul><p>　　如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：在Centos上进行开发的环境搭建&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Centos开发环境" scheme="https://shang.at/tags/Centos%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-CentOS7时区设置</title>
    <link href="https://shang.at/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-CentOS7%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/"/>
    <id>https://shang.at/post/操作系统-CentOS7时区设置/</id>
    <published>2020-07-04T14:20:22.000Z</published>
    <updated>2020-07-04T14:20:44.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p><a href="https://www.cnblogs.com/zhangeamon/p/5500744.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangeamon/p/5500744.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="centos7时区设置" scheme="https://shang.at/tags/centos7%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux-ssh</title>
    <link href="https://shang.at/post/Linux-ssh/"/>
    <id>https://shang.at/post/Linux-ssh/</id>
    <published>2020-07-04T14:13:25.000Z</published>
    <updated>2020-07-04T14:13:59.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p><a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/" target="_blank" rel="noopener">http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://shang.at/categories/Linux/"/>
    
    
      <category term="ssh" scheme="https://shang.at/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-deque</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-deque/"/>
    <id>https://shang.at/post/Python学习-deque/</id>
    <published>2020-07-02T15:52:28.000Z</published>
    <updated>2020-07-02T15:52:52.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p><a href="https://zhuanlan.zhihu.com/p/63502912" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63502912</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="deque" scheme="https://shang.at/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-单调栈和窗口及其更新结构</title>
    <link href="https://shang.at/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E7%AA%97%E5%8F%A3%E5%8F%8A%E5%85%B6%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%84/"/>
    <id>https://shang.at/post/数据结构与算法-单调栈和窗口及其更新结构/</id>
    <published>2020-07-02T11:07:20.000Z</published>
    <updated>2020-07-09T02:06:46.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://shang.at/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="单调栈" scheme="https://shang.at/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="窗口" scheme="https://shang.at/tags/%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-标准库学习</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shang.at/post/Python学习-标准库学习/</id>
    <published>2020-07-01T09:17:07.000Z</published>
    <updated>2020-07-05T01:38:22.197Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p><a href="https://docs.python.org/zh-cn/3/library/index.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="Python标准库" scheme="https://shang.at/tags/Python%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-itertools</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-itertools/"/>
    <id>https://shang.at/post/Python学习-itertools/</id>
    <published>2020-07-01T09:16:51.000Z</published>
    <updated>2020-07-05T01:37:04.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p><a href="https://docs.python.org/zh-cn/3/library/itertools.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/itertools.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="itertools" scheme="https://shang.at/tags/itertools/"/>
    
  </entry>
  
  <entry>
    <title>Spark应用-大数据集的处理</title>
    <link href="https://shang.at/post/Spark%E5%BA%94%E7%94%A8-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://shang.at/post/Spark应用-大数据集的处理/</id>
    <published>2020-07-01T09:12:03.000Z</published>
    <updated>2020-07-23T01:25:05.710Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：在spark上处理超大数据集的时候，有时候需要与外界系统进行交互或者需要将大数据量导出，下面讲解几种较方便的方案</p></blockquote><a id="more"></a><h4 id="rdd-mapPartitions"><a href="#rdd-mapPartitions" class="headerlink" title="rdd.mapPartitions()"></a>rdd.mapPartitions()</h4><p>业务场景：需要给大批量的数据进行解密操作，第一种解决方案是将数据load到driver端(4G内存)，然后进行解密，但是当数据量达到一定的量级，driver便会OOM了，所以有了第二种方案：使用<code>rdd.mapPartitions()</code>，在excutor端进行解密操作。基本原理是<code>每个partition执行一次解密操作</code>，每个partition的数据量基本不会导致    excutor OOM了。</p><p>遇到的问题：</p><p>1、对于rdd.mapPartitions() 接口内部的数据类型不熟悉</p><p>​    rdd.mapPartitions()接受的函数对象func，在被调起的时候，会有一个默认的参数传递给它，是一个iterator对象，可以接成这一个partition的数据集合，每个元素都是一个Row类型的变量，可以使用asDict()函数将其转换成map对象来操作。</p><p>​    可以这样理解，实际上就是在远程的excutor上操作了一个集合，处理完后再将结果返回</p><p>2、因为调用解密接口的时候需要动态传递一个参数到解密服务，但是rdd.mapPartitions() 执行逻辑的时候实际上是在excutor端执行的，因此传递给rdd.mapPartitions() 的函数并不能接收参数</p><p>​    rdd.mapPartitions()的参数是一个函数，在python中叫做<code>高阶函数</code>，如果熟悉java的话，那实际上类似于java8(及以后)中lambda表达式或者java中的函数回调。高阶函数可以接收函数对象作为参数，同时也可以返回一个函数对象。这里就利用高阶函数的这个特性，在func外层包装一个make_func()函数，用它来接收外部传来的参数，然后在func内部使用make_func接收的参数，这种特性叫做<code>闭包</code>，闭包还有一些其他的陷阱，<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017434209254976" target="_blank" rel="noopener">请见这里</a></p><p>3、解密的字段仅仅是极个别的字段</p><p>​    解决方案：先将需要解密的字段加一个特殊的后缀(注意要避免其他的字段有相同的后缀)；然后在func中拿到有特定后缀的字段，将其取出，并且调用解密服务；最后将字段重新命名回来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspark.rdd <span class="keyword">import</span> RDD</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> asiacredit.conf.request <span class="keyword">import</span> reqConf</span><br><span class="line"><span class="keyword">from</span> asiacredit.util.requeset.http_request <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line">KP_CHANNEL = <span class="string">'XXXXXX'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_func</span><span class="params">(channel)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(iterator)</span>:</span></span><br><span class="line">        request_obj = Request(url=reqConf.decryptConf.url, ak=reqConf.decryptConf.ak, sk=reqConf.decryptConf.sk)</span><br><span class="line">        request_body = json.loads(<span class="string">'&#123;"encryptDataList":"", "decryptionChannel":"%s"&#125;'</span> % channel)</span><br><span class="line">        _iterator = [item.asDict() <span class="keyword">for</span> item <span class="keyword">in</span> iterator]</span><br><span class="line">        <span class="keyword">if</span> len(_iterator) &lt;= <span class="number">0</span>: <span class="keyword">return</span> [Row(**item) <span class="keyword">for</span> item <span class="keyword">in</span> _iterator]</span><br><span class="line">        encrypted_columns = [k <span class="keyword">for</span> k, v <span class="keyword">in</span> _iterator[<span class="number">0</span>].items() <span class="keyword">if</span> <span class="string">'_encrypted'</span> <span class="keyword">in</span> k]</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> encrypted_columns:</span><br><span class="line">            arr = [item[col] <span class="keyword">for</span> item <span class="keyword">in</span> _iterator <span class="keyword">if</span> item[col]</span><br><span class="line">            <span class="keyword">if</span> arr:</span><br><span class="line">                copy_request_body = copy.copy(request_body)</span><br><span class="line">                copy_request_body[<span class="string">'encryptDataList'</span>] = arr</span><br><span class="line">                request_obj.body = json.dumps(copy_request_body)</span><br><span class="line">                encrypted_res = request_obj.request()</span><br><span class="line">                col_res = &#123;line[<span class="string">'encryptStr'</span>]: line[<span class="string">'decryptStr'</span>] <span class="keyword">for</span> line <span class="keyword">in</span> encrypted_res[<span class="string">'decryptDataList'</span>]&#125;</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(_iterator)):</span><br><span class="line">                    <span class="keyword">if</span> _iterator[i][col]:</span><br><span class="line">                        _iterator[i][col] = col_res[_iterator[i][col]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> [Row(**item) <span class="keyword">for</span> item <span class="keyword">in</span> _iterator]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecryptData</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, encrypt_data: DataFrame, columns: list, decryption_channel=KP_CHANNEL, partition_num=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将解密操作放到集群节点上进行</span></span><br><span class="line"><span class="string">        如果不指定partition_num，会自动按照默认的分区数进行解密</span></span><br><span class="line"><span class="string">        :param encrypt_data: 要解密的DataFrame</span></span><br><span class="line"><span class="string">        :param columns: 被加密的字段列表</span></span><br><span class="line"><span class="string">        :param decryption_channel: 加密的channel</span></span><br><span class="line"><span class="string">        :param partition_num: 为1时，和第一版的接口效果一致，但是这里占用的是executor的资源，driver不会因为数据量过大二OOM</span></span><br><span class="line"><span class="string">            executor的内存一般会比driver大很多，所以OOM的概率会降低</span></span><br><span class="line"><span class="string">            或者 这里在外层可以动态计算数据量设置一个合适的partition num</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.columns = columns</span><br><span class="line">        self.columns1 = [<span class="string">f'<span class="subst">&#123;col&#125;</span>_encrypted'</span> <span class="keyword">for</span> col <span class="keyword">in</span> columns]</span><br><span class="line">        self.source_columns = [col_name <span class="keyword">for</span> col_name, _ <span class="keyword">in</span> encrypt_data.dtypes]</span><br><span class="line">        <span class="keyword">for</span> old, new <span class="keyword">in</span> zip(self.columns, self.columns1):</span><br><span class="line">            encrypt_data = encrypt_data.withColumnRenamed(old, new)</span><br><span class="line">        self.enough_data = encrypt_data.count() &gt; <span class="number">0</span></span><br><span class="line">        self.encrypt_data = encrypt_data</span><br><span class="line">        self.partition_num = partition_num</span><br><span class="line">        <span class="keyword">if</span> decryption_channel <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">raise</span> AttributeError(<span class="string">'decryption_channel can not be none'</span>)</span><br><span class="line">        self.decryption_channel = decryption_channel</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.enough_data:</span><br><span class="line">            encrypt_data_rdd: RDD = self.encrypt_data.rdd \</span><br><span class="line">                <span class="keyword">if</span> self.partition_num == <span class="number">0</span> <span class="keyword">else</span> self.encrypt_data.repartition(self.partition_num).rdd</span><br><span class="line">            print(<span class="string">'partition nums:'</span> + str(encrypt_data_rdd.getNumPartitions()))</span><br><span class="line">            res_df = encrypt_data_rdd.mapPartitions(make_func(self.decryption_channel)).flatMap(</span><br><span class="line">                <span class="keyword">lambda</span> line: line).toDF()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"there's no data to decrypt"</span>)</span><br><span class="line">            res_df = self.encrypt_data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> old, new <span class="keyword">in</span> zip(self.columns1, self.columns):</span><br><span class="line">            res_df = res_df.withColumnRenamed(old, new)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res_df.select(*self.source_columns).distinct()</span><br></pre></td></tr></table></figure><h4 id="toLocalIetator"><a href="#toLocalIetator" class="headerlink" title="toLocalIetator()"></a>toLocalIetator()</h4><p><a href="https://www.waitingforcode.com/apache-spark/collecting-part-data-driver-rdd-tolocaiIterator/read" target="_blank" rel="noopener">https://www.waitingforcode.com/apache-spark/collecting-part-data-driver-rdd-tolocaiIterator/read</a></p><p>toLocalIetator()的工作原理类似于python中的<code>itertools.chain(*iterables)</code>，类似于下面的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure><p>它是将所有的partition形成一个类似于Ietator的形式，使用的时候，spark会将数据数据一部分一部分的从excutor端收集到driver端(从sparkui上也可以看出来)，并不会一次性将所有partition的数据全量收集到driver端，导致driver端的OOM，这也是一种导出大量数据时候的选择，但是数据需要经历一个从excutor向driver传输的过程，这个过程是比较费时的。一个使用案例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_mkdir</span><span class="params">(base_dir, filename, delete=False)</span>:</span></span><br><span class="line">    path = os.path.join(base_dir, filename)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(path) <span class="keyword">and</span> delete:</span><br><span class="line">        shutil.rmtree(path, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_csv</span><span class="params">(df:DataFrame, filename, threshold=<span class="number">1000000</span>, base_dir=<span class="string">'result/'</span>)</span>:</span></span><br><span class="line">    row_num = <span class="number">0</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    csvwrite = <span class="literal">None</span></span><br><span class="line">    csvfile = <span class="literal">None</span></span><br><span class="line">    first = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> df.toLocalIterator():</span><br><span class="line"><span class="comment">#         print(type(val.asDict()))</span></span><br><span class="line"><span class="comment">#         print(val.asDict())</span></span><br><span class="line"><span class="comment">#         print([v for k,v in val.asDict().items()])</span></span><br><span class="line">        <span class="keyword">if</span> first <span class="keyword">or</span> row_num&gt;=threshold:</span><br><span class="line">            print(filename + <span class="string">' write '</span> + str(index) + <span class="string">'...'</span> + str(threshold*index))</span><br><span class="line">            file_path = _mkdir(base_dir, filename, first)</span><br><span class="line">            csvfile = open(os.path.join(file_path, filename+<span class="string">'_%04d.csv'</span> % index), <span class="string">'w'</span>, buffering=<span class="number">4096</span>)</span><br><span class="line">            csvwrite = csv.writer(csvfile)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            row_num = <span class="number">0</span></span><br><span class="line">            first = <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        csvwrite.writerow(val)</span><br><span class="line">        csvfile.flush()</span><br><span class="line">            </span><br><span class="line">        row_num += <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="重分区写入集群，然后下载"><a href="#重分区写入集群，然后下载" class="headerlink" title="重分区写入集群，然后下载"></a>重分区写入集群，然后下载</h4><p>这种方案是：直接在集群内部设置适当的分区数，然后将数据写入集群内，最后将生成的文件下载下来。这种方式在数据量十分大的情况下，repartition的过程也是很费时的。</p><p>so，注意尽量不要使用repartition(numPartition, *col)，而是选择使用coalesce(numPartition)。这二者有很大区别：repartition会导致shuffle，会导致集群内部大量的数据传输，非常耗费时间；如果仅仅是将大量的partition合并成较少量的partition，可以直接使用coalesce，coalesce的原理是将多个partition直接合并成一个partition，是一个窄依赖，不会发生suffle，如果传入的参数大于当前的分区数，那么分区数不会发生变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：在spark上处理超大数据集的时候，有时候需要与外界系统进行交互或者需要将大数据量导出，下面讲解几种较方便的方案&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Spark应用" scheme="https://shang.at/categories/Spark%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Spark大数据集防止driver OOM" scheme="https://shang.at/tags/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E9%98%B2%E6%AD%A2driver-OOM/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-类的特殊方法</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/"/>
    <id>https://shang.at/post/Python学习-类的特殊方法/</id>
    <published>2020-07-01T02:22:24.000Z</published>
    <updated>2020-07-01T06:03:54.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：通过定义具有特殊名称的方法，类可以实现某些通过特殊语法调用的操作（例如算术运算或下标和切片）。这是Python运算符重载的方法，它允许类针对语言运算符定义自己的行为。例如，如果一个类定义了一个名为<code>__getitem__()</code>的方法，并且x是该类的实例，则<code>x[i]</code>大致等效于<code>type(x).__getitem__(x, i)</code>。除非另有说明，否则当未定义适当的方法（通常为<code>AttributeError</code>或<code>TypeError</code>）时，尝试执行操作会引发异常。</p><p>将特殊方法设置为<code>None</code>表示相应的操作不可用。例如，如果一个类将<code>__iter__()</code>设置为<code>None</code>，则该类不可迭代，因此在其实例上调用<code>iter()</code>会引发<code>TypeError</code>（而不会回到<code>__getitem__()</code>）。</p><p>默认情况下，我们自定义的类，它的这些特殊方法都有默认的实现。</p></blockquote><a id="more"></a><p>参考官网</p><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/reference/datamodel.html</a></p><h1 id="Basic-customization"><a href="#Basic-customization" class="headerlink" title="Basic customization"></a>Basic customization</h1><h3 id="new"><a href="#new" class="headerlink" title="__new__"></a>__new__</h3><h3 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h3><h3 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h3><h3 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a>__repr__</h3><h1 id="Customizing-attribute-access"><a href="#Customizing-attribute-access" class="headerlink" title="Customizing attribute access"></a>Customizing attribute access</h1><h2 id="Customizing-module-attribute-access"><a href="#Customizing-module-attribute-access" class="headerlink" title="Customizing module attribute access"></a>Customizing module attribute access</h2><h2 id="Implementing-Descriptors"><a href="#Implementing-Descriptors" class="headerlink" title="Implementing Descriptors"></a>Implementing Descriptors</h2><h1 id="Customizing-class-creation"><a href="#Customizing-class-creation" class="headerlink" title="Customizing class creation"></a>Customizing class creation</h1><h2 id="Metaclasses"><a href="#Metaclasses" class="headerlink" title="Metaclasses"></a>Metaclasses</h2><h1 id="Customizing-instance-and-subclass-checks"><a href="#Customizing-instance-and-subclass-checks" class="headerlink" title="Customizing instance and subclass checks"></a>Customizing instance and subclass checks</h1><h1 id="Emulating-generic-types"><a href="#Emulating-generic-types" class="headerlink" title="Emulating generic types"></a>Emulating generic types</h1><h1 id="Emulating-callable-objects"><a href="#Emulating-callable-objects" class="headerlink" title="Emulating callable objects"></a>Emulating callable objects</h1><h1 id="Emulating-container-types"><a href="#Emulating-container-types" class="headerlink" title="Emulating container types"></a>Emulating container types</h1><h1 id="Emulating-numeric-types"><a href="#Emulating-numeric-types" class="headerlink" title="Emulating numeric types"></a>Emulating numeric types</h1><h1 id="With-Statement-Context-Managers"><a href="#With-Statement-Context-Managers" class="headerlink" title="With Statement Context Managers"></a>With Statement Context Managers</h1><h1 id="Special-method-lookup"><a href="#Special-method-lookup" class="headerlink" title="Special method lookup"></a>Special method lookup</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：通过定义具有特殊名称的方法，类可以实现某些通过特殊语法调用的操作（例如算术运算或下标和切片）。这是Python运算符重载的方法，它允许类针对语言运算符定义自己的行为。例如，如果一个类定义了一个名为&lt;code&gt;__getitem__()&lt;/code&gt;的方法，并且x是该类的实例，则&lt;code&gt;x[i]&lt;/code&gt;大致等效于&lt;code&gt;type(x).__getitem__(x, i)&lt;/code&gt;。除非另有说明，否则当未定义适当的方法（通常为&lt;code&gt;AttributeError&lt;/code&gt;或&lt;code&gt;TypeError&lt;/code&gt;）时，尝试执行操作会引发异常。&lt;/p&gt;
&lt;p&gt;将特殊方法设置为&lt;code&gt;None&lt;/code&gt;表示相应的操作不可用。例如，如果一个类将&lt;code&gt;__iter__()&lt;/code&gt;设置为&lt;code&gt;None&lt;/code&gt;，则该类不可迭代，因此在其实例上调用&lt;code&gt;iter()&lt;/code&gt;会引发&lt;code&gt;TypeError&lt;/code&gt;（而不会回到&lt;code&gt;__getitem__()&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;默认情况下，我们自定义的类，它的这些特殊方法都有默认的实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="Python类的特殊方法" scheme="https://shang.at/tags/Python%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-JMH</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-JMH/"/>
    <id>https://shang.at/post/Java学习-JMH/</id>
    <published>2020-06-30T15:13:41.000Z</published>
    <updated>2020-07-05T01:38:55.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：本节学习Java准测试工具套件-JMH</p></blockquote><a id="more"></a><p>官网：<a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jmh/</a></p><p>官方样例：<br><a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/" target="_blank" rel="noopener">http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/</a></p><p>博客：<a href="https://www.xncoding.com/2018/01/07/java/jmh.html" target="_blank" rel="noopener">https://www.xncoding.com/2018/01/07/java/jmh.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：本节学习Java准测试工具套件-JMH&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JAVA-JMH" scheme="https://shang.at/tags/JAVA-JMH/"/>
    
  </entry>
  
  <entry>
    <title>算法-动态规划</title>
    <link href="https://shang.at/post/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://shang.at/post/算法-动态规划/</id>
    <published>2020-06-29T17:54:22.000Z</published>
    <updated>2020-07-13T23:48:37.398Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：动态规划是高级的算法思想，本节主要记录DP的分析思路</p></blockquote><a id="more"></a><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>其本质是动态递推</p></blockquote><ol><li>避免人肉递归。可以尝试画出递归树</li><li>找到<strong>最近最简</strong>方法，将其拆解成可重复解决的问题</li><li>如何找到<strong>最近最简方法</strong>：数学归纳法思维</li><li>如何区分DP问题：<code>DP一般会被用来求解最值问题</code></li></ol><blockquote><p>DP与递归和分治的联系</p></blockquote><ol><li>DP与 递归或者分治没有根本上的却别</li><li>共性：找到重复子问题</li><li>差异性：DP有最优子结构，中途可以淘汰次优解</li></ol><h1 id="实战例题"><a href="#实战例题" class="headerlink" title="实战例题"></a>实战例题</h1><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf7saakd9nj30nm0hn3zw.jpg" alt="image-20200528065512796"></p><p>傻递归 - 自顶向下</p><p>画出递归树</p><p>时间复杂度：每计算一个节点，需要计算其余的两个节点，以此类推下去，这是一个二叉树的结构，所以它的时间复杂度是O($2^n$)的</p><p>优化：</p><ul><li><p>加入备忘录</p><p>在傻递归的基础上，加入一个缓存，以达到避免重复子问题的重复计算的问题</p></li><li><p>使用DP的思维解决 - 自底向上</p></li></ul><p>DP三步曲</p><ol><li><p>找到重复子问题</p><p>根据数学归纳法：要计算第n个斐波那契数，那么我们只需要计算第n-1和n-2个斐波那契数就可以了</p></li><li><p>状态定义 - 且找到base case</p><p>假设使用a[i]表示第i个斐波那契数，那么f[i] = f[i-1]+f[i-2] 且f[0]=0,f[1]=1</p></li><li><p>DP方程</p><script type="math/tex; mode=display">f(n)=\left\{\begin{aligned}0 &,& n=0 \\1 &,& n=1 \\f(n-1)+f(n-2) &,& n>1\end{aligned}\right.</script></li></ol><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfa9koughqj30ij0ebjsi.jpg" alt="image-20200530102415327"></p><p>考虑下变体：</p><ul><li>不止可以上1阶或2阶：可以上1、2、3阶等</li><li>可以上1 2 3阶，且相邻的两个步伐不能相同，该如何设计</li></ul><p>本体：</p><script type="math/tex; mode=display">f(n)=\left\{\begin{aligned}1 &,& n=1 \\2 &,& n=2 \\f(n-1)+f(n-2) &,& n>2\end{aligned}\right.</script><p>变体1：</p><script type="math/tex; mode=display">f(n)=\left\{\begin{aligned}1 &,& n=1 \\2 &,& n=2 \\4 &,& n=3 \\f(n-1)+f(n-2)+f(n-3) &,& n>3\end{aligned}\right.</script><p>变体2：</p><p>定义dp[0…2][i]，</p><p>​    dp[0][i]表示到达i最后一次走了1步；</p><p>​    dp[1][i]表示到达i最后一次走了2步；</p><p>​    dp[2][i]表示到达i最后一次走了3步</p><p>那么</p><p>​    dp[0][i]=dp[1][i-1]+dp[2][i-1]；到当前台阶走了1步，那么前面只能再选最后一次走了2步和3步的</p><p>​    dp[1][i]=dp[0][i-2]+dp[2][i-2]；到当前台阶走了2步，那么前面只能再选最后一次走了1步和3步</p><p>​    dp[2][i]=dp[0][i-3]+dp[1][i-3]    到当前台阶走了3步，那么前面只能再选最后一次走了1步和2步的</p><p>结果为：dp[0][-1]+dp[1][-1]+dp[2][-1]，即到达n的所有步伐的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeClimbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>: <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># dp[0][i] 最后一次走了1步到达 i</span></span><br><span class="line">    <span class="comment"># dp[1][i] 最后一次走了2步到达 i</span></span><br><span class="line">    <span class="comment"># dp[2][i] 最后一次走了3步到达 i</span></span><br><span class="line">    dp = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>] + [<span class="number">0</span>] * (n - <span class="number">3</span>),  <span class="comment"># 最后一次走1步</span></span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>] + [<span class="number">0</span>] * (n - <span class="number">3</span>),  <span class="comment"># 最后一次走2步</span></span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] + [<span class="number">0</span>] * (n - <span class="number">3</span>)   <span class="comment"># 最后一次走3步</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n):</span><br><span class="line">        <span class="comment"># 到当前台阶走了1步，那么前面只能再选最后一次走了2步和3步的</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">1</span>][i - <span class="number">1</span>] + dp[<span class="number">2</span>][i - <span class="number">1</span>]  </span><br><span class="line">        <span class="comment"># 到当前台阶走了2步，那么前面只能再选最后一次走了1步和3步的</span></span><br><span class="line">        dp[<span class="number">1</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>] + dp[<span class="number">2</span>][i - <span class="number">2</span>]  </span><br><span class="line">        <span class="comment"># 到当前台阶走了3步，那么前面只能再选最后一次走了1步和2步的</span></span><br><span class="line">        dp[<span class="number">2</span>][i] = dp[<span class="number">0</span>][i - <span class="number">3</span>] + dp[<span class="number">1</span>][i - <span class="number">3</span>]  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>] + dp[<span class="number">1</span>][<span class="number">-1</span>] + dp[<span class="number">2</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9c76vxnoj31b00ps77e.jpg" alt="image-20200529150931667"></p><p>略过递归方案，直接上DP</p><p>DP问题三步曲</p><ol><li><p>找到重复子问题</p><p>根据数学归纳法：已知某金额所需的最少硬币数，可得其他金额的所需最少硬币数</p></li><li><p>状态定义</p><p>假设dp[i]表示，金额为i时需要的最少硬币数，那么因为有coins个硬币可选，所以dp[i]=min(dp[i-k] for k in coins) + 1，加1表示要选择一个面值为k的硬币</p><p>dp初始值为mount+1，因为金额为amout，所需硬币最多为amout个1元硬币，长度为amout+1</p><p>dp[0]=0，表示当金额为0时，需要的硬币数也为0</p><p>最终结果：dp[amout]</p></li><li><p>DP方程</p></li></ol><script type="math/tex; mode=display">f(n) = \left\{\begin{aligned}0 &,& n=0 \\1 &,& n=1 \\min(f(n-k))+1 &,& k \in coins \\\end{aligned}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> coin &lt;= i:</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] &lt; amount + <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9d1sl4wtj30xu0u0n2h.jpg" alt="image-20200529153859627"></p><p>直接DP三步曲</p><ol><li><p>找到重复子问题</p><p>要求从位置(i,j)到END的不同路径数，由于从某个位置出发只能向右或向下走，如果我知道了从(i+1, j)和从(i,j+1)到END的路径数，那么我就能得到<script type="math/tex">path_{i,j}</script>，<script type="math/tex">path_{i,j}</script>=<script type="math/tex">path_{i+1,j}</script>+<script type="math/tex">path_{i,j+1}</script></p></li><li><p>状态定义</p><p>定义dp[m][n]数组，表示棋盘，每个元素表示从该位置出发，到END的不同路径数</p><p>dp[][n]=1，右边界全为1，因为右边界的位置到END，路径数都是1</p><p>dp[m][]=1，下边界全为1，因为下边界的位置到END，路径数都是1</p><p>遍历方向：从END位置开始向上遍历</p><p>最终结果：dp[0][0]</p></li><li><p>DP方程</p></li></ol><script type="math/tex; mode=display">f(x,y) = \left\{\begin{aligned}1 &,& x=m\\1 &,& y=n\\f(x+1, y)+f(x, y+1) &,& 0 \leq x < m \& 0 \leq y < n\end{aligned}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化dp数组，左边界和右边界都初始化为1</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">if</span> j == m - <span class="number">1</span> <span class="keyword">or</span> i == n - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 空间压缩：我们只需要一维的数组就可以存下路径的变化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化dp数组为 1</span></span><br><span class="line">        dp = [<span class="number">1</span>] * m</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j] = dp[j] + dp[j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9gw1sj0kj30xj0u0jx7.jpg" alt="image-20200529175152160"></p><p>直接DP三步曲</p><ol><li><p>找到重复子问题</p><p>要求从位置(i,j)到END的不同路径数，由于从某个位置出发只能向右或向下走，如果我知道了从(i+1, j)和从(i,j+1)到END的路径数，那么我就能得到<script type="math/tex">path_{i,j}</script>，<script type="math/tex">path_{i,j}=path_{i+1,j}+path_{i,j+1}</script></p></li><li><p>状态定义</p><p>定义dp[m][n]数组，表示棋盘，每个元素表示从该位置出发，到END的不同路径数</p><p>dp[][n]=1，右边界最后一个障碍物之后全为1，最后一个障碍物及之前的位置全为0，因为右边界一旦出现了障碍物，那么在这之前的位置的路径就都被截断了</p><p>dp[m][]=1，下边界最后一个障碍物之后全为1，最后一个障碍物及之前的位置全为0，因为下边界一旦出现了障碍物，那么在这之前的位置的路径就都被截断了</p><p>需要注意的是：棋盘上为1的位置不能走，那个位置的路径数为0</p><p>遍历方向：从END位置开始遍历</p><p>最终结果：dp[0][0]</p></li><li><p>DP方程</p></li></ol><script type="math/tex; mode=display">f(x,y) = \left\{\begin{aligned}0 &,& x=m\&x\leq lastcol(lastrow表示下边界最后一个障碍物的位置)\\0 &,& y=n\&y\leq lastrow(lastrow表示右边界最后一个障碍物的位置)\\1 &,& x=m\&x>lastcol(lastrow表示下边界最后一个障碍物的位置)\\1 &,& y=n\&y>lastrow(lastrow表示右边界最后一个障碍物的位置)\\0 &,& obstacleGrid(x, y)=1\\f(x-1, y)+f(x, y-1) &,& 0 \leq x < m \& 0 \leq y < n\end{aligned}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(obstacleGrid[<span class="number">0</span>]), len(obstacleGrid)</span><br><span class="line">        <span class="comment"># if obstacleGrid[-1][-1] == 1 or obstacleGrid[0][0] == 1: return 0  # 起点和终点为1，直接返回0</span></span><br><span class="line">        <span class="comment"># if n == 1:  # 只有一行</span></span><br><span class="line">        <span class="comment">#     if sum(obstacleGrid[0]) &gt;= 1:  # 行出现了1</span></span><br><span class="line">        <span class="comment">#         return 0</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment"># if m == 1:  # 只有一列</span></span><br><span class="line">        <span class="comment">#     if sum(list(chain(*obstacleGrid))) &gt;= 1:  # 列出现了1</span></span><br><span class="line">        <span class="comment">#         return 0</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment"># 如果 最后一行或最后一列出现了1，那么1出现的位置及之前的位置和1没有区别</span></span><br><span class="line">        last_row, last_col = <span class="number">-1</span>, <span class="number">-1</span>  <span class="comment"># 标记最后一行(列)出现障碍的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">                last_row = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">-1</span>][i] == <span class="number">1</span>:</span><br><span class="line">                last_col = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据棋盘的最后一行和最后一列初始化 dp数组</span></span><br><span class="line">        <span class="comment"># 包含了 起点和终点为1 的情况</span></span><br><span class="line">        <span class="comment"># 包含了 只有一行和只有一列的情况</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">if</span> i &gt; last_col <span class="keyword">and</span> j == n - <span class="number">1</span> <span class="keyword">or</span> j &gt; last_row <span class="keyword">and</span> i == m - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span></span><br><span class="line">              range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles1</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid <span class="keyword">or</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 状态定义 - base case</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示从i,j到达finish位置的路径数</span></span><br><span class="line">        <span class="comment"># 初始化为0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n  <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 特殊考虑右边界和下边界:找到右边界和下边界最后一个障碍物的位置</span></span><br><span class="line">        <span class="comment"># 从后往前找，不用从前往后 全部遍历</span></span><br><span class="line">        last_col, last_row = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># 遍历状态</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>: <span class="comment"># 遇到障碍物</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 在遍历状态的过程中记录 右边界和下边界 最后一个障碍物的位置</span></span><br><span class="line">                    last_col = max(last_col, j) <span class="keyword">if</span> i==m<span class="number">-1</span> <span class="keyword">else</span> last_col  </span><br><span class="line">                    last_row = max(last_row, i) <span class="keyword">if</span> j==n<span class="number">-1</span> <span class="keyword">else</span> last_row</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 正常的格子</span></span><br><span class="line">                    <span class="keyword">if</span> i&lt;m<span class="number">-1</span> <span class="keyword">and</span> j&lt;n<span class="number">-1</span>: <span class="comment"># 不在右边界和下边界</span></span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">elif</span> i==m<span class="number">-1</span>: <span class="comment"># 下边界:如果当前位置是在下边界的最后一个障碍物之后，那么赋值1，否则赋值0</span></span><br><span class="line">                        dp[i][j] = <span class="number">1</span> <span class="keyword">if</span> j&gt;last_col <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> j==n<span class="number">-1</span>: <span class="comment"># 右边界:如果当前位置是在右边界的最后一个障碍物之后，那么赋值1，否则赋值0</span></span><br><span class="line">                        dp[i][j] = <span class="number">1</span> <span class="keyword">if</span> i&gt;last_row <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 答案为dp[0][0]         </span></span><br><span class="line">        <span class="comment"># print(last_col, last_row)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dp空间压缩：实际上我们在进行递推的时候，只需要一维数组就可以</span></span><br><span class="line">    <span class="comment"># 为什么能做到这样的空间压缩？</span></span><br><span class="line">    <span class="comment"># 当开始遍历上一层(i--)，dp[j]的值是保留了下一层的值，所以dp[j] += dp[j+1]是相当于之前的  dp[i][j] = dp[i+1][j] + dp[i][j+1] ~~~！！！！</span></span><br><span class="line">    <span class="comment"># 同时也可以避免右边界和下边界的 特殊情况，因为一维的情况下 相当于是已经自动加了限制</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(obstacleGrid[<span class="number">0</span>]), len(obstacleGrid)</span><br><span class="line">        dp = [<span class="number">0</span>] * m</span><br><span class="line">        dp[m - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:  <span class="comment"># 当前位置为障碍物</span></span><br><span class="line">                    dp[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> j &lt; m - <span class="number">1</span>:  <span class="comment"># 因为要使用下一个坐标，这里要检测坐标的合法性，防止指针越界</span></span><br><span class="line">                    dp[j] += dp[j + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfa5gmnx4bj30xx0u044x.jpg" alt="image-20200530080158059"></p><p>思维：DP最终会归结到一个状态数组中，所以拿到一个这样的题目后，就往一维状态数组上靠拢，一维搞不定，就尝试用二维数组，再不行就三维…然后依靠数学归纳法进行推导，看是否能根据已知内容的位置 推导出当前位置的值</p><p>直接上DP三步曲</p><ol><li><p>找到重复子问题</p><p>abcde和abc的问题可以由下列的二维表格描述，如果要求某个位置的值，只需要知道它之前的某些位置即可</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">d</th><th style="text-align:center">e</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">LCS(a,a)=1</td><td style="text-align:center">LCS(a,ab)=1</td><td style="text-align:center">LCS(a,abc)=1</td><td style="text-align:center">LCS(a,aabcd)=1</td><td style="text-align:center">LCS(a,abcde)=1</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">LCS(ac,a)=1</td><td style="text-align:center">LCS(ac,ab)=1</td><td style="text-align:center">LCS(ac,abc)=2</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">LCS(ace,abcde)=3</td></tr></tbody></table></div><ol><li><p>定义状态</p><p>dp[i][j]，i表示第一个字符串的位置编号，j表示第二个字符串的位置编号，整体表示两个子串的最长公共子序列的长度</p><p>dp长度初始化为text1.length+1*text2.length+1，因为至少要包含没有字符的情况</p><p>初始值：dp[0][0]=0</p><p>遍历方向：从前往后。因为base case在前部</p><p>最终结果：dp[text1.length][text2.length]</p></li><li><p>DP方程</p></li></ol><script type="math/tex; mode=display">f(x, y) = \left\{\begin{aligned}0 &,& x=0\&y=0 \\max(f(x-1, y), f(x, y-1)) &,& text1(x)!=text2(y) \\f(x-1, y-1)+1 &,& text1(x)=text2(y) \\\end{aligned}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence1</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(text1), len(text2)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[j - <span class="number">1</span>] == text2[i - <span class="number">1</span>]:  <span class="comment"># 当前位置的两个字符一样，取对角的值再加1(加上自身)</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 当前位置的两个字符不一样，取两个字符对应的最大值</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dp空间压缩：发现求当前位置的值，只需要left和last_line的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(text1), len(text2)</span><br><span class="line">        <span class="comment"># 当前位置，当前位置的左一位置</span></span><br><span class="line">        curr, left = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 上一行的值</span></span><br><span class="line">        last_line = [<span class="number">0</span>] * (m + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[j - <span class="number">1</span>] == text2[i - <span class="number">1</span>]:  <span class="comment"># 当前位置的两个字符一样，取对角的值再加1(加上自身)</span></span><br><span class="line">                    curr = last_line[j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 当前位置的两个字符不一样，取两个字符对应的最大值</span></span><br><span class="line">                    curr = max(last_line[j], left)</span><br><span class="line">                <span class="comment"># 根据当前计算的结果 更新上一行，遍历到下一行的时候，正好可以用</span></span><br><span class="line">                <span class="keyword">if</span> j == m:  <span class="comment"># 换行：可以更新当前位置的up位置元素，且把left重置为0</span></span><br><span class="line">                    last_line[j - <span class="number">1</span>], last_line[j], left = left, curr, <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 不换行：不能更新up位置，因为在同一行中遍历的时候，要使用原始的值</span></span><br><span class="line">                    last_line[j - <span class="number">1</span>], left = left, curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfa7wqal6mj30ku0degmu.jpg" alt="image-20200530092638716"></p><p>直接DP三步曲</p><ol><li><p>找到重复子问题</p><p>要想求得到达当前位置的最小路径和，那么我只需要知道到达当前位置的up和up_left最小路径和即可</p></li><li><p>状态定义</p><p>dp[i][j]，i和j分别表示矩阵的坐标，整体表示到达该坐标的最小路径和</p><p>dp[0][0]为矩阵的第一个元素值</p><p>最终结果：min(dp[-1])</p></li><li><p>DP方程</p></li></ol><script type="math/tex; mode=display">f(x, y) = \left\{\begin{aligned}matrix(0, 0) &, & x=0\&y=0 \\min(f(x-1, y), f(x-1, y-1)) + matrix(x,y) &,& 0\leq x \& 0\leq y\end{aligned}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal1</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(triangle[<span class="number">-1</span>]), len(triangle)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> triangle]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(triangle[i]):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>: dp[i][j] = dp[i - <span class="number">1</span>][j] + val</span><br><span class="line">                <span class="keyword">elif</span> j == len(triangle[i]) - <span class="number">1</span>: dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + val</span><br><span class="line">                <span class="keyword">else</span>: dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dp空间压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(triangle[<span class="number">-1</span>]), len(triangle)</span><br><span class="line"></span><br><span class="line">        dp = triangle</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j, val <span class="keyword">in</span> enumerate(triangle[i]):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>: dp[i][j] = dp[i - <span class="number">1</span>][j] + val</span><br><span class="line">                <span class="keyword">elif</span> j == len(triangle[i]) - <span class="number">1</span>: dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + val</span><br><span class="line">                <span class="keyword">else</span>: dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfacvt7tj7j30m609iq3f.jpg" alt="image-20200530121844939"></p><p>DP三步曲</p><ol><li><p>找到重复子问题</p><p>以某个位置(i,j)为右下角的正方形的边长，可以根据当前位置的up、left、left_up三个位置确定出来</p><p>状态定义</p><p>dp[i][j]表示以(i,j)为右下角的正方形的边长，那么如果(i,j)为0，dp[i][j]=0；否则dp[i][j]=min(up,left,up_left)+1</p><p>加1的目的是，至少包含它本身</p></li><li><p>DP方程</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcjq9qu41j30j801mq2y.jpg" alt="image-20200601094644553"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(matrix[<span class="number">0</span>]), len(matrix)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        max_edge = dp[<span class="number">0</span>][<span class="number">0</span>] = int(matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, m):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span> <span class="keyword">if</span> matrix[i][j] == <span class="string">'0'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span> <span class="keyword">if</span> matrix[i][j] == <span class="string">'0'</span> <span class="keyword">else</span> min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                max_edge = max(dp[i][j], max_edge)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_edge * max_edge</span><br></pre></td></tr></table></figure><h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfa7xf1ixuj30mq0bkmyr.jpg" alt="image-20200530092718495"></p><p>DP三步曲</p><ol><li><p>找到重复子问题</p><p>当只有一个气球时，只需要戳一次即可</p><p>当有两个气球时，也只需要戳一次</p><p>当有三个气球时，那么肯定要先戳中间那一个</p><p>当有四个气球时，那么就要</p></li><li><p>状态定义</p><p>气球的个数为n</p><p>假设dp[i][j]表示序号在(i,j)之间的获得的硬币最大值，那么我们需要通过遍历(i,j)之间的所有序号，求出dp[i][k]和dp[k][j]，因为dp[i][j]=dp[i][k]+dp[k][j]+k，</p><p>最终结果：dp[0][n+1]</p></li><li><p>DP方程</p></li></ol><script type="math/tex; mode=display"><Empty \space Math \space Block></script><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf7ru9d1mfj31bg0p8n24.jpg" alt="image-20200528063944746"></p><p>略过递归方案，直接上DP</p><p>DP问题三步曲</p><ol><li><p>找到重复子问题</p><p>根据数学归纳法：如果已知小偷在第i-1个房间对应的最高金额，那么小偷在第i个房间的对应的最高金额有以下两种情况</p><ul><li>小偷偷了第i-1房间：那么小偷势必不能偷第i个房间，那么这个时候小偷偷的金额应该继承上一个值</li><li>小偷没有偷第i-1房间：那么小偷一定要偷第i个房间(因为是求的最大值)，这个时候小偷偷的金额应该是上一个值加上第i个房间的金额</li></ul></li><li><p>状态定义</p><p>那么我们怎么表示某一个房间偷与不偷呢？此时我们可以考虑在一维的基础之上加一维附加这个状态，用dp[i][0]表示没有偷第i个房间，dp[i][1]表示偷了第i个房间，nums[i]表示第i间房的金额，那么</p><ul><li>计算没有偷i房的时候在i的最大金额：dp[i][0]=max(dp[i-1][0], dp[i-1][1])</li><li>计算偷i房的时候在i的最大金额：dp[i][1]=dp[i-1][0]+nums[i]</li></ul><p>dp的初始值为全为0，长度为n+1，</p><p>第0个元素表示房间数为0时，能偷到的金额为0，</p><p>第n个元素表示到达最后一个房间，能偷到的金额为多少</p><p>遍历从1开始</p><p>最终的结果：max(dp[n][0], dp[n][1])</p></li><li><p>DP方程定义</p></li></ol><script type="math/tex; mode=display">f(n,0) =\left\{\begin{aligned}0 &,& n=0 \\max(f(n-1, 0), f(n-1, 1)) &,& n>1\end{aligned}\right.</script><script type="math/tex; mode=display">f(n,1) =\left\{\begin{aligned}0 &,& n=0 \\f(n-1, 0)+nums(n) &,& n>1\end{aligned}\right.</script><script type="math/tex; mode=display">res = max(f(n, 0), f(n, 1))</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)  <span class="comment"># 房间个数</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>])  <span class="comment"># 不偷第i间房</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>]  <span class="comment"># 偷第i间房</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>])  <span class="comment"># 返回第i间房 偷与不偷的最大金额</span></span><br></pre></td></tr></table></figure><p>DP问题三步曲-version2</p><blockquote><p>第一个版本中，我们考虑的时候，并不知道小偷有没有偷某个房间，所以加了一个维度表示某个房间偷与不偷的 对应的最大金额</p><p>这个版本中，我们换个思路，可以肯定的是，小偷一定会偷其中一间房，也就是说，如果我们假定某间房必偷的话，那么我们最终的结果应该是所有结果的最大值</p></blockquote><ol><li><p>找到重复子问题</p><p>根据数学归纳法：由于小偷不能偷连续的两间房，那么我们如果要计算第i间房最大金额，该怎么计算呢？这个时候，前一间房要么偷了，要么没偷，如果前一间房没偷，那么看前两间房偷没偷，前两间房如果没偷，那就继续往前推</p></li><li><p>状态定义-DP数组含义及base case</p><p>dp[i]表示当偷到第i间房时的最大金额，不管第i间房偷与不偷，</p><p>dp[i]=max(dp[i-1], dp[i-2]+nums[i])  表示：偷与不偷i-1的时候，在第i间房的最大金额</p><p>dp初始化全为0，长度为n+2</p><p>dp[0], dp[1]表示第1间房前1间、两间的金额都为0</p><p>遍历从2开始</p><p>最终结果：max(dp)</p></li><li><p>DP方程</p></li></ol><script type="math/tex; mode=display">f(n) = \left\{\begin{aligned}0 &,& n=-1 \\0 &,& n=0 \\max(f(n-1), f(n-2)+nums(n)) &,& n>0\end{aligned}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robnn</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">2</span>):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ====&gt; 优化，去掉最后的取最大值的函数，且降低空间复杂度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        i_2, i_1, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 前两间房的最大金额，前一间房的最大金额，当前房间的最大金额</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 2])</span></span><br><span class="line">            <span class="comment"># 更新偷到当前房间的最大金额</span></span><br><span class="line">            res = max(i_1, i_2 + nums[i])</span><br><span class="line">            <span class="comment"># 上一个res变成前一间房</span></span><br><span class="line">            <span class="comment"># 上一个i_1变成前两间房</span></span><br><span class="line">            i_1, i_2 = res, i_1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggfqbp2v75j30wz0u0q70.jpg" alt="image-20200705071208466"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggfqbzdxhbj31260qstb1.jpg" alt="image-20200705071229047"></p><p>DP三步曲</p><ol><li><p>找到重复子问题</p><p>要想知道p[1…j]是否匹配s[1…i]，那么需要知道p[0…j-1]与s[0…i-1]是否匹配</p></li><li><p>状态定义-DP数组含义及base case</p><p>dp[i][j]表示p[1…j]是否匹配s[1…i]</p><p>dp[0][0]=True</p><p>如果p和s都是空字符串，那么两者是匹配的，直接返回True</p><p>如果s为空，p不为空且只包含<code>*</code>这一种字符，则两者匹配，直接返回True</p><p>如果p为空，s不为空，则两者不匹配，直接返回False</p><p>如果s为空，p不为空且不止包含<code>*</code>这一种字符，则两者不匹配，直接返回False</p></li><li><p>状态转移方程</p><script type="math/tex; mode=display">dp[i][j] = \left\{\begin{aligned}dp[i-1][j-1] &,& s[i]=p[j] \\dp[i-1][j] ∨ dp[i][j-1] &,& p[j]='*' \\dp[i-1][j-1] &,& p[j]='?'\end{aligned}\right.</script></li></ol>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> s: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> (<span class="string">'*'</span> <span class="keyword">not</span> <span class="keyword">in</span> set(p) <span class="keyword">or</span> len(set(p))&gt;<span class="number">1</span>): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="literal">False</span>]*(len(p)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(p)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>]==<span class="string">'*'</span>: dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(p)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-1</span>]==<span class="string">'?'</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j<span class="number">-1</span>]==<span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>] | dp[i<span class="number">-1</span>][j]</span><br><span class="line">        print(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[len(s)][len(p)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：动态规划是高级的算法思想，本节主要记录DP的分析思路&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://shang.at/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="https://shang.at/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-python3.6-dict有序且效率更高</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-python3-6-dict%E6%9C%89%E5%BA%8F%E4%B8%94%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98/"/>
    <id>https://shang.at/post/Python学习-python3-6-dict有序且效率更高/</id>
    <published>2020-06-28T23:22:42.000Z</published>
    <updated>2020-07-02T15:49:24.809Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/xieqiankun/p/python_dict.html" target="_blank" rel="noopener">https://www.cnblogs.com/xieqiankun/p/python_dict.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xieqiankun/p/python_dict.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/xieqiankun/p/pytho
      
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="python的dict" scheme="https://shang.at/tags/python%E7%9A%84dict/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop学习</title>
    <link href="https://shang.at/post/Hadoop%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shang.at/post/Hadoop学习/</id>
    <published>2020-06-26T16:34:48.000Z</published>
    <updated>2020-07-15T09:10:12.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p>大数据</p><p>分布式数据存储</p><p>​    数据一致性 - CAP - poxes</p><p>主从</p><p>​    单点故障 - HA</p><p>​    内存压力 - 分片管理</p><p>分布式计算 - 计算向数据移动</p><p>​    </p><p>mapreduce</p><p>数据以一条记录为单位及经过map方法映射成KV，相同的K为一组，这一组数据条用一次reduce方法，在方法内迭代计算一组数据。</p><p>迭代器模式，数据集一般是用迭代计算的方式</p><p>​    </p><p>为什么要有split？split只是一个逻辑上的概念。</p><p>​    与数据物理存储上的block解耦(软件工程上：加一层解耦)，默认情况下，split等于block，但是也可以小于block，也可能大于block</p><p>集群内部的通信采用RPC的方式，同时只会发生client向server发送请求，server处理完之后返回client响应结果，sever不会主动向client发送消息</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hadoop学习" scheme="https://shang.at/categories/Hadoop%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Hadoop" scheme="https://shang.at/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop学习-Yarn-Scheduler</title>
    <link href="https://shang.at/post/Hadoop%E5%AD%A6%E4%B9%A0-Yarn-Scheduler/"/>
    <id>https://shang.at/post/Hadoop学习-Yarn-Scheduler/</id>
    <published>2020-06-25T06:24:45.000Z</published>
    <updated>2020-06-25T06:25:31.320Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Hadoop学习" scheme="https://shang.at/categories/Hadoop%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Yarn-Scheduler" scheme="https://shang.at/tags/Yarn-Scheduler/"/>
    
  </entry>
  
</feed>
