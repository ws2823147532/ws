<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>努力，奋斗</title>
  
  <subtitle>记录学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shang.at/"/>
  <updated>2020-06-13T02:18:33.907Z</updated>
  <id>https://shang.at/</id>
  
  <author>
    <name>王尚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java学习-底层知识总结</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://shang.at/post/java学习-底层知识总结/</id>
    <published>2020-06-13T00:20:45.000Z</published>
    <updated>2020-06-13T02:18:33.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>JVM：Java Virtual Machine</p><p>JMM：Java Memory Model</p><h2 id="1：JVM基础知识"><a href="#1：JVM基础知识" class="headerlink" title="1：JVM基础知识"></a>1：JVM基础知识</h2><ol><li>什么是JVM</li><li>常见的JVM</li></ol><h2 id="2：ClassFileFormat"><a href="#2：ClassFileFormat" class="headerlink" title="2：ClassFileFormat"></a>2：ClassFileFormat</h2><h2 id="3：类编译-加载-初始化"><a href="#3：类编译-加载-初始化" class="headerlink" title="3：类编译-加载-初始化"></a>3：类编译-加载-初始化</h2><p>hashcode<br>锁的信息（2位 四种组合）<br>GC信息（年龄）<br>如果是数组，数组的长度</p><h2 id="4：JMM"><a href="#4：JMM" class="headerlink" title="4：JMM"></a>4：JMM</h2><p>new Cat()<br>pointer -&gt; Cat.class<br>寻找方法的信息</p><h2 id="5：对象"><a href="#5：对象" class="headerlink" title="5：对象"></a>5：对象</h2><p>1：句柄池 （指针池）间接指针，节省内存<br>2：直接指针，访问速度快</p><h2 id="6：GC基础知识"><a href="#6：GC基础知识" class="headerlink" title="6：GC基础知识"></a>6：GC基础知识</h2><p>栈上分配<br>TLAB（Thread Local Allocation Buffer）<br>Old<br>Eden<br>老不死 - &gt; Old</p><h2 id="7：GC常用垃圾回收器"><a href="#7：GC常用垃圾回收器" class="headerlink" title="7：GC常用垃圾回收器"></a>7：GC常用垃圾回收器</h2><p>new Object()<br>markword          8个字节<br>类型指针           8个字节<br>实例变量           0<br>补齐                  0<br>16字节（压缩 非压缩）<br>Object o<br>8个字节<br>JVM参数指定压缩或非压缩</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;p&gt;JVM：Java Virtual Machine&lt;/p&gt;
&lt;p&gt;JMM：Java Memory Model&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java底层" scheme="https://shang.at/tags/java%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>java学习-class文件格式</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>https://shang.at/post/java学习-class文件格式/</id>
    <published>2020-06-13T00:12:38.000Z</published>
    <updated>2020-06-13T00:18:59.170Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="class文件格式" scheme="https://shang.at/tags/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-metaclass实现单例</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-metaclass%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/"/>
    <id>https://shang.at/post/Python学习-metaclass实现单例/</id>
    <published>2020-06-12T01:35:16.000Z</published>
    <updated>2020-06-12T01:35:16.633Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java学习-运行时线程</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BA%BF%E7%A8%8B/"/>
    <id>https://shang.at/post/java学习-运行时线程/</id>
    <published>2020-06-11T03:40:56.000Z</published>
    <updated>2020-06-11T03:52:13.279Z</updated>
    
    <content type="html"><![CDATA[<p>一个Java进程启动之后，至少会创建以下几个线程：</p><ul><li>main</li><li>Finalizer</li><li>Reference Handler</li><li>Signal Dispatcher</li><li>Others: 用户自己创建的线程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个Java进程启动之后，至少会创建以下几个线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main&lt;/li&gt;
&lt;li&gt;Finalizer&lt;/li&gt;
&lt;li&gt;Reference Handler&lt;/li&gt;
&lt;li&gt;Signal Dispatcher&lt;/li&gt;
&lt;li&gt;Others: 用户自
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="运行时线程" scheme="https://shang.at/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习笔记-JOIN的算法实现</title>
    <link href="https://shang.at/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JOIN%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shang.at/post/数据结构与算法学习笔记-JOIN的算法实现/</id>
    <published>2020-06-10T06:40:09.000Z</published>
    <updated>2020-06-10T06:45:03.736Z</updated>
    
    <content type="html"><![CDATA[<h5 id="JOIN-INNER-JOIN"><a href="#JOIN-INNER-JOIN" class="headerlink" title="JOIN(INNER JOIN)"></a>JOIN(INNER JOIN)</h5><h5 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h5><h5 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h5><h5 id="FULL-JOIN"><a href="#FULL-JOIN" class="headerlink" title="FULL JOIN"></a>FULL JOIN</h5><h5 id="left-semi"><a href="#left-semi" class="headerlink" title="left_semi"></a>left_semi</h5><h5 id="left-anti"><a href="#left-anti" class="headerlink" title="left_anti"></a>left_anti</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;JOIN-INNER-JOIN&quot;&gt;&lt;a href=&quot;#JOIN-INNER-JOIN&quot; class=&quot;headerlink&quot; title=&quot;JOIN(INNER JOIN)&quot;&gt;&lt;/a&gt;JOIN(INNER JOIN)&lt;/h5&gt;&lt;h5 id=&quot;LEFT-JOIN&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://shang.at/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JOIN的算法实现" scheme="https://shang.at/tags/JOIN%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>java学习-JDK环境切换</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-JDK%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/"/>
    <id>https://shang.at/post/java学习-JDK环境切换/</id>
    <published>2020-06-10T05:40:50.000Z</published>
    <updated>2020-06-10T05:47:55.073Z</updated>
    
    <content type="html"><![CDATA[<p>近期，JDK版本更新十分频繁，如果要想快速切换JDK版本，可以通过linux的alias命令来简单实现：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> mac环境</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ~/.bash_profile</span><br><span class="line">export JAVA_8_HOME=$(/usr/libexec/java_home -v 1.8)</span><br><span class="line">export JAVA_9_HOME=$(/usr/libexec/java_home -v 9)</span><br><span class="line">export JAVA_10_HOME=$(/usr/libexec/java_home -v 10)</span><br><span class="line">export JAVA_11_HOME=$(/usr/libexec/java_home -v 11)</span><br><span class="line">export JAVA_HOME=$JAVA_8_HOME</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ~/.zshrc  注意要放到~/.zshrc文件的最下面</span><br><span class="line"><span class="meta">#</span> multi jdk config</span><br><span class="line">alias jdk8="export PATH=$JAVA_8_HOME/bin:$PATH"</span><br><span class="line">alias jdk9="export PATH=$JAVA_9_HOME/bin:$PATH"</span><br><span class="line">alias jdk10="export PATH=$JAVA_10_HOME/bin:$PATH"</span><br><span class="line">alias jdk11="export PATH=$JAVA_11_HOME/bin:$PATH"</span><br></pre></td></tr></table></figure><p>默认环境为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ java -version</span><br><span class="line">java version "1.8.0_144"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</span><br></pre></td></tr></table></figure><p>切换jdk9之后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ jdk9</span><br><span class="line">➜  ~ java -version</span><br><span class="line">java version "9.0.4"</span><br><span class="line">Java(TM) SE Runtime Environment (build 9.0.4+11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 9.0.4+11, mixed mode)</span><br></pre></td></tr></table></figure><p>这样就可以在当前的terminal session中使用jdk9的新特性了，比如jshell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期，JDK版本更新十分频繁，如果要想快速切换JDK版本，可以通过linux的alias命令来简单实现：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JDK环境切换" scheme="https://shang.at/tags/JDK%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>java学习-JVM虚拟机栈</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>https://shang.at/post/java学习-JVM虚拟机栈/</id>
    <published>2020-06-09T07:39:37.000Z</published>
    <updated>2020-06-09T07:40:05.128Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM虚拟机栈" scheme="https://shang.at/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>java学习-JVM疑问</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-JVM%E7%96%91%E9%97%AE/"/>
    <id>https://shang.at/post/java学习-JVM疑问/</id>
    <published>2020-06-05T09:01:58.000Z</published>
    <updated>2020-06-09T07:36:50.916Z</updated>
    
    <content type="html"><![CDATA[<p>在学习JVM的内存模型的时候，我有这样一些疑惑：</p><p>1、我们通常只是定义了堆大小(-Xms初始，-Xmx最大)，虚拟机栈大小(-Xss)。<br>但是我发现这并不能计算出一个java进程占用的全部内存大小。<br>以下是我自己理解的(JDK1.8)：<br>java进程占用的内存<br>​    =JVM管理的内存+非JVM管理的内存<br>​    =线程独立的内存+线程共享的内存<br>​    =n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)+堆内存(heap)+非堆内存(non-heap)+元空间(metaspace)+堆外内存(off-heap:direct memory)<br>其中：<br>​    JVM管理的内存：n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)+堆内存(heap)+非堆内存(non-heap)<br>​    非JVM管理的内存：元空间(metaspace)+堆外内存(off-heap:direct memory)<br>​    线程独立的内存：n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)，n是线程数<br>​    线程共享的内存：堆内存(heap)+非堆内存(non-heap)+元空间(metaspace)+对外内存(off-heap:direct memory)</p><p>2、在JDK1.7及以前，有个永久代(PermGen)，也就是文中说的方法区。这块区域也被称为非堆内存<br>​    那么在JDK1.8及以后，永久代变成了元空间，到了JVM管理之外了，那么JDK1.8及以后的版本中还有非堆内存(non-heap)的说法吗？如果有的话，是指什么呢？</p><p>3、关于线程独立的这块内存{n*(虚拟机栈内存+程序计数器内存+本地方法栈内存)，n是线程数}，它是完全独立于其他的内存的吗？<br>​    还是会分享堆内存，受到堆内存大小的限制<br>​    还是说Thread对象是建立在堆内存，然后每个Thread对应的虚拟机栈都是独立的吗？ 换句话说，随着Thread的增加(堆内存充足：还能给新的对象分配内存)，java进程占用的内存会越来越大—–我觉得这肯定不对，但是我却无法解释</p><p>4、我做了一些测试(JDK1.8)：<br>​    4.1、指定很小的堆内存，改变虚拟机栈大小<br>​        4.1.1、-Xms2m -Xmx2m -Xss16m 启动java进程，直到递归调用1,016,085深度，会报StackOverflowError<br>​        4.1.2、-Xms2m -Xmx2m -Xss8m 启动java进程，直到递归调用318,031深度，会报StackOverflowError<br>​    4.2、指定很小的堆内存，如-Xms2m -Xmx2m，最终会报OutOfMemoryError</p><p>我谈一下我的理解，首先，新创建的线程对象肯定是放在堆中的；每个线程独立的虚拟机栈，存放了很多的栈帧，每个栈帧实际上存放了局部变量表(和其他三部分)，每个栈帧对应了一个函数调用，在这个线程中执行的每个函数中的变量可能会存放在堆里面，也有可能会直接在栈上分配内存，因为这里有一个逃逸的概念(仅函数内部使用的局部变量直接在栈上分配内存，不会占用堆内存)。</p><p>所以在我的理解里面，如果虚拟机栈是一个完全独立于堆的内存，那么虚拟机栈就不会受到堆内存大小的限制(比如我上面做的实验：当堆内存远小于虚拟机栈大小，最终报的异常仍然是StackOverflowError，而不是OutOfMemoryError)</p><p>所以我才会想到，如果虚拟机栈是一个完全独立于堆的内存，无限的创建线程，每个线程的虚拟机栈如果都无限接近于-Xss分配的最大限度，那么最终会耗尽系统的所有 内存吧</p><p>我又做了一个实验，就是无限的创建线程，然后在调用start()的时候，报了OutOfMemoryError:unable to create new native thread的异常，看来操作系统在这里是对线程数是有限制的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习JVM的内存模型的时候，我有这样一些疑惑：&lt;/p&gt;
&lt;p&gt;1、我们通常只是定义了堆大小(-Xms初始，-Xmx最大)，虚拟机栈大小(-Xss)。&lt;br&gt;但是我发现这并不能计算出一个java进程占用的全部内存大小。&lt;br&gt;以下是我自己理解的(JDK1.8)：&lt;br&gt;ja
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM疑问" scheme="https://shang.at/tags/JVM%E7%96%91%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>java学习-基本类型和包装类型</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shang.at/post/java学习-基本类型和包装类型/</id>
    <published>2020-06-04T03:37:10.000Z</published>
    <updated>2020-06-04T06:32:35.963Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/baozhuangleixing.png" alt="image-20200604141908424"></p><p>Java 的每个基本类型都对应了一个包装类型，比如说 int 的包装类型为 Integer，double 的包装类型为 Double。基本类型和包装类型的区别主要有以下 4 点。</p><h3 id="01、包装类型可以为-null，而基本类型不可以"><a href="#01、包装类型可以为-null，而基本类型不可以" class="headerlink" title="01、包装类型可以为 null，而基本类型不可以"></a>01、包装类型可以为 null，而基本类型不可以</h3><p>别小看这一点区别，它使得包装类型可以应用于 POJO 中，而基本类型则不行。</p><p>POJO 是什么呢？这里稍微说明一下。</p><p>POJO 的英文全称是 <code>Plain Ordinary Java Object</code>，翻译一下就是，简单无规则的 Java 对象，只有属性字段以及 setter 和 getter 方法，示例如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 POJO 类似的，还有数据传输对象 DTO（Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象）、视图对象 VO（View Object，把某个页面的数据封装起来）、持久化对象 PO（Persistant Object，可以看成是与数据库中的表映射的 Java 对象）。</p><p>那为什么 POJO 的属性必须要用包装类型呢？</p><p>《阿里巴巴 Java 开发手册》上有详细的说明，我们来大声朗读一下（预备，起）。</p><blockquote><p>数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 <code>NullPointerException</code> 的异常。</p></blockquote><h3 id="02、包装类型可用于泛型，而基本类型不可以"><a href="#02、包装类型可用于泛型，而基本类型不可以" class="headerlink" title="02、包装类型可用于泛型，而基本类型不可以"></a>02、包装类型可用于泛型，而基本类型不可以</h3><p>泛型不能使用基本类型，因为使用基本类型时会编译出错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;int&gt; list = new ArrayList&lt;&gt;(); // 提示 Syntax error, insert &quot;Dimensions&quot; to complete ReferenceType</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>为什么呢？因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。</p><h3 id="03、基本类型比包装类型更高效"><a href="#03、基本类型比包装类型更高效" class="headerlink" title="03、基本类型比包装类型更高效"></a>03、基本类型比包装类型更高效</h3><p>基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。</p><p><img src="http://www.itwanger.com/assets/images/2019/11/java-int-integer-1.png" alt="img"></p><p>很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过 new 一个包装类型就显得非常笨重。</p><h3 id="03、两个包装类型的值可以相同，但却不相等"><a href="#03、两个包装类型的值可以相同，但却不相等" class="headerlink" title="03、两个包装类型的值可以相同，但却不相等"></a>03、两个包装类型的值可以相同，但却不相等</h3><p>两个包装类型的值可以相同，但却不相等——这句话怎么理解呢？来看一段代码就明明白白了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer chenmo = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">Integer wanger = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(chenmo == wanger); <span class="comment">// false</span></span><br><span class="line">System.out.println(chenmo.equals(wanger )); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>两个包装类型在使用“==”进行判断的时候，判断的是其指向的地址是否相等。chenmo 和 wanger 两个变量使用了 new 关键字，导致它们在“==”的时候输出了 false。</p><p>而 <code>chenmo.equals(wanger)</code> 的输出结果为 true，是因为 equals 方法内部比较的是两个 int 值是否相等。源码如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final int value;</span><br><span class="line"></span><br><span class="line">public int intValue() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">if (obj instanceof Integer) &#123;</span><br><span class="line">return value == ((Integer)obj).intValue();</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瞧，虽然 chenmo 和 wanger 的值都是 10，但他们并不相等。换句话说就是：<strong>将“==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符</strong>。</p><h3 id="04、自动装箱和自动拆箱"><a href="#04、自动装箱和自动拆箱" class="headerlink" title="04、自动装箱和自动拆箱"></a>04、自动装箱和自动拆箱</h3><p>既然有了基本类型和包装类型，肯定有些时候要在它们之间进行转换。把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p><p>在 Java SE5 之前，开发人员要手动进行装拆箱，比如说：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer chenmo = <span class="keyword">new</span> Integer(<span class="number">10</span>);  <span class="comment">// 手动装箱</span></span><br><span class="line"><span class="keyword">int</span> wanger = chenmo.intValue();  <span class="comment">// 手动拆箱</span></span><br></pre></td></tr></table></figure><p>Java SE5 为了减少开发人员的工作，提供了自动装箱与自动拆箱的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer chenmo  = <span class="number">10</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> wanger = chenmo;     <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><p>上面这段代码使用 JAD 反编译后的结果如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer chenmo = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> wanger = chenmo.intValue();</span><br></pre></td></tr></table></figure><p>也就是说，自动装箱是通过 <code>Integer.valueOf()</code> 完成的；自动拆箱是通过 <code>Integer.intValue()</code> 完成的。理解了原理之后，我们再来看一道老马当年给我出的面试题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1）基本类型和包装类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">Integer b = <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）两个包装类型</span></span><br><span class="line">Integer c = <span class="number">100</span>;</span><br><span class="line">Integer d = <span class="number">100</span>;</span><br><span class="line">System.out.println(c == d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）</span></span><br><span class="line">c = <span class="number">200</span>;</span><br><span class="line">d = <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure><p>答案是什么呢？有举手要回答的吗？答对的奖励一朵小红花哦。</p><p>第一段代码，基本类型和包装类型进行 == 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true。</p><p>第二段代码，两个包装类型都被赋值为了 100，这时候会进行自动装箱，那 == 的结果会是什么呢？</p><p>我们之前的结论是：将“==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。那结果是 false？但这次的结果却是 true，是不是感觉很意外？</p><p>第三段代码，两个包装类型重新被赋值为了 200，这时候仍然会进行自动装箱，那 == 的结果会是什么呢？</p><p>吃了第二段代码的亏后，是不是有点怀疑人生了，这次结果是 true 还是 false 呢？扔个硬币吧，哈哈。我先告诉你结果吧，false。</p><p>为什么？为什么？为什么呢？</p><p>事情到了这一步，必须使出杀手锏了——分析源码吧。</p><p>之前我们已经知道了，自动装箱是通过 <code>Integer.valueOf()</code> 完成的，那我们就来看看这个方法的源码吧。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"><span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难不成是 IntegerCache 在作怪？你猜对了！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// high value may be configured by property</span></span><br><span class="line"><span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">high = h;</span><br><span class="line"></span><br><span class="line">cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> j = low;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line"><span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line"><span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致瞟一下这段代码你就全明白了。-128 到 127 之间的数会从 IntegerCache 中取，然后比较，所以第二段代码（100 在这个范围之内）的结果是 true，而第三段代码（200 不在这个范围之内，所以 new 出来了两个 Integer 对象）的结果是 false。</p><p>看完上面的分析之后，我希望大家记住一点：<strong>当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象</strong>。</p><p>自动装拆箱是一个很好的功能，大大节省了我们开发人员的精力，但也会引发一些麻烦，比如下面这段代码，性能就很差。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">Long sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE;i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(t2-t1);</span><br></pre></td></tr></table></figure><p>sum 由于被声明成了包装类型 Long 而不是基本类型 long，所以 <code>sum += i</code> 进行了大量的拆装箱操作（sum 先拆箱和 i 相加，然后再装箱赋值给 sum），导致这段代码运行完花费的时间足足有 2986 毫秒；如果把 sum 换成基本类型 long，时间就仅有 554 毫秒，完全不一个等量级啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/baozhuangleixing.png&quot; alt=&quot;image-20200604141908424&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java 的每个基本类型都对应了一个包装类型，比如说 int 的包装类型为 Integer，double 的包装类型为
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="基本类型和包装类型" scheme="https://shang.at/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>java学习-JVM-heap-non-heap-off-heap</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-JVM-heap-non-heap-off-heap/"/>
    <id>https://shang.at/post/java学习-JVM-heap-non-heap-off-heap/</id>
    <published>2020-06-03T22:50:26.000Z</published>
    <updated>2020-06-03T22:50:26.253Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java网络编程-零拷贝</title>
    <link href="https://shang.at/post/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>https://shang.at/post/java网络编程-零拷贝/</id>
    <published>2020-06-03T16:32:39.000Z</published>
    <updated>2020-06-03T23:37:38.921Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h4><p>刚才讲阻塞 IO 的时候我讲到，系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。以下是具体流程：</p><p><img src="/images/zero-copy.jpg" alt="zero-copy"></p><p>应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 CPU 将数据拷贝到系统内核的缓冲区中，之后再由 DMA 将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。</p><p>应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要 CPU 进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样是不是很浪费 CPU 和性能呢？那有没有什么方式，可以减少进程间的数据拷贝，提高数据传输的效率呢？</p><p>这时我们就需要零拷贝（Zero-copy）技术。</p><p>所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，都可以通过一种方式，让应用进程向用户空间写入或者读取数据，就如同直接向内核空间写入或者读取数据一样，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。</p><p>那怎么做到零拷贝？你想一下是不是用户空间与内核空间都将数据写到一个地方，就不需要拷贝了？此时你有没有想到虚拟内存？</p><p><img src="/images/zero-copy1.jpg" alt="zero-copy1"></p><p>零拷贝有两种解决方式，分别是 mmap+write 方式和 sendfile 方式，mmap+write 方式的核心原理就是通过虚拟内存来解决的。</p><h4 id="java中的零拷贝"><a href="#java中的零拷贝" class="headerlink" title="java中的零拷贝"></a>java中的零拷贝</h4><h4 id="Netty中的零拷贝"><a href="#Netty中的零拷贝" class="headerlink" title="Netty中的零拷贝"></a>Netty中的零拷贝</h4><blockquote><p>具体去读Netty的源码再详细补充这里</p></blockquote><p>了解完零拷贝，我们再看看 Netty 中的零拷贝。</p><p>我刚才讲到，RPC 框架在网络通信框架的选型上，我们最优的选择是基于 Reactor 模式实现的框架，如 Java 语言，首选的便是 Netty 框架。那么 Netty 框架是否也有零拷贝机制呢？Netty 框架中的零拷贝和我之前讲的零拷贝又有什么不同呢？</p><p>刚才我讲的零拷贝是操作系统层面上的零拷贝，主要目标是避免用户空间与内核空间之间的数据拷贝操作，可以提升 CPU 的利用率。</p><p>而 Netty 的零拷贝则不大一样，他完全站在了用户空间上，也就是 JVM 上，它的零拷贝主要是偏向于数据操作的优化上。</p><p>那么 Netty 这么做的意义是什么呢？</p><p>回想下[第 02 讲]，在这一讲中我讲解了 RPC 框架如何去设计协议，其中我讲到：在传输过程中，RPC 并不会把请求参数的所有二进制数据整体一下子发送到对端机器上，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包，所以消息都需要有边界。那么一端的机器收到消息之后，就需要对数据包进行处理，根据边界对数据包进行分割和合并，最终获得一条完整的消息。</p><p>那收到消息后，对数据包的分割和合并，是在用户空间完成，还是在内核空间完成的呢？</p><p>当然是在用户空间，因为对数据包的处理工作都是由应用程序来处理的，那么这里有没有可能存在数据的拷贝操作？可能会存在，当然不是在用户空间与内核空间之间的拷贝，是用户空间内部内存中的拷贝处理操作。Netty 的零拷贝就是为了解决这个问题，在用户空间对数据操作进行优化。</p><p>那么 Netty 是怎么对数据操作进行优化的呢？</p><ul><li>Netty 提供了 CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝。</li><li>ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。</li><li>通过 wrap 操作，我们可以将 byte[] 数组、ByteBuf、ByteBuffer 等包装成一个 Netty ByteBuf 对象, 进而避免拷贝操作。</li></ul><p>Netty 框架中很多内部的 ChannelHandler 实现类，都是通过 CompositeByteBuf、slice、wrap 操作来处理 TCP 传输中的拆包与粘包问题的。</p><p>那么 Netty 有没有解决用户空间与内核空间之间的数据拷贝问题的方法呢？</p><p>Netty 的 ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socket 的读写操作，最终的效果与我刚才讲解的虚拟内存所实现的效果是一样的。<strong>(mmap方式)</strong></p><p>Netty 还提供 FileRegion 中包装 NIO 的 FileChannel.transferTo() 方法实现了零拷贝，这与 Linux 中的 sendfile 方式在原理上也是一样的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>零拷贝带来的好处就是避免没必要的 CPU 拷贝，让 CPU 解脱出来去做其他的事，同时也减少了 CPU 在用户空间与内核空间之间的上下文切换，从而提升了网络通信效率与应用程序的整体性能。</p><p>而 Netty 的零拷贝与操作系统的零拷贝是有些区别的，Netty 的零拷贝偏向于用户空间中对数据操作的优化，这对处理 TCP 传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。</p><p>在 RPC 框架的开发与使用过程中，我们要深入了解网络通信相关的原理知识，尽量做到零拷贝，如使用 Netty 框架；我们要合理使用 ByteBuf 子类，做到完全零拷贝，提升 RPC 框架的整体性能。</p><p>其他关于零拷贝技术的文章：</p><p><a href="https://zhuanlan.zhihu.com/p/78869158" target="_blank" rel="noopener">Java中的零拷贝</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是零拷贝&quot;&gt;&lt;a href=&quot;#什么是零拷贝&quot; class=&quot;headerlink&quot; title=&quot;什么是零拷贝&quot;&gt;&lt;/a&gt;什么是零拷贝&lt;/h4&gt;&lt;p&gt;刚才讲阻塞 IO 的时候我讲到，系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="网络编程-零拷贝" scheme="https://shang.at/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>java学习-JVM参数</title>
    <link href="https://shang.at/post/java%E5%AD%A6%E4%B9%A0-JVM%E5%8F%82%E6%95%B0/"/>
    <id>https://shang.at/post/java学习-JVM参数/</id>
    <published>2020-06-03T10:36:02.000Z</published>
    <updated>2020-06-04T03:30:03.517Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查看JVM参数"><a href="#查看JVM参数" class="headerlink" title="查看JVM参数"></a>查看JVM参数</h4><p>启动应用的时候分别加以下的参数可以打印相关的参数：</p><ol><li><p>java -XX:+PrintFlagsInitial  打印所有的JVM初始参数，但是会立刻终止应用</p></li><li><p>java -XX:+PrintFlagsFinal  打印所有的设置后的JVM参数，不会终止应用</p></li><li><p>jinfo [options]  pid</p></li></ol><p>​     jinfo -flags pid 查看指定pid的jvm的所有设置参数</p><ol start="4"><li>-XX:+PrintVMOptions 程序运行时，打印虚拟机接受到的命令行显式参数。不会终止应用</li><li>-XX:+PrintCommandLineFlags 打印传递给虚拟机的显式和隐式参数。不会终止应用</li></ol><h4 id="常见的JVM参数"><a href="#常见的JVM参数" class="headerlink" title="常见的JVM参数"></a>常见的JVM参数</h4><ul><li>InitialHeapSize(单位是字节)：初始堆大小，默认是物理内存的1/64，最小为2m(设置了1m，发现PrintFlagsFinal打印出来的是2m)，可以使用-Xms指定，如-Xms64m，只能指定m、g这样的单位</li><li>MaxHeapSize：最大堆大小，默认是物理内存的1/4，最小为2m，可以使用-Xmx指定，如-Xmx64m</li><li>MaxNewSize：</li><li>NewSize：</li><li>OldSize：</li><li>MetaspaceSize：</li><li>MaxMetaspaceSize：</li><li><p>ThreadStackSize(单位是kb)：虚拟机栈大小，默认是1024k，可以使用-Xss指定，如-Xss256k</p></li><li><p>MaxTenuringThreshold：对象晋升到老年代的年龄阈值，默认是15，可以使用-XX:MaxTenuringThreshold指定，如-XX:MaxTenuringThreshold=20</p></li></ul><h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h4><ol><li>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查看JVM参数&quot;&gt;&lt;a href=&quot;#查看JVM参数&quot; class=&quot;headerlink&quot; title=&quot;查看JVM参数&quot;&gt;&lt;/a&gt;查看JVM参数&lt;/h4&gt;&lt;p&gt;启动应用的时候分别加以下的参数可以打印相关的参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;java -XX
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM参数" scheme="https://shang.at/tags/JVM%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-常见异常</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/"/>
    <id>https://shang.at/post/Java学习-常见异常/</id>
    <published>2020-06-03T09:31:00.000Z</published>
    <updated>2020-06-12T02:06:08.511Z</updated>
    
    <content type="html"><![CDATA[<h5 id="StackOverflowError和OutOfMemoryError的区别-JDK1-8"><a href="#StackOverflowError和OutOfMemoryError的区别-JDK1-8" class="headerlink" title="StackOverflowError和OutOfMemoryError的区别(JDK1.8)"></a>StackOverflowError和OutOfMemoryError的区别(JDK1.8)</h5><p>StackOverflowError：Thrown when a stack overflow occurs because an application recurses too deeply.</p><p>OutOfMemoryError：Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector.</p><p>从对这两个Error的注释来看，</p><p>由于应用程序递归过深而在堆栈溢出时会抛出StackOverflowError；同一个函数递归调用时，内存不足</p><p>当Java虚拟机由于内存不足而无法分配对象，并且垃圾回收器无法再提供更多内存时，抛出OutOfMemoryError。创建新的对象(包括虚拟机栈：函数调用(也包括递归调用)时创建虚拟机栈)时，内存不足</p><p>在java应用启动的时候，可以通过-Xss来设置虚拟机栈大小，虚拟机栈默认大小为1024k</p><p>在java里，函数的递归调用受到以下几方面的影响：</p><ol><li>虚拟机栈大小：设置的虚拟机栈</li><li>局部变量表大小</li></ol><p><a href="https://blog.csdn.net/chengyun19830206/article/details/78452321" target="_blank" rel="noopener">https://blog.csdn.net/chengyun19830206/article/details/78452321</a></p><p><a href="https://dzone.com/articles/outofmemoryerror-unable-create" target="_blank" rel="noopener">https://dzone.com/articles/outofmemoryerror-unable-create</a></p><p><a href="https://blog.csdn.net/kylinsoong/article/details/16879653" target="_blank" rel="noopener">https://blog.csdn.net/kylinsoong/article/details/16879653</a></p><p><a href="https://www.jianshu.com/p/c09727dc8f92" target="_blank" rel="noopener">https://www.jianshu.com/p/c09727dc8f92</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;StackOverflowError和OutOfMemoryError的区别-JDK1-8&quot;&gt;&lt;a href=&quot;#StackOverflowError和OutOfMemoryError的区别-JDK1-8&quot; class=&quot;headerlink&quot; title=&quot;St
      
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="常见异常" scheme="https://shang.at/tags/%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程-12-并发框架(Disruptor)</title>
    <link href="https://shang.at/post/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-12-%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6-Disruptor/"/>
    <id>https://shang.at/post/JAVA并发编程-12-并发框架-Disruptor/</id>
    <published>2020-06-03T02:54:59.000Z</published>
    <updated>2020-06-03T03:00:26.307Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA并发编程" scheme="https://shang.at/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Disruptor" scheme="https://shang.at/tags/Disruptor/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程-11-响应式编程(RxJava)</title>
    <link href="https://shang.at/post/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-11-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-RxJava/"/>
    <id>https://shang.at/post/JAVA并发编程-11-响应式编程-RxJava/</id>
    <published>2020-06-03T02:53:44.000Z</published>
    <updated>2020-06-03T08:24:11.250Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5ed62cabf265da7709526718" target="_blank" rel="noopener">https://juejin.im/post/5ed62cabf265da7709526718</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5ed62cabf265da7709526718&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5ed62cabf265da7709526718&lt;
      
    
    </summary>
    
      <category term="JAVA并发编程" scheme="https://shang.at/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="RxJava" scheme="https://shang.at/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程-10-协程</title>
    <link href="https://shang.at/post/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-10-%E5%8D%8F%E7%A8%8B/"/>
    <id>https://shang.at/post/JAVA并发编程-10-协程/</id>
    <published>2020-06-03T02:53:19.000Z</published>
    <updated>2020-06-03T08:24:17.642Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5ed62cabf265da7709526718" target="_blank" rel="noopener">https://juejin.im/post/5ed62cabf265da7709526718</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5ed62cabf265da7709526718&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5ed62cabf265da7709526718&lt;
      
    
    </summary>
    
      <category term="JAVA并发编程" scheme="https://shang.at/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="协程" scheme="https://shang.at/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程-9-线程池</title>
    <link href="https://shang.at/post/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-9-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://shang.at/post/JAVA并发编程-9-线程池/</id>
    <published>2020-06-03T02:52:35.000Z</published>
    <updated>2020-06-03T02:59:46.242Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA并发编程" scheme="https://shang.at/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池" scheme="https://shang.at/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程-8-阻塞队列</title>
    <link href="https://shang.at/post/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-8-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://shang.at/post/JAVA并发编程-8-阻塞队列/</id>
    <published>2020-06-03T02:52:16.000Z</published>
    <updated>2020-06-03T02:59:37.175Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA并发编程" scheme="https://shang.at/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="阻塞队列" scheme="https://shang.at/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程-7-Atomic</title>
    <link href="https://shang.at/post/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-7-Atomic/"/>
    <id>https://shang.at/post/JAVA并发编程-7-Atomic/</id>
    <published>2020-06-03T02:51:56.000Z</published>
    <updated>2020-06-03T02:59:29.958Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA并发编程" scheme="https://shang.at/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Atomic" scheme="https://shang.at/tags/Atomic/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程-6-并发集合</title>
    <link href="https://shang.at/post/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-6-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/"/>
    <id>https://shang.at/post/JAVA并发编程-6-并发集合/</id>
    <published>2020-06-03T02:51:41.000Z</published>
    <updated>2020-06-03T02:59:22.524Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA并发编程" scheme="https://shang.at/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发集合" scheme="https://shang.at/tags/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
