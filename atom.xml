<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>努力，奋斗</title>
  
  <subtitle>记录学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shang.at/"/>
  <updated>2020-05-17T15:16:15.157Z</updated>
  <id>https://shang.at/</id>
  
  <author>
    <name>王尚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java学习-线程安全的集合类</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>https://shang.at/post/Java学习-线程安全的集合类/</id>
    <published>2020-05-17T15:16:15.000Z</published>
    <updated>2020-05-17T15:16:15.157Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java学习-Iterator</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-Iterator/"/>
    <id>https://shang.at/post/Java学习-Iterator/</id>
    <published>2020-05-17T07:27:13.000Z</published>
    <updated>2020-05-17T07:55:27.700Z</updated>
    
    <content type="html"><![CDATA[<p>在看Iterator之前，先看一个早期版本的迭代器java.util.Enumeration</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* NOTE: The functionality of this interface is duplicated by the Iterator</span><br><span class="line">* interface.  In addition, Iterator adds an optional remove operation, and</span><br><span class="line">* has shorter method names.  New implementations should consider using</span><br><span class="line">* Iterator in preference to Enumeration.</span><br></pre></td></tr></table></figure><p>现在来看Iterator：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的点：</p><ul><li>Iterator在好的设计下可以在遍历的过程中对列表进行增加和删除和修改元素</li><li>Iterator在遍历的过程只能进行一遍，即遍历完的对象不能再次遍历，<ul><li>因为大多数Iterator在实现的过程中都是维护了了cursor指针，这个指针一般只会增加，不会减少</li><li>同时大都没有充值cursor指针的接口</li><li>关键是看Iterator的设计如何</li></ul></li></ul><p>例如下面的ListIterator</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListIterator在原来的Iterator的基础上扩展了，使之可以往前遍历，同时可以修改和增加元素</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在看Iterator之前，先看一个早期版本的迭代器java.util.Enumeration&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;sp
      
    
    </summary>
    
      <category term="JAVA源码" scheme="https://shang.at/categories/JAVA%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JAVA-Iterator" scheme="https://shang.at/tags/JAVA-Iterator/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-函数式编程</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://shang.at/post/Java学习-函数式编程/</id>
    <published>2020-05-17T00:38:33.000Z</published>
    <updated>2020-05-17T03:28:07.220Z</updated>
    
    <content type="html"><![CDATA[<p>Java8之后加入了一种全新的方式来实现方法(功能)作为参数传递的机制：lambda表达式</p><blockquote><p>像python语言，天生就支持将function作为参数传递给函数.</p></blockquote><p>可以想象，既然是一种实现方法作为参数传递的机制，java是一种面向对象的编程语言，也就是说在java中除了原始数据类型之外，都是对象：</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="meta">@FunctionalInterface</span></span><br><span class="line">&gt; <span class="class"><span class="keyword">interface</span> <span class="title">CharBinaryOperator</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function">String <span class="title">applyAsChar</span><span class="params">(<span class="keyword">char</span> left, <span class="keyword">char</span> right)</span></span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; CharBinaryOperator charBinaryOperator = (<span class="keyword">char</span> a, <span class="keyword">char</span> b) -&gt; &#123;</span><br><span class="line">&gt;     System.out.println(a);</span><br><span class="line">&gt;     System.out.println(b);</span><br><span class="line">&gt;     <span class="keyword">return</span> String.valueOf(a + b);</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>charBinaryOperator instanceof CharBinaryOperator<ul><li>charBinaryOperator是CharBinaryOperator的一个实例</li></ul></li><li>CharBinaryOperator.class instanceof Class<ul><li>CharBinaryOperator.class是Class的一个实例</li></ul></li><li>Class.class instanceof Class<ul><li>Class.class同时也是Class的一个实例</li></ul></li></ul></blockquote><p>在java中，传递的参数要么是原始数据类型，要么是对象(类型也是对象，所以能够传递)，不能是其他的类型。在JDK8之前，要想将一个功能传递到函数内部(<strong>这一般会被称为函数回调</strong>，是大多数异步编程的常用套路：到达某个时间节点或满足某中情况触发一个操作)，那么就只能<strong>显示的</strong>先定义一个接口，然后创建一个实现了这个接口的类，然后再实例化这个类得到一个对象，最后将这个对象作为参数传入函数，函数内部调用对象实现的方法，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CharBinaryOperator charBinaryOperator1 = <span class="keyword">new</span> CharBinaryOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">applyAsChar</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">charBinaryOperator.applyAsChar(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><p>在JDK8及之后，我们不需要再显示的做这一系列的事情(当然你这么做也不会有问题)。</p><p>在JDK8及之后，所有满足条件的interface都会被解释函数式接口，即都可以通过lambda表达式的形式代替上述流程</p><blockquote><p>什么样的interface才算满足条件呢？</p><p>只声明了一个未实现的函数的interface就可以。在JDK8及以后，interface中定义的函数也可以有默认的实现</p><p>在声明接口的时候，可以使用java.lang.FunctionalInterface注解，表示该interface是一个函数式接口(当然可以不加，compiler会自动判断)</p><p>如果在有多个未实现的函数的interface上加这个注解的时候，编译阶段就会报错：Multiple non-overriding abstract methods found in interface OOXX</p></blockquote><blockquote><p>lambda表达式只不过是为了实现这个机制的一种解决方案，可以提高开发效率，同时隐藏了interface的定义细节，<del>compilier完全是按照参数列表来推断当前的lambda表达式是和哪一个interface绑定的</del>(compilier直接找到接口的定义，不是推断的)。如果没有预定义的，那么就会在编译期间报错，所以在java中lambda表达式的使用是有一定的限制的。</p><p>同时，在使用JDK预定义的操作时，在内部是调用了接口内定义的那个具体的函数的，所以对于开发者来说也是透明的，如列表的forEach()函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;     <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">&gt;         Objects.requireNonNull(action);</span><br><span class="line">&gt;         <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">&gt;             action.accept(t);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; <span class="comment">// 我们在使用的时候是这样的</span></span><br><span class="line">&gt;         List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;         integers.add(<span class="number">1</span>);</span><br><span class="line">&gt;         integers.forEach(i -&gt; &#123;</span><br><span class="line">&gt;             System.out.println(i);</span><br><span class="line">&gt;         &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>本质上，还是要先有interface的定义(在JDK中已经预定义了大部分的interface，所以我们才不用自己手动定义，我上面的例子中就是一个没有被预定义的例子)，运行结果也是创建了一个实现了指定接口的对象，然后将对象作为参数传递给函数</p><p>如果我们完全脱离了JDK预定义的操作，那么我们就需要自己定义innterface，并且在我们使用该接口的地方显示的声明方法的使用，但是在外层传递方法参数的调用，我们仍可以使用简洁明了的lambda表达式，无论怎么说，lambda表达式的这种机制极大的方便了开发人员</p></blockquote><p>Lambda 表达式和匿名类之间的区别</p><blockquote><p><code>this</code> 关键字。对于匿名类 <code>this</code> 关键字解析为匿名类，而对于 Lambda 表达式，<code>this</code> 关键字解析为包含写入 Lambda 的类。</p></blockquote><h6 id="JDK中预定义的interface"><a href="#JDK中预定义的interface" class="headerlink" title="JDK中预定义的interface"></a>JDK中预定义的interface</h6><p>在<code>java.util.function</code>可以看到全部的预定义的interface，以下四种是最有代表性的</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gev9okl2qkj30fg04sjrk.jpg" alt></p><ul><li>Function<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gev9t81dwtj30ch03kdg0.jpg" alt="image-20200517110913472"><ul><li>R apply(T)</li><li>Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)</li><li>Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)</li><li>Function&lt;T, T&gt; identity()</li></ul></li><li>Consumer<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gev9v9l0w5j30ae02jglk.jpg" alt="image-20200517111112190"><ul><li>void accept(T)</li><li>Consumer&lt; T&gt; addThen(Consumer&lt;? super T&gt;)</li></ul></li><li>Predicate<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gev9vnldldj30a804b74d.jpg" alt="image-20200517111135143"><ul><li>boolean test()</li><li>Predicate&lt; T&gt; add(Predicate&lt;? super T&gt;)</li><li>Predicate&lt; T&gt; negate()</li><li>Predicate&lt; T&gt; or(Predicate&lt;? super T&gt;)</li><li>Predicate&lt; T&gt; isEqual(Object) </li></ul></li><li>Supplier<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gev9ukowqdj303k01uq2r.jpg" alt="image-20200517111031489"><ul><li>T get()</li></ul></li></ul><h1 id="Lambda-表达式的例子"><a href="#Lambda-表达式的例子" class="headerlink" title="Lambda 表达式的例子"></a><a href="https://segmentfault.com/a/1190000009186509" target="_blank" rel="noopener">Lambda 表达式的例子</a></h1><h2 id="1-线程初始化"><a href="#1-线程初始化" class="headerlink" title="1 线程初始化"></a>1 线程初始化</h2><p>线程可以初始化如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Old way</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// New way</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">    () -&gt; System.out.println(<span class="string">"Hello world"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><h2 id="2-事件处理"><a href="#2-事件处理" class="headerlink" title="2 事件处理"></a>2 事件处理</h2><p>事件处理可以用 Java 8 使用 Lambda 表达式来完成。以下代码显示了将 <code>ActionListener</code> 添加到 UI 组件的新旧方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Old way</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// New way</span></span><br><span class="line">button.addActionListener( (e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-遍例输出（方法引用）"><a href="#3-遍例输出（方法引用）" class="headerlink" title="3 遍例输出（方法引用）"></a>3 遍例输出（方法引用）</h2><p>输出给定数组的所有元素的简单代码。请注意，还有一种使用 Lambda 表达式的方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old way</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer n : list) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 -&gt; 的 Lambda 表达式</span></span><br><span class="line">list.forEach(n -&gt; System.out.println(n));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 :: 的 Lambda 表达式</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="6-4-逻辑操作"><a href="#6-4-逻辑操作" class="headerlink" title="6.4 逻辑操作"></a>6.4 逻辑操作</h2><p>输出通过逻辑判断的数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wuxianjiezh.demo.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出所有数字："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"不输出："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出偶数："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出奇数："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; n % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"输出大于 5 的数字："</span>);</span><br><span class="line">        evaluate(list, (n) -&gt; n &gt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evaluate</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer n : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(n)) &#123;</span><br><span class="line">                System.out.print(n + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出所有数字：1 2 3 4 5 6 7 </span><br><span class="line">不输出：</span><br><span class="line">输出偶数：2 4 6 </span><br><span class="line">输出奇数：1 3 5 7 </span><br><span class="line">输出大于 5 的数字：6 7</span><br></pre></td></tr></table></figure><h2 id="6-4-Stream-API-示例"><a href="#6-4-Stream-API-示例" class="headerlink" title="6.4 Stream API 示例"></a>6.4 Stream API 示例</h2><p><code>java.util.stream.Stream</code>接口 和 Lambda 表达式一样，都是 Java 8 新引入的。所有 <code>Stream</code> 的操作必须以 Lambda 表达式为参数。<code>Stream</code> 接口中带有大量有用的方法，比如 <code>map()</code> 的作用就是将 input Stream 的每个元素，映射成output Stream 的另外一个元素。</p><p>下面的例子，我们将 Lambda 表达式 <code>x -&gt; x*x</code> 传递给 <code>map()</code> 方法，将其应用于流的所有元素。之后，我们使用 <code>forEach</code> 打印列表的所有元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old way</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer n : list) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = n * n;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new way</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">list.stream().map((x) -&gt; x*x).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>下面的示例中，我们给定一个列表，然后求列表中每个元素的平方和。这个例子中，我们使用了 <code>reduce()</code> 方法，这个方法的主要作用是把 Stream 元素组合起来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old way</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer n : list) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = n * n;</span><br><span class="line">    sum = sum + x;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new way</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java8之后加入了一种全新的方式来实现方法(功能)作为参数传递的机制：lambda表达式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;像python语言，天生就支持将function作为参数传递给函数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以想象，既然是一种实现方法作
      
    
    </summary>
    
      <category term="JAVA源码" scheme="https://shang.at/categories/JAVA%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="函数式编程" scheme="https://shang.at/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-集合类</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>https://shang.at/post/Java学习-集合类/</id>
    <published>2020-05-16T23:27:00.000Z</published>
    <updated>2020-05-17T09:06:31.786Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gev3hd1fgnj30ye0u0jws.jpg" alt></p><blockquote><p>注：这里只列举了单一线线程使用的集合对象(Vector除外)</p></blockquote><p>JVAV中列表类集合，按照数据的存储方式可以分为两大类：基于数组和基于链表。两种方式各有好处，需要根据实际业务场景做出选择。</p><ul><li><p>数组</p><ul><li>优点<ul><li>支持随机访问，给定下标的访问是O(1)的时间复杂度</li></ul></li><li>缺点<ul><li>内存必须是连续的，否则会申请空间失败</li><li>查找、插入、扩容、删除都是O(n)的时间复杂度</li><li>有容量的限制，增加节点时，可能会因为数组大小不够导致扩容，扩容的时间复杂度是O(n)的</li></ul></li><li>使用注意<ul><li>最好能够预估数据的最大容量，可以预先设计capacity，尽量避免扩容操作</li><li>但是在特别的使用场景下，基于数组的实现效率会更好，比如下面要说的ArrayDeque</li></ul></li><li>具体实现<ul><li>ArrayList</li><li>Vector</li><li>Stack</li><li>ArrayDeque</li></ul></li></ul></li><li><p>链表</p><ul><li><p>优点</p><ul><li>内存不用是连续的</li><li>插入、删除都是O(1)的时间复杂度</li><li>没有容量的限制，按理说限制就是JVAV堆的大小限制</li></ul></li><li><p>缺点</p><ul><li>查找是O(n)的时间复杂度</li></ul></li><li><p>使用</p><ul><li>单独使用链表的时候，还挺少的，毕竟一个没有附加特性的链表结构，仅仅只能够做到新增和删除的时间复杂度为O(1)，但是查询却需要O(n)，并且还需要额外的空间存储链表结构。数组可以通过预估容量的方式尽量减少扩容的操作，对比发现，使用基于数组的集合性价比更高</li></ul></li><li><p>具体实现</p><ul><li><p>LinkList</p></li><li><p>LinkList在定位低index个元素的时候，有个优化的点可以学习</p></li><li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul></li></ul><blockquote><p>总结：可以发现，基于数组和基于链表的集合实现方式，想要从他们中查询到具体的元素，时间复杂度都是O(n)的，这是因为，这里仅仅考虑了数据的存储方式，并没有额外的信息给出来，所以是没有办法加速查询的。要想实现加速查询，那么就必须在这基础上增加新的特性：</p></blockquote><ul><li>数组<ul><li>有序性：可以借助有序性使用二分查找，把查找时间复杂度降到O(log n)</li></ul></li><li>链表<ul><li>建立树结构：<ul><li>二叉搜索树：前序遍历就是正向排序，可以把查询的时间复杂度降到O(log n)，但是要维护二叉搜索，尽量保证他是平衡的(但是这个的时间复杂度是O(1)的)</li><li>堆：查找最大(最小)值是O(1)的时间复杂度</li></ul></li><li>升维：比如跳表，就是在有序的链表上建立多级索引来实现加速查询的，可以把查找时间复杂度降到O(log n)，但是在新增和删除节点时需要维护多级索引(但是这个的时间复杂度是O(1)的)</li></ul></li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevgxzxj4uj30iw0ij0uy.jpg" alt="image-20200517151558262"></p><p>接口信息如下：</p><table><thead><tr><th></th><th>Method</th><th>Return</th><th>Comment</th></tr></thead><tbody><tr><td>Insert</td><td>add(E)</td><td>boolean</td><td>向队列加入元素，如果空间不足，会触发扩容</td></tr><tr><td>Insert</td><td>add(int, E)</td><td>void</td><td>向指定位置插入元素，可能会抛IndexOutOfBoundsException</td></tr><tr><td>Remove</td><td>remove(Object)</td><td>boolean</td><td>移除指定的元素，没有的话返回false，有的话返回true</td></tr><tr><td>Remove</td><td>remove(int)</td><td>E</td><td>移除指定index的元素，可能会抛IndexOutOfBoundsException</td></tr><tr><td>Examine</td><td>get(int)</td><td>E</td><td>返回指定index的元素，可能会抛IndexOutOfBoundsException</td></tr><tr><td>Update</td><td>set(int, E)</td><td>E</td><td>更新指定index的元素，可能会抛IndexOutOfBoundsException</td></tr></tbody></table><p>在List的源码中发现多处这样的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只返回第一个遇到的o，当o为null的时候，o.equals会报错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详看扩容操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">   elementData[size++] = e;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEFAULT_CAPACITY=10</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">// newCapacity = int(1.5*oldCapacity)</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整形溢出：Integer.MAX_VALUE + 8&lt;0</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevjdx0lvfj305o056aa0.jpg" alt="image-20200517164030856"></p><p>设计了一套支持队列操作的接口，如下：</p><table><thead><tr><th></th><th>Method</th><th>Return</th><th>Comment</th></tr></thead><tbody><tr><td>Insert</td><td>add(E)</td><td>boolean</td><td>向队列添加一个元素，如果没有空间会抛出IllegalStateException</td></tr><tr><td>Insert</td><td>offer(E)</td><td>boolean</td><td>向队列添加一个元素，如果没有空间会返回false</td></tr><tr><td>Remove</td><td>remove()</td><td>E</td><td>移除并返回头结点，如果队列为空的话，会抛NoSuchElementException</td></tr><tr><td>Remove</td><td>poll()</td><td>E</td><td>移除并返回头结点，如果队列为空的话，会返回null</td></tr><tr><td>Examine</td><td>element()</td><td>E</td><td>返回头结点，如果队列为空的话，会抛NoSuchElementException</td></tr><tr><td>Examine</td><td>peek()</td><td>E</td><td>返回头结点，如果队列为空的话，会返回null</td></tr></tbody></table><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevjrosqnyj30g80i8dhk.jpg" alt="image-20200517165344428"></p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevk1e2lppj306v04s0sp.jpg" alt="image-20200517170304083"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>通常使用ArrayDeque来作为先进先出的Queue，后进先出的Stack</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gev3hd
      
    
    </summary>
    
      <category term="JAVA源码" scheme="https://shang.at/categories/JAVA%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JAVA集合类-列表" scheme="https://shang.at/tags/JAVA%E9%9B%86%E5%90%88%E7%B1%BB-%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>分布式服务框架-IPC&amp;RPC</title>
    <link href="https://shang.at/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6-IPC-RPC/"/>
    <id>https://shang.at/post/分布式服务框架-IPC-RPC/</id>
    <published>2020-05-14T03:38:18.000Z</published>
    <updated>2020-05-15T01:43:48.472Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="分布式" scheme="https://shang.at/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="IPC&amp;RPC" scheme="https://shang.at/tags/IPC-RPC/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-代理</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%90%86/"/>
    <id>https://shang.at/post/Java学习-代理/</id>
    <published>2020-05-14T03:34:00.000Z</published>
    <updated>2020-05-15T01:44:12.636Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JAVA" scheme="https://shang.at/categories/JAVA/"/>
    
    
      <category term="代理" scheme="https://shang.at/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习-事务和隔离级别</title>
    <link href="https://shang.at/post/Mysql%E5%AD%A6%E4%B9%A0-%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://shang.at/post/Mysql学习-事务和隔离级别/</id>
    <published>2020-05-12T17:31:26.000Z</published>
    <updated>2020-05-13T03:30:51.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL事务和隔离级别"><a href="#MYSQL事务和隔离级别" class="headerlink" title="MYSQL事务和隔离级别"></a>MYSQL事务和隔离级别</h1><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><p>事务是由一组SQL语句组成的逻辑处理单元，是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。事务具有以下4个属性，通常简称为事务的ACID属性:</p><ul><li>原子性（Atomicity）：<strong>事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</strong>。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li><li>一致性（Consistent）：<strong>在事务开始和完成时，数据都必须保持一致状态</strong>。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。 <strong>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</strong>。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 　可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li></ul><blockquote><p>MySQL 默认采用<strong>自动提交模式</strong>。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqnms749pj30zo0qggre.jpg" alt="image-20200513111933684"></p></blockquote><blockquote><p>这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库奔溃的情况。</li></ul></blockquote><h2 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h2><h3 id="1、更新丢失-Lost-Update"><a href="#1、更新丢失-Lost-Update" class="headerlink" title="1、更新丢失(Lost Update)"></a>1、更新丢失(Lost Update)</h3><p><strong>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改</strong>。</p><p>例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。</p><p><strong>如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题</strong>。 </p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqnnepde0j31540u0gqk.jpg" alt="image-20200513112012076"></p><h3 id="2、脏读"><a href="#2、脏读" class="headerlink" title="2、脏读"></a>2、脏读</h3><p>一句话：事务B读取到了事务A已修改但尚未提交的的数据，还在这个数据基础上做了操作。此时，如果A事务回滚<code>Rollback</code>，B读取的数据无效，不符合一致性要求。</p><p>解决办法: 把数据库的事务隔离级别调整到 <code>READ_COMMITTED</code></p><p><strong>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqno2ih8oj314s0u044g.jpg" alt="image-20200513112050855"></p><h3 id="3、不可重复读-Non-Repeatable-Reads"><a href="#3、不可重复读-Non-Repeatable-Reads" class="headerlink" title="3、不可重复读(Non-Repeatable Reads)"></a>3、不可重复读(Non-Repeatable Reads)</h3><p>  在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p><p> <strong>一句话：一个事务范围内两个相同的查询却返回了不同数据</strong>。</p><p>同时操作，事务1分别读取事务2操作时和提交后的数据，读取的记录内容不一致。<strong>不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果</strong>。</p><p>解决办法: 如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。把数据库的事务隔离级别调整到<code>REPEATABLE_READ</code></p><p><strong>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqnxkk82wj313l0u0grm.jpg" alt="image-20200513112958117"></p><h3 id="4、幻读"><a href="#4、幻读" class="headerlink" title="4、幻读"></a>4、幻读</h3><p>一个事务T1按相同的查询条件重新读取以前检索过的数据，却发现其他事务T2插入了满足其查询条件的新数据，这种现象就称为“幻读”。（和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）</p><p>一句话：事务A 读取到了事务B提交的新增数据，不符合隔离性。 </p><p>解决办法: 如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题。把数据库的事务隔离级别调整到 <code>SERIALIZABLE_READ</code>。</p><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqnxye5ghj31360u0gq5.jpg" alt="image-20200513113020849"></p><h2 id="三、事务隔离级别"><a href="#三、事务隔离级别" class="headerlink" title="三、事务隔离级别"></a>三、事务隔离级别</h2><p>“脏读”、”不可重复读”和”幻读”，其实都是数据库读一致性问题，<strong>必须由数据库提供一定的事务隔离机制来解决</strong>。</p><p> 数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。 </p><p>MYSQL常看当前数据库的事务隔离级别：<code>show variables like &#39;tx_isolation&#39;;</code></p><h3 id="1、读未提交-Read-Uncommitted"><a href="#1、读未提交-Read-Uncommitted" class="headerlink" title="1、读未提交 (Read Uncommitted)"></a>1、读未提交 (Read Uncommitted)</h3><p>最低的隔离等级，<strong>允许其他事务看到没有提交的数据</strong>，会导致脏读。</p><h3 id="2、读已提交-Read-Committed"><a href="#2、读已提交-Read-Committed" class="headerlink" title="2、读已提交 (Read Committed)"></a>2、读已提交 (Read Committed)</h3><p><strong>被读取的数据可以被其他事务修改，这样可能导致不可重复读</strong>。<strong>也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放</strong>，释放读锁之后，就可能被其他事务修改数据。该等级也是 SQL Server 默认的隔离等级。</p><h3 id="3、可重复读-Repeatable-Read"><a href="#3、可重复读-Repeatable-Read" class="headerlink" title="3、可重复读(Repeatable Read)"></a>3、可重复读(Repeatable Read)</h3><p><strong>所有被 Select 获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况</strong>。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，即前一个事务有读锁但是没有范围锁，为什么叫做可重复读等级呢？那是因为该等级解决了下面的不可重复读问题。(引申：现在主流数据库都使用 MVCC 并发控制，使用之后<code>RR</code>（可重复读）隔离级别下是不会出现幻读的现象。)</p><p>MYSQL默认是<code>REPEATABLE-READ</code>。 </p><h3 id="4、串行化-Serializable"><a href="#4、串行化-Serializable" class="headerlink" title="4、串行化(Serializable)"></a>4、串行化(Serializable)</h3><p>所有事务一个接着一个的执行，这样可以避免幻读 (phantom read)，对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务。</p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul><li>读未提交: <strong>一个事务还没提交时，它做的变更就能被别的事务看到</strong>。</li><li>读提交: 一个事务提交<strong>之后</strong>，它做的变更<strong>才</strong>会被其他事务看到。</li><li>可重复读 : <strong>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的</strong>。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>四个级别逐渐增强，每个级别解决一个问题，事务级别越高，性能越差，大多数环境(<code>Read committed</code> 就可以用了)</p><table><thead><tr><th>隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>最低级别</td><td>√</td><td>√</td><td>√</td></tr><tr><td>提交读</td><td>语句级</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>事务级</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>最高级别,事务级</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><a href="https://github.com/ZXZxin/ZXBlog" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MYSQL事务和隔离级别&quot;&gt;&lt;a href=&quot;#MYSQL事务和隔离级别&quot; class=&quot;headerlink&quot; title=&quot;MYSQL事务和隔离级别&quot;&gt;&lt;/a&gt;MYSQL事务和隔离级别&lt;/h1&gt;&lt;h2 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; cla
      
    
    </summary>
    
      <category term="Mysql" scheme="https://shang.at/categories/Mysql/"/>
    
    
      <category term="事务和隔离级别" scheme="https://shang.at/tags/%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习-第三范式</title>
    <link href="https://shang.at/post/Mysql%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
    <id>https://shang.at/post/Mysql学习-第三范式/</id>
    <published>2020-05-12T17:19:15.000Z</published>
    <updated>2020-05-13T02:56:08.500Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h4><blockquote><p>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</p><p>符合1NF的关系中的每个属性都不可再分</p></blockquote><p>有两点要求：</p><ul><li>schema定义：每个属性不可再分，即字段的含义要明确，同一个字段不应该有多于1个的含义<ul><li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqm6y05xoj314m08c77c.jpg" alt="image-20200513102942067"></li><li>图中的这种schema在RDBMS中是不可能存在的，也就是无法创建的。可以改成如下的schema:</li><li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqm8stpcij313w05c412.jpg" alt="image-20200513103132122"></li></ul></li><li>存储的数据：同一列中不能有多个值<ul><li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqm622kgkj318s0bcgs2.jpg" alt="image-20200513102837775"></li><li>图中的一个字段里面存了多个值，这种情况在RDBMS中是可以存在的，但是该字段是可再分的，应该。可以将数据分成多条存储，如下图</li><li><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqmclbtx1j318k0batey.jpg" alt="image-20200513103510685"></li></ul></li></ul><h4 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h4><blockquote><p>满足第一范式</p><p>没有部分依赖</p></blockquote><p>在同一个表中，不能存在某些字段依赖一些键，而另一些字段依赖另外一些键</p><p>员工表的一个候选键是{id，mobile，deptNo}，而deptName依赖于deptNo，同样 name 依赖于 id，因此不是 2NF的。为了满足第二范式的条件，需要将这个表拆分成employee、dept、employee_dept、employee_mobile四个表</p><p>不满足2NF的表，可能存在的问题：修改异常、新增异常、删除异常</p><h4 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h4><blockquote><p>满足第二范式</p><p>没有传递依赖</p></blockquote><p>在同一个表中，不要存在字段A依赖字段B，同时字段B依赖字段C，推导出来字段A间接依赖字段C的关系。</p><p>员工表的province、city、district依赖于zip，而zip依赖于id，换句话说，province、city、district传递依赖于id，违反了 3NF 规则。为了满足第三范式的条件，可以将这个表拆分成employee和zip两个表</p><p><em>但是这种关系也不是一定不能存在，视具体的业务而定吧</em></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设有一个名为<code>employee</code>的员工表，它有九个属性：<code>id</code>(员工编号)、<code>name</code>(员工名称)、<code>mobile</code>(电话)、<code>zip</code>(邮编)、<code>province</code>(省份)、<code>city</code>(城市)、<code>district</code>(区县)、<code>deptNo</code>(所属部门编号)、<code>deptName</code>(所属部门名称)、表总数据如下：</p><table><br><thead><br><tr><br><th>id</th><br><th>name</th><br><th>mobile</th><br><th>zip</th><br><th>province</th><br><th>city</th><br><th>district</th><br><th>deptNo</th><br><th>deptName</th><br></tr><br></thead><br><tbody><br><tr><br><td>101</td><br><td>张三</td><br>    <td>13910000001<br>13910000002</td><br><td>100001</td><br><td>北京</td><br><td>北京</td><br><td>海淀区</td><br><td>D1</td><br><td>部门1</td><br></tr><br><tr><br><td>101</td><br><td>张三</td><br><td>13910000001<br>13910000002</td><br><td>100001</td><br><td>北京</td><br><td>北京</td><br><td>海淀区</td><br><td>D2</td><br><td>部门2</td><br></tr><br><tr><br><td>102</td><br><td>李四</td><br><td>13910000003</td><br><td>200001</td><br><td>上海</td><br><td>上海</td><br><td>静安区</td><br><td>D3</td><br><td>部门3</td><br></tr><br><tr><br><td>103</td><br><td>王五</td><br><td>13910000004</td><br><td>510001</td><br><td>广东省</td><br><td>广州</td><br><td>白云区</td><br><td>D4</td><br><td>部门4</td><br></tr><br><tr><br><td>103</td><br><td>王五</td><br><td>13910000004</td><br><td>510001</td><br><td>广东省</td><br><td>广州</td><br><td>白云区</td><br><td>D5</td><br><td>部门 5</td><br></tr><br></tbody><br></table><p>将上表改成满足第1范式，如下：</p><table><br><thead><br><tr><br><th>id</th><br><th>name</th><br><th>mobile</th><br><th>zip</th><br><th>province</th><br><th>city</th><br><th>district</th><br><th>deptNo</th><br><th>deptName</th><br></tr><br></thead><br><tbody><br><tr><br><td>101</td><br><td>张三</td><br><td>13910000001</td><br><td>100001</td><br><td>北京</td><br><td>北京</td><br><td>海淀区</td><br><td>D1</td><br><td>部门1</td><br></tr><br><tr><br><td>101</td><br><td>张三</td><br><td>13910000002</td><br><td>100001</td><br><td>北京</td><br><td>北京</td><br><td>海淀区</td><br><td>D1</td><br><td>部门1</td><br></tr><br><tr><br><td>101</td><br><td>张三</td><br><td>13910000001</td><br><td>100001</td><br><td>北京</td><br><td>北京</td><br><td>海淀区</td><br><td>D2</td><br><td>部门2</td><br></tr><br><tr><br><td>101</td><br><td>张三</td><br><td>13910000002</td><br><td>100001</td><br><td>北京</td><br><td>北京</td><br><td>海淀区</td><br><td>D2</td><br><td>部门2</td><br></tr><br><tr><br><td>102</td><br><td>李四</td><br><td>13910000003</td><br><td>200001</td><br><td>上海</td><br><td>上海</td><br><td>静安区</td><br><td>D3</td><br><td>部门3</td><br></tr><br><tr><br><td>103</td><br><td>王五</td><br><td>13910000004</td><br><td>510001</td><br><td>广东省</td><br><td>广州</td><br><td>白云区</td><br><td>D4</td><br><td>部门4</td><br></tr><br><tr><br><td>103</td><br><td>王五</td><br><td>13910000004</td><br><td>510001</td><br><td>广东省</td><br><td>广州</td><br><td>白云区</td><br><td>D5</td><br><td>部门5</td><br></tr><br></tbody><br></table><h6 id="仍存在的问题"><a href="#仍存在的问题" class="headerlink" title="仍存在的问题"></a>仍存在的问题</h6><ol><li><strong>修改异常</strong>：上表中张三、王五都有多条记录，因为他隶属于两个部门。如果我们要修改王五的地址，必修修改两行记录。假如一个部门得到了王五的新地址并进行了更新，而另一个部门没有，那么此时王五在表中会存在两个不同的地址，导致了数据不一致</li><li><strong>新增异常：</strong>假如一个新员工假如公司，他正处于入职培训阶段，还没有被正式分配到某个部门，如果<code>deptNo</code>字段不允许为空，我们就无法向<code>employee</code>表中新增该员工的数据。</li><li><strong>删除异常：</strong>假设公司撤销了D3部门，那么在删除<code>deptNo</code>为D3的行时，会将李四的信息也一并删除。因为他隶属于D3这一部门。</li></ol><p>为了解决上面的问题，我们可以将上述表设计成满足3NF</p><p>在关系数据库模型设计中，一般需要满足第三范式的要求。如果一个表具有良好的主外键设计，就应该是满足3NF的表。规范化带来的好处是通过减少数据冗余提高更新数据的效率，同时保证数据完整性。然而，我们在实际应用中也要防止过度规范化的问题。规范化程度越高，划分的表就越多，在查询数据时越有可能使用表连接操作。而如果连接的表过多，会影响查询性能。关键的问题是要依据业务需求，仔细权衡数据查询和数据更新关系，指定最合适的规范化程度。不要为了遵循严格的规范化规则而修改业务需求。</p><p><a href="https://www.jianshu.com/p/5a8bb84289a9" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一范式-1NF&quot;&gt;&lt;a href=&quot;#第一范式-1NF&quot; class=&quot;headerlink&quot; title=&quot;第一范式(1NF)&quot;&gt;&lt;/a&gt;第一范式(1NF)&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值
      
    
    </summary>
    
      <category term="Mysql" scheme="https://shang.at/categories/Mysql/"/>
    
    
      <category term="第三范式" scheme="https://shang.at/tags/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-函数参数传递</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <id>https://shang.at/post/Python学习-函数参数传递/</id>
    <published>2020-04-19T04:00:49.000Z</published>
    <updated>2020-04-19T04:26:43.749Z</updated>
    
    <content type="html"><![CDATA[<p>在Python(估计也适用于其他的语言)中，函数参数的传递分为两类 值传递和引用传递，实际上这两类传递类型都是属于变量传值，即：</p><blockquote><p>值传递：将实际参数值复制一份传递到函数内，这样在函数内对参数进行修改，就不会影响到原参数</p><p>引用传递：将实际参数的地址直接传递到函数内，那么在函数内对参数所进行的修改，将可能会影响到原参数</p></blockquote><p>要注意的是，在函数内修改参数，实际上又分为两种情况(仅说引用传递)：</p><blockquote><p>1、对参数(a)重新进行赋值操作(a=new_obj)，此时，实际上修改的已经不是传递给函数的最初的参数(a)了，它已经指向了其他的内存地址，这时再修改a，实际上就和之前的对象没有任何关系了</p><p>2、直接对a进行修改，比如说a.name=’sdd’，这时，原始的对象就会发生变化</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Python(估计也适用于其他的语言)中，函数参数的传递分为两类 值传递和引用传递，实际上这两类传递类型都是属于变量传值，即：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;值传递：将实际参数值复制一份传递到函数内，这样在函数内对参数进行修改，就不会影响到原参数&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="python学习" scheme="https://shang.at/tags/python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-OrderedDict</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-OrderedDict/"/>
    <id>https://shang.at/post/Python学习-OrderedDict/</id>
    <published>2020-04-16T08:50:57.000Z</published>
    <updated>2020-04-16T08:51:22.122Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict  <span class="comment"># 记录插入顺序的dict，操作方式和dict一样。</span></span><br><span class="line"><span class="comment"># 是基于dict和双端队列实现，可以用来实现LRUcache</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; collections &lt;span cla
      
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="python源码学习" scheme="https://shang.at/tags/python%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-bisect</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-bisect/"/>
    <id>https://shang.at/post/Python学习-bisect/</id>
    <published>2020-04-16T08:47:50.000Z</published>
    <updated>2020-04-16T08:49:46.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个模块对有序列表提供了支持，使得他们可以在插入新数据仍然保持有序。对于长列表，如果其包含元素的比较操作十分昂贵的话，这可以是对更常见方法的改进</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""Bisection algorithms."""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the right of the rightmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line">insort = insort_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_right</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; a[mid]: hi = mid</span><br><span class="line">        <span class="keyword">else</span>: lo = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line">bisect = bisect_right   <span class="comment"># backward compatibility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insort_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Insert item x in list a, and keep it sorted assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If x is already in a, insert it to the left of the leftmost x.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    a.insert(lo, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bisect_left</span><span class="params">(a, x, lo=<span class="number">0</span>, hi=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'lo must be non-negative'</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = len(a)</span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">        mid = (lo+hi)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &lt; x: lo = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite above definitions with a fast C implementation</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> _bisect <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这个模块对有序列表提供了支持，使得他们可以在插入新数据仍然保持有序。对于长列表，如果其包含元素的比较操作十分昂贵的话，这可以是对更常见方法的改进&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight python&quot;&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="python源码学习" scheme="https://shang.at/tags/python%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习笔记-查找算法</title>
    <link href="https://shang.at/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://shang.at/post/数据结构与算法学习笔记-查找算法/</id>
    <published>2020-04-10T00:58:45.000Z</published>
    <updated>2020-04-10T01:00:39.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>查找算法</th><th>时间复杂度</th><th></th></tr></thead><tbody><tr><td>二分查找</td><td>O($$logn$$)</td><td>O(logn)</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;查找算法&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://shang.at/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找算法" scheme="https://shang.at/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spark应用之import spark.implicits._</title>
    <link href="https://shang.at/post/Spark%E5%BA%94%E7%94%A8%E4%B9%8Bimport-spark-implicits/"/>
    <id>https://shang.at/post/Spark应用之import-spark-implicits/</id>
    <published>2020-03-25T09:10:54.000Z</published>
    <updated>2020-03-27T06:38:15.397Z</updated>
    
    <content type="html"><![CDATA[<p>在初期使用spark的时候，大家都会遇见一个很奇怪的写法<strong><code>import spark.implicits._</code></strong></p><p>这里面包含了四个关键字：<code>import</code>、<code>spark</code>、<code>implicits</code>、<code>_</code></p><p><code>import</code>和<code>_</code>实际上是Scala中包引入的写法，表示引入指定包内的所有成员</p><p>本文主要想记录一下另外两个关键字：<code>spark</code>、<code>implicits</code></p><h4 id="关键字一：spark"><a href="#关键字一：spark" class="headerlink" title="关键字一：spark"></a>关键字一：spark</h4><h4 id="关键字二：implicits"><a href="#关键字二：implicits" class="headerlink" title="关键字二：implicits"></a>关键字二：implicits</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在初期使用spark的时候，大家都会遇见一个很奇怪的写法&lt;strong&gt;&lt;code&gt;import spark.implicits._&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里面包含了四个关键字：&lt;code&gt;import&lt;/code&gt;、&lt;code&gt;spark&lt;/co
      
    
    </summary>
    
      <category term="Spark" scheme="https://shang.at/categories/Spark/"/>
    
    
      <category term="Spark应用" scheme="https://shang.at/tags/Spark%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>hadoop源码学习一</title>
    <link href="https://shang.at/post/hadoop%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>https://shang.at/post/hadoop源码学习一/</id>
    <published>2019-07-10T03:03:43.000Z</published>
    <updated>2020-05-14T03:39:39.124Z</updated>
    
    <content type="html"><![CDATA[<p>先导知识</p><ul><li><p><a href="/post/Java学习-代理">JAVA-代理</a></p></li><li><p><a href="/post/分布式服务框架-IPC-RPC">IPC/RPC</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先导知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/post/Java学习-代理&quot;&gt;JAVA-代理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;/post/分布式服务框架-IPC-RPC&quot;&gt;IPC/RPC&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="Hadoop" scheme="https://shang.at/categories/Hadoop/"/>
    
    
      <category term="Hadoop-IPC" scheme="https://shang.at/tags/Hadoop-IPC/"/>
    
  </entry>
  
  <entry>
    <title>Pandas-学习</title>
    <link href="https://shang.at/post/Pandas-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://shang.at/post/Pandas-学习/</id>
    <published>2019-06-11T01:53:35.000Z</published>
    <updated>2019-08-03T02:17:49.584Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Pandas" scheme="https://shang.at/categories/Pandas/"/>
    
    
  </entry>
  
  <entry>
    <title>Python学习-时间处理</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
    <id>https://shang.at/post/Python学习-时间处理/</id>
    <published>2019-06-06T08:37:46.000Z</published>
    <updated>2019-08-03T02:17:49.584Z</updated>
    
    <content type="html"><![CDATA[<p>关于时间戳的几个概念<br>时间戳，根据1970年1月1日00:00:00开始按秒计算的偏移量。<br>时间元组（struct_time），包含9个元素。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">10</span>, tm_mday=<span class="number">1</span>, tm_hour=<span class="number">14</span>, tm_min=<span class="number">21</span>, tm_sec=<span class="number">57</span>, tm_wday=<span class="number">6</span>, tm_yday=<span class="number">274</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>时间格式字符串，字符串形式的时间。<br>time模块与时间戳和时间相关的重要函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time.time() <span class="comment"># 生成当前的时间戳，格式为10位整数的浮点数。</span></span><br><span class="line">time.strftime() <span class="comment"># 根据时间元组生成时间格式化字符串。</span></span><br><span class="line">time.strptime() <span class="comment"># 根据时间格式化字符串生成时间元组。time.strptime()与time.strftime()为互操作。</span></span><br><span class="line">time.localtime() <span class="comment"># 根据时间戳生成当前时区的时间元组。</span></span><br><span class="line">time.mktime() <span class="comment"># 根据时间元组生成时间戳。</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">##生成当前时间的时间戳，只有一个参数即时间戳的位数，默认为10位，输入位数即生成相应位数的时间戳，比如可以生成常用的13位时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now_to_timestamp</span><span class="params">(digits = <span class="number">10</span>)</span>:</span></span><br><span class="line">    time_stamp = time.time()</span><br><span class="line">    digits = <span class="number">10</span> ** (digits <span class="number">-10</span>)</span><br><span class="line">    time_stamp = int(round(time_stamp*digits))</span><br><span class="line">    <span class="keyword">return</span> time_stamp</span><br><span class="line"></span><br><span class="line"><span class="comment">##将时间戳规范为10位时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_timestamp10</span><span class="params">(time_stamp)</span>:</span></span><br><span class="line">    time_stamp = int (time_stamp* (<span class="number">10</span> ** (<span class="number">10</span>-len(str(time_stamp)))))</span><br><span class="line">    <span class="keyword">return</span> time_stamp</span><br><span class="line"></span><br><span class="line"><span class="comment">##将当前时间转换为时间字符串，默认为2017-10-01 13:37:04格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now_to_date</span><span class="params">(format_string=<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span>:</span></span><br><span class="line">    time_stamp = int(time.time())</span><br><span class="line">    time_array = time.localtime(time_stamp)</span><br><span class="line">    str_date = time.strftime(format_string, time_array)</span><br><span class="line">    <span class="keyword">return</span> str_date</span><br><span class="line"></span><br><span class="line"><span class="comment">##将10位时间戳转换为时间字符串，默认为2017-10-01 13:37:04格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_to_date</span><span class="params">(time_stamp, format_string=<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span>:</span></span><br><span class="line">    time_array = time.localtime(time_stamp)</span><br><span class="line">    str_date = time.strftime(format_string, time_array)</span><br><span class="line">    <span class="keyword">return</span> str_date</span><br><span class="line"></span><br><span class="line"><span class="comment">##将时间字符串转换为10位时间戳，时间字符串默认为2017-10-01 13:37:04格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_to_timestamp</span><span class="params">(date, format_string=<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span>:</span></span><br><span class="line">    time_array = time.strptime(date, format_string)</span><br><span class="line">    time_stamp = int(time.mktime(time_array))</span><br><span class="line">    <span class="keyword">return</span> time_stamp</span><br><span class="line"></span><br><span class="line"><span class="comment">##不同时间格式字符串的转换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_style_transfomation</span><span class="params">(date, format_string1=<span class="string">"%Y-%m-%d %H:%M:%S"</span>,format_string2=<span class="string">"%Y-%m-%d %H-%M-%S"</span>)</span>:</span></span><br><span class="line">    time_array  = time.strptime(date, format_string1)</span><br><span class="line">    str_date = time.strftime(format_string2, time_array)</span><br><span class="line">    <span class="keyword">return</span> str_date</span><br><span class="line"></span><br><span class="line">print(now_to_date())</span><br><span class="line">print(timestamp_to_date(<span class="number">1506816572</span>))</span><br><span class="line">print(date_to_timestamp(<span class="string">'2017-10-01 08:09:32'</span>))</span><br><span class="line">print(timestamp_to_timestamp10(<span class="number">1506816572546</span>))</span><br><span class="line">print(date_style_transfomation(<span class="string">'2017-10-01 08:09:32'</span>))</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1506836224000</span><br><span class="line">2017-10-01 13:37:04</span><br><span class="line">2017-10-01 08:09:32</span><br><span class="line">1506816572</span><br><span class="line">1506816572</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于时间戳的几个概念&lt;br&gt;时间戳，根据1970年1月1日00:00:00开始按秒计算的偏移量。&lt;br&gt;时间元组（struct_time），包含9个元素。 &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="python中的时间处理" scheme="https://shang.at/tags/python%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spark学习笔记-Configuration</title>
    <link href="https://shang.at/post/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Configuration/"/>
    <id>https://shang.at/post/Spark学习笔记-Configuration/</id>
    <published>2019-06-03T09:32:33.000Z</published>
    <updated>2019-08-03T02:17:49.585Z</updated>
    
    <content type="html"><![CDATA[<p> submit 参数</p><p>运行时可配置参数：在代码中使用spark.conf.set(‘’， ‘’)的方式设置。运行时设置的参数不会在WebUI中显示</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; submit 参数&lt;/p&gt;
&lt;p&gt;运行时可配置参数：在代码中使用spark.conf.set(‘’， ‘’)的方式设置。运行时设置的参数不会在WebUI中显示&lt;/p&gt;

      
    
    </summary>
    
      <category term="Spark" scheme="https://shang.at/categories/Spark/"/>
    
    
      <category term="Configuration" scheme="https://shang.at/tags/Configuration/"/>
    
  </entry>
  
  <entry>
    <title>Python学习-队列</title>
    <link href="https://shang.at/post/Python%E5%AD%A6%E4%B9%A0-%E9%98%9F%E5%88%97/"/>
    <id>https://shang.at/post/Python学习-队列/</id>
    <published>2019-06-03T02:10:48.000Z</published>
    <updated>2020-05-11T02:35:59.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue <span class="comment">#LILO队列</span></span><br><span class="line">q = Queue() <span class="comment">#创建队列对象</span></span><br><span class="line">q.put(<span class="number">0</span>)    <span class="comment">#在队列尾部插入元素</span></span><br><span class="line">q.put(<span class="number">1</span>)</span><br><span class="line">q.put(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'LILO队列'</span>,q.queue)  <span class="comment">#查看队列中的所有元素</span></span><br><span class="line">print(q.get())  <span class="comment">#返回并删除队列头部元素</span></span><br><span class="line">print(q.queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> LifoQueue <span class="comment">#LIFO队列</span></span><br><span class="line">lifoQueue = LifoQueue()</span><br><span class="line">lifoQueue.put(<span class="number">1</span>)</span><br><span class="line">lifoQueue.put(<span class="number">2</span>)</span><br><span class="line">lifoQueue.put(<span class="number">3</span>)</span><br><span class="line">print(<span class="string">'LIFO队列'</span>,lifoQueue.queue)</span><br><span class="line">lifoQueue.get() <span class="comment">#返回并删除队列尾部元素</span></span><br><span class="line">lifoQueue.get()</span><br><span class="line">print(lifoQueue.queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue <span class="comment">#优先队列</span></span><br><span class="line">priorityQueue = PriorityQueue() <span class="comment">#创建优先队列对象</span></span><br><span class="line">priorityQueue.put(<span class="number">3</span>)    <span class="comment">#插入元素</span></span><br><span class="line">priorityQueue.put(<span class="number">78</span>)   <span class="comment">#插入元素</span></span><br><span class="line">priorityQueue.put(<span class="number">100</span>)  <span class="comment">#插入元素</span></span><br><span class="line">print(priorityQueue.queue)  <span class="comment">#查看优先级队列中的所有元素</span></span><br><span class="line">priorityQueue.put(<span class="number">1</span>)    <span class="comment">#插入元素</span></span><br><span class="line">priorityQueue.put(<span class="number">2</span>)    <span class="comment">#插入元素</span></span><br><span class="line">print(<span class="string">'优先级队列:'</span>,priorityQueue.queue)  <span class="comment">#查看优先级队列中的所有元素</span></span><br><span class="line">priorityQueue.get() <span class="comment">#返回并删除优先级最低的元素</span></span><br><span class="line">print(<span class="string">'删除后剩余元素'</span>,priorityQueue.queue)</span><br><span class="line">priorityQueue.get() <span class="comment">#返回并删除优先级最低的元素</span></span><br><span class="line">print(<span class="string">'删除后剩余元素'</span>,priorityQueue.queue)  <span class="comment">#删除后剩余元素</span></span><br><span class="line">priorityQueue.get() <span class="comment">#返回并删除优先级最低的元素</span></span><br><span class="line">print(<span class="string">'删除后剩余元素'</span>,priorityQueue.queue)  <span class="comment">#删除后剩余元素</span></span><br><span class="line">priorityQueue.get() <span class="comment">#返回并删除优先级最低的元素</span></span><br><span class="line">print(<span class="string">'删除后剩余元素'</span>,priorityQueue.queue)  <span class="comment">#删除后剩余元素</span></span><br><span class="line">priorityQueue.get() <span class="comment">#返回并删除优先级最低的元素</span></span><br><span class="line">print(<span class="string">'全部被删除后:'</span>,priorityQueue.queue)  <span class="comment">#查看优先级队列中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment">#双端队列</span></span><br><span class="line">dequeQueue = deque([<span class="string">'Eric'</span>,<span class="string">'John'</span>,<span class="string">'Smith'</span>])</span><br><span class="line">print(dequeQueue)</span><br><span class="line">dequeQueue.append(<span class="string">'Tom'</span>)    <span class="comment">#在右侧插入新元素</span></span><br><span class="line">dequeQueue.appendleft(<span class="string">'Terry'</span>)  <span class="comment">#在左侧插入新元素</span></span><br><span class="line">print(dequeQueue)</span><br><span class="line">dequeQueue.rotate(<span class="number">2</span>)    <span class="comment">#循环右移2次</span></span><br><span class="line">print(<span class="string">'循环右移2次后的队列'</span>,dequeQueue)</span><br><span class="line">dequeQueue.popleft()    <span class="comment">#返回并删除队列最左端元素</span></span><br><span class="line">print(<span class="string">'删除最左端元素后的队列：'</span>,dequeQueue)</span><br><span class="line">dequeQueue.pop()    <span class="comment">#返回并删除队列最右端元素</span></span><br><span class="line">print(<span class="string">'删除最右端元素后的队列：'</span>,dequeQueue)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="Python" scheme="https://shang.at/categories/Python/"/>
    
    
      <category term="数据结构" scheme="https://shang.at/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Spark学习笔记-广播变量</title>
    <link href="https://shang.at/post/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/"/>
    <id>https://shang.at/post/Spark学习笔记-广播变量/</id>
    <published>2019-05-28T08:19:03.000Z</published>
    <updated>2019-08-03T02:17:49.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shared-Variables"><a href="#Shared-Variables" class="headerlink" title="Shared Variables"></a>Shared Variables</h2><p>通常，当在远程集群节点上执行传递给Spark操作（例如<code>map</code>or <code>reduce</code>）的函数时，它将在函数中使用的所有变量的单独副本上工作。这些变量将复制到每台计算机，并且远程计算机上的变量的更新不会传播回驱动程序。支持跨任务的通用，读写共享变量效率低下。但是，Spark确实为两种常见的使用模式提供了两种有限类型的<em>共享变量</em>：广播变量和累加器。</p><h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><p>广播变量允许程序员在每台机器上保留一个只读变量，而不是随副本一起发送它的副本。例如，它们可用于以有效的方式为每个节点提供大输入数据集的副本。Spark还尝试使用有效的广播算法来分发广播变量，以降低通信成本。</p><p>Spark动作通过一组阶段执行，由分布式“shuffle”操作分隔。Spark自动广播每个阶段中任务所需的公共数据。以这种方式广播的数据以序列化形式缓存并在运行每个任务之前反序列化。这意味着显式创建广播变量仅在跨多个阶段的任务需要相同数据或以反序列化形式缓存数据很重要时才有用。</p><p>广播变量是<code>v</code>通过调用从变量创建的<code>SparkContext.broadcast(v)</code>。广播变量是一个包装器<code>v</code>，可以通过调用该<code>value</code> 方法来访问它的值。下面的代码显示了这个：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>broadcastVar = sc.broadcast([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&lt;pyspark.broadcast.Broadcast object at <span class="number">0x102789f10</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>broadcastVar.value</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>创建广播变量后，应该使用它来代替<code>v</code>群集上运行的任何函数中的值，这样<code>v</code>就不会多次传送到节点。此外，在<code>v</code>广播之后不应修改对象 ，以确保所有节点获得相同的广播变量值（例如，如果稍后将变量发送到新节点）。</p><p><a href="https://spark.apache.org/docs/latest/sql-performance-tuning.html" target="_blank" rel="noopener">Performance Tuning</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">== Physical Plan ==</span><br><span class="line">InMemoryTableScan [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_outstanding_amount_ex_dp90#6075]</span><br><span class="line">   +- InMemoryRelation [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_outstanding_amount_ex_dp90#6075], true, 10000, StorageLevel(disk, 1 replicas)</span><br><span class="line">         +- *(34) Project [bill_create_date#4955, week_last_day#5015, month_last_day#5075, ((coalesce(nanvl(total_disburse_amount#5203, null), 0.0) - cast(coalesce(total_repay_principal_amount#5974, 0) as double)) - coalesce(nanvl(total_write_off_principal#5986, null), 0.0)) AS total_outstanding_amount_ex_dp90#6075]</span><br><span class="line">            +- SortMergeJoin [bill_create_date#4955], [write_off_date#4776], LeftOuter</span><br><span class="line">               :- *(23) Project [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_disburse_amount#5203, total_repay_principal_amount#5974]</span><br><span class="line">               :  +- SortMergeJoin [bill_create_date#4955], [repay_date#5789], LeftOuter</span><br><span class="line">               :     :- *(6) Sort [bill_create_date#4955 ASC NULLS FIRST], false, 0</span><br><span class="line">               :     :  +- Exchange hashpartitioning(bill_create_date#4955, 200)</span><br><span class="line">               :     :     +- *(5) Project [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_disburse_amount#5203]</span><br><span class="line">               :     :        +- Window [sum(disburse_amount#5197) windowspecdefinition(1, bill_create_date#4955 ASC NULLS FIRST, specifiedwindowframe(RangeFrame, unboundedpreceding$(), currentrow$())) AS total_disburse_amount#5203], [1], [bill_create_date#4955 ASC NULLS FIRST]</span><br><span class="line">               :     :           +- *(4) Sort [1 ASC NULLS FIRST, bill_create_date#4955 ASC NULLS FIRST], false, 0</span><br><span class="line">               :     :              +- Exchange hashpartitioning(1, 200)</span><br><span class="line">               :     :                 +- *(3) HashAggregate(keys=[bill_create_date#4955, week_last_day#5015, month_last_day#5075], functions=[sum(cast(principal#615 as double))])</span><br><span class="line">               :     :                    +- Exchange hashpartitioning(bill_create_date#4955, week_last_day#5015, month_last_day#5075, 200)</span><br><span class="line">               :     :                       +- *(2) HashAggregate(keys=[bill_create_date#4955, week_last_day#5015, month_last_day#5075], functions=[partial_sum(cast(principal#615 as double))])</span><br><span class="line">               :     :                          +- *(2) Project [principal#615, cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) AS bill_create_date#4955, next_day(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), Sun) AS week_last_day#5015, last_day(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date)) AS month_last_day#5075]</span><br><span class="line">               :     :                             +- *(2) BroadcastHashJoin [id#392], [loan_id#609], Inner, BuildRight</span><br><span class="line">               :     :                                :- *(2) Project [id#392]</span><br><span class="line">               :     :                                :  +- *(2) Filter (status#397 IN (COMPLETED,CURRENT,LATE) &amp;&amp; isnotnull(id#392))</span><br><span class="line">               :     :                                :     +- *(2) FileScan parquet [id#392,status#397] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [In(status, [COMPLETED,CURRENT,LATE]), IsNotNull(id)], ReadSchema: struct&lt;id:string,status:string&gt;</span><br><span class="line">               :     :                                +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true]))</span><br><span class="line">               :     :                                   +- *(1) Project [loan_id#609, principal#615, create_time#632L]</span><br><span class="line">               :     :                                      +- *(1) Filter ((cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) &lt;= 18043) &amp;&amp; isnotnull(loan_id#609))</span><br><span class="line">               :     :                                         +- *(1) FileScan parquet [loan_id#609,principal#615,create_time#632L] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [IsNotNull(loan_id)], ReadSchema: struct&lt;loan_id:string,principal:string,create_time:bigint&gt;</span><br><span class="line">               :     +- *(22) Sort [repay_date#5789 ASC NULLS FIRST], false, 0</span><br><span class="line">               :        +- Exchange hashpartitioning(repay_date#5789, 200)</span><br><span class="line">               :           +- *(21) Project [repay_date#5789, total_repay_principal_amount#5974]</span><br><span class="line">               :              +- Window [sum(repay_principal_amount#5970) windowspecdefinition(1, repay_date#5789 ASC NULLS FIRST, specifiedwindowframe(RangeFrame, unboundedpreceding$(), currentrow$())) AS total_repay_principal_amount#5974], [1], [repay_date#5789 ASC NULLS FIRST]</span><br><span class="line">               :                 +- *(20) Sort [1 ASC NULLS FIRST, repay_date#5789 ASC NULLS FIRST], false, 0</span><br><span class="line">               :                    +- Exchange hashpartitioning(1, 200)</span><br><span class="line">               :                       +- *(19) HashAggregate(keys=[repay_date#5789], functions=[sum(CASE WHEN (isnull(write_off_date#4776) || (write_off_date#4776 &gt; repay_date#5789)) THEN repaid_principal#684 END)])</span><br><span class="line">               :                          +- Exchange hashpartitioning(repay_date#5789, 200)</span><br><span class="line">               :                             +- *(18) HashAggregate(keys=[repay_date#5789], functions=[partial_sum(CASE WHEN (isnull(write_off_date#4776) || (write_off_date#4776 &gt; repay_date#5789)) THEN repaid_principal#684 END)])</span><br><span class="line">               :                                +- *(18) Project [repaid_principal#684, write_off_date#4776, cast(from_utc_timestamp(repay_time#692, Asia/Ho_Chi_Minh) as date) AS repay_date#5789]</span><br><span class="line">               :                                   +- SortMergeJoin [loan_id#609], [loan_id#5672], LeftOuter</span><br><span class="line">               :                                      :- *(12) Sort [loan_id#609 ASC NULLS FIRST], false, 0</span><br><span class="line">               :                                      :  +- Exchange hashpartitioning(loan_id#609, 200)</span><br><span class="line">               :                                      :     +- *(11) Project [loan_id#609, repaid_principal#684, repay_time#692]</span><br><span class="line">               :                                      :        +- *(11) BroadcastHashJoin [id#608], [bill_id#670], Inner, BuildRight</span><br><span class="line">               :                                      :           :- *(11) Project [id#608, loan_id#609]</span><br><span class="line">               :                                      :           :  +- *(11) BroadcastHashJoin [id#392], [loan_id#609], Inner, BuildRight</span><br><span class="line">               :                                      :           :     :- *(11) Project [id#392]</span><br><span class="line">               :                                      :           :     :  +- *(11) Filter (status#397 IN (COMPLETED,CURRENT,LATE) &amp;&amp; isnotnull(id#392))</span><br><span class="line">               :                                      :           :     :     +- *(11) FileScan parquet [id#392,status#397] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [In(status, [COMPLETED,CURRENT,LATE]), IsNotNull(id)], ReadSchema: struct&lt;id:string,status:string&gt;</span><br><span class="line">               :                                      :           :     +- BroadcastExchange HashedRelationBroadcastMode(List(input[1, string, true]))</span><br><span class="line">               :                                      :           :        +- *(7) Project [id#608, loan_id#609]</span><br><span class="line">               :                                      :           :           +- *(7) Filter (isnotnull(loan_id#609) &amp;&amp; isnotnull(id#608))</span><br><span class="line">               :                                      :           :              +- *(7) FileScan parquet [id#608,loan_id#609] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [IsNotNull(loan_id), IsNotNull(id)], ReadSchema: struct&lt;id:string,loan_id:string&gt;</span><br><span class="line">               :                                      :           +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[0, string, true]))</span><br><span class="line">               :                                      :              +- *(10) Project [bill_id#670, repaid_principal#684, repay_time#692]</span><br><span class="line">               :                                      :                 +- *(10) Filter ((isnotnull(rn#5382) &amp;&amp; (rn#5382 = 1)) &amp;&amp; (cast(from_utc_timestamp(repay_time#692, Asia/Ho_Chi_Minh) as date) &lt;= 18043))</span><br><span class="line">               :                                      :                    +- Window [row_number() windowspecdefinition(bill_id#670, repay_time#692 DESC NULLS LAST, specifiedwindowframe(RowFrame, unboundedpreceding$(), currentrow$())) AS rn#5382], [bill_id#670], [repay_time#692 DESC NULLS LAST]</span><br><span class="line">               :                                      :                       +- *(9) Sort [bill_id#670 ASC NULLS FIRST, repay_time#692 DESC NULLS LAST], false, 0</span><br><span class="line">               :                                      :                          +- Exchange hashpartitioning(bill_id#670, 200)</span><br><span class="line">               :                                      :                             +- *(8) Project [bill_id#670, repaid_principal#684, repay_time#692]</span><br><span class="line">               :                                      :                                +- *(8) Filter isnotnull(bill_id#670)</span><br><span class="line">               :                                      :                                   +- *(8) FileScan parquet [bill_id#670,repaid_principal#684,repay_time#692] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [IsNotNull(bill_id)], ReadSchema: struct&lt;bill_id:string,repaid_principal:decimal(20,0),repay_time:timestamp&gt;</span><br><span class="line">               :                                      +- *(17) Sort [loan_id#5672 ASC NULLS FIRST], false, 0</span><br><span class="line">               :                                         +- *(17) HashAggregate(keys=[loan_id#5672], functions=[first(write_off_date#4705, true)])</span><br><span class="line">               :                                            +- *(17) HashAggregate(keys=[loan_id#5672], functions=[partial_first(write_off_date#4705, true)])</span><br><span class="line">               :                                               +- *(17) Project [loan_id#5672, write_off_date#4705]</span><br><span class="line">               :                                                  +- *(17) BroadcastHashJoin [bill_id#4714], [bill_id#670], LeftOuter, BuildRight</span><br><span class="line">               :                                                     :- *(17) Project [loan_id#5672, write_off_date#4705, bill_id#4714]</span><br><span class="line">               :                                                     :  +- *(17) BroadcastHashJoin [loan_id#5672], [loan_id#4718], LeftOuter, BuildRight</span><br><span class="line">               :                                                     :     :- *(17) Project [loan_id#5672, write_off_date#4705]</span><br><span class="line">               :                                                     :     :  +- *(17) BroadcastHashJoin [loan_id#5672], [loan_id#4708], LeftOuter, BuildRight</span><br><span class="line">               :                                                     :     :     :- *(17) HashAggregate(keys=[loan_id#5672], functions=[min(CASE WHEN is_write_off_bill#4594 THEN write_off_date#4630 END)])</span><br><span class="line">               :                                                     :     :     :  +- Exchange hashpartitioning(loan_id#5672, 200)</span><br><span class="line">               :                                                     :     :     :     +- *(13) HashAggregate(keys=[loan_id#5672], functions=[partial_min(CASE WHEN is_write_off_bill#4594 THEN write_off_date#4630 END)])</span><br><span class="line">               :                                                     :     :     :        +- *(13) Project [loan_id#5672, (CASE WHEN isnotnull(CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END WHEN isnotnull(CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END ELSE 0 END &gt;= 91) AS is_write_off_bill#4594, date_add(cast(due_date#5686 as date), 91) AS write_off_date#4630]</span><br><span class="line">               :                                                     :     :     :           +- *(13) Filter (CASE WHEN isnotnull(CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END WHEN isnotnull(CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END ELSE 0 END &gt;= 91)</span><br><span class="line">               :                                                     :     :     :              +- *(13) FileScan parquet [loan_id#5672,status#5676,due_date#5686,repay_time#5694L] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;loan_id:string,status:string,due_date:string,repay_time:bigint&gt;</span><br><span class="line">               :                                                     :     :     +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[0, string, true]))</span><br><span class="line">               :                                                     :     :        +- *(14) Project [id#392 AS loan_id#4708]</span><br><span class="line">               :                                                     :     :           +- *(14) FileScan parquet [id#392] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;id:string&gt;</span><br><span class="line">               :                                                     :     +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[1, string, true]))</span><br><span class="line">               :                                                     :        +- *(15) Project [id#4717 AS bill_id#4714, loan_id#4718]</span><br><span class="line">               :                                                     :           +- *(15) FileScan parquet [id#4717,loan_id#4718] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;id:string,loan_id:string&gt;</span><br><span class="line">               :                                                     +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true]))</span><br><span class="line">               :                                                        +- *(16) FileScan parquet [bill_id#670] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;bill_id:string&gt;</span><br><span class="line">               +- *(33) Sort [write_off_date#4776 ASC NULLS FIRST], false, 0</span><br><span class="line">                  +- Exchange hashpartitioning(write_off_date#4776, 200)</span><br><span class="line">                     +- *(32) Project [write_off_date#4776, total_write_off_principal#5986]</span><br><span class="line">                        +- Window [sum(write_off_principal#5982) windowspecdefinition(1, write_off_date#4776 ASC NULLS FIRST, specifiedwindowframe(RangeFrame, unboundedpreceding$(), currentrow$())) AS total_write_off_principal#5986], [1], [write_off_date#4776 ASC NULLS FIRST]</span><br><span class="line">                           +- *(31) Sort [1 ASC NULLS FIRST, write_off_date#4776 ASC NULLS FIRST], false, 0</span><br><span class="line">                              +- Exchange hashpartitioning(1, 200)</span><br><span class="line">                                 +- *(30) HashAggregate(keys=[write_off_date#4776], functions=[sum(write_off_principal#4779)])</span><br><span class="line">                                    +- Exchange hashpartitioning(write_off_date#4776, 200)</span><br><span class="line">                                       +- *(29) HashAggregate(keys=[write_off_date#4776], functions=[partial_sum(write_off_principal#4779)])</span><br><span class="line">                                          +- SortAggregate(key=[loan_id#609], functions=[first(write_off_date#4705, true), first(amount#398, true), sum(CASE WHEN (isnotnull(repayment_date#4760) &amp;&amp; (repayment_date#4760 &lt; write_off_date#4705)) THEN repaid_principal#684 ELSE 0 END)])</span><br><span class="line">                                             +- SortAggregate(key=[loan_id#609], functions=[partial_first(write_off_date#4705, true), partial_first(amount#398, true), partial_sum(CASE WHEN (isnotnull(repayment_date#4760) &amp;&amp; (repayment_date#4760 &lt; write_off_date#4705)) THEN repaid_principal#684 ELSE 0 END)])</span><br><span class="line">                                                +- *(28) Sort [loan_id#609 ASC NULLS FIRST], false, 0</span><br><span class="line">                                                   +- *(28) Project [loan_id#609, write_off_date#4705, amount#398, repaid_principal#684, cast(from_utc_timestamp(repay_time#692, Asia/Ho_Chi_Minh) as date) AS repayment_date#4760]</span><br><span class="line">                                                      +- *(28) BroadcastHashJoin [bill_id#4714], [bill_id#670], LeftOuter, BuildRight</span><br><span class="line">                                                         :- *(28) Project [loan_id#609, write_off_date#4705, amount#398, bill_id#4714]</span><br><span class="line">                                                         :  +- *(28) BroadcastHashJoin [loan_id#609], [loan_id#4718], LeftOuter, BuildRight</span><br><span class="line">                                                         :     :- *(28) Project [loan_id#609, write_off_date#4705, amount#398]</span><br><span class="line">                                                         :     :  +- *(28) BroadcastHashJoin [loan_id#609], [loan_id#4708], LeftOuter, BuildRight</span><br><span class="line">                                                         :     :     :- *(28) HashAggregate(keys=[loan_id#609], functions=[min(CASE WHEN is_write_off_bill#4594 THEN write_off_date#4630 END)])</span><br><span class="line">                                                         :     :     :  +- ReusedExchange [loan_id#609, min#6101], Exchange hashpartitioning(loan_id#5672, 200)</span><br><span class="line">                                                         :     :     +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[0, string, true]))</span><br><span class="line">                                                         :     :        +- *(25) Project [id#392 AS loan_id#4708, amount#398]</span><br><span class="line">                                                         :     :           +- *(25) FileScan parquet [id#392,amount#398] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;id:string,amount:string&gt;</span><br><span class="line">                                                         :     +- ReusedExchange [bill_id#4714, loan_id#4718], BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[1, string, true]))</span><br><span class="line">                                                         +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true]))</span><br><span class="line">                                                            +- *(27) Project [bill_id#670, repay_time#692, repaid_principal#684]</span><br><span class="line">                                                               +- *(27) FileScan parquet [bill_id#670,repaid_principal#684,repay_time#692] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;bill_id:string,repaid_principal:decimal(20,0),repay_time:timestamp&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shared-Variables&quot;&gt;&lt;a href=&quot;#Shared-Variables&quot; class=&quot;headerlink&quot; title=&quot;Shared Variables&quot;&gt;&lt;/a&gt;Shared Variables&lt;/h2&gt;&lt;p&gt;通常，当在远程集群节点上执行
      
    
    </summary>
    
      <category term="Spark" scheme="https://shang.at/categories/Spark/"/>
    
    
      <category term="Spark学习" scheme="https://shang.at/tags/Spark%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记二-算法</title>
    <link href="https://shang.at/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E7%AE%97%E6%B3%95/"/>
    <id>https://shang.at/post/数据结构学习笔记二-算法/</id>
    <published>2019-05-16T09:54:29.000Z</published>
    <updated>2019-05-16T14:39:58.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="深度和广度优先搜索"><a href="#深度和广度优先搜索" class="headerlink" title="深度和广度优先搜索"></a>深度和广度优先搜索</h2><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>##分治算法</p><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h2 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://shang.at/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://shang.at/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
