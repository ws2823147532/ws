<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>努力，奋斗</title>
  
  <subtitle>记录学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shang.at/"/>
  <updated>2020-08-09T15:07:24.336Z</updated>
  <id>https://shang.at/</id>
  
  <author>
    <name>王尚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具使用-编译工具-sbt</title>
    <link href="https://shang.at/post/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7-sbt/"/>
    <id>https://shang.at/post/工具使用-编译工具-sbt/</id>
    <published>2020-08-09T15:07:24.000Z</published>
    <updated>2020-08-09T15:07:24.336Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spark学习-源码一-wordcount</title>
    <link href="https://shang.at/post/Spark%E5%AD%A6%E4%B9%A0-%E6%BA%90%E7%A0%81%E4%B8%80-wordcount/"/>
    <id>https://shang.at/post/Spark学习-源码一-wordcount/</id>
    <published>2020-08-09T00:12:46.000Z</published>
    <updated>2020-08-09T03:20:05.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：Spark源码学习-wordcount代码跟踪</p></blockquote><a id="more"></a><p>SparkContext：RPC、序列化、反序列化、零拷贝、堆内内存、堆外内存</p><p>sc.clean(f)：检查f是否可序列化</p><p>第一步数据文件testdata.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello msb</span><br><span class="line">hello spark</span><br><span class="line">good spark</span><br></pre></td></tr></table></figure><p>第二步spark脚本</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountScala</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setAppName(<span class="string">"wordcount"</span>)</span><br><span class="line">    conf.setMaster(<span class="string">"local"</span>) <span class="comment">//单击本地运行</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"testdata.txt"</span>)</span><br><span class="line">    <span class="comment">//hello world</span></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap((x: <span class="type">String</span>) =&gt; _.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="comment">//hello</span></span><br><span class="line">    <span class="comment">//world</span></span><br><span class="line">    <span class="keyword">val</span> pairWord: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map((x: <span class="type">String</span>) =&gt; (_, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">//(hello,1)</span></span><br><span class="line">    <span class="comment">//(hello,1)</span></span><br><span class="line">    <span class="comment">//(world,1)</span></span><br><span class="line">    <span class="keyword">val</span> res: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = pairWord.reduceByKey((x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y)</span><br><span class="line">    <span class="comment">//X:oldValue  Y:value</span></span><br><span class="line">    <span class="comment">//(hello,2)  -&gt; (2,1)</span></span><br><span class="line">    <span class="comment">//(world,1)   -&gt; (1,1)</span></span><br><span class="line">    <span class="comment">//(msb,2)   -&gt; (2,1)</span></span><br><span class="line"></span><br><span class="line">    res.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面跟踪wordcount脚本的数据流的操作流程，从表面上看我们是调用了RDD的api，但实际上我们调用的这些个api只是构造了一个数据流程，并没有去实际的运行相关的逻辑，最后我们会引出，它底层实际上是基于我们最常见的一种编程模式——— 迭代器模式。</p><p>一个大数据处理框架，他为我们做了什么事情呢？</p><p>1、读取数据，确定数据在集群中存储的位置</p><p>2、分配任务，任务具体会在哪里执行呢？遵循<code>计算向数据移动</code>的原则</p><p>3、根据我们写出来的脚本，生成任务的执行计划，DAG。</p><p>4、启动任务，调用我们的计算逻辑。 就像是我们平常所说的模板方法，函数回调(callback)</p><p>5、将结果写入目标文件</p><p>6、在这个过程中，框架还会帮助我们解决集群中的网络通信(RPC)、数据传输(编解码/序列化反序列化)、各种优化(零拷贝，内存管理、计算结果缓存)</p><hr><p>第一步：<code>val fileRDD: RDD[String] = sc.textFile(&quot;testdata.txt&quot;)</code></p><p>跟踪下去，他实际上是调用的SparkContext对象的textFile方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textFile</span></span>(</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    minPartitions: <span class="type">Int</span> = defaultMinPartitions): <span class="type">RDD</span>[<span class="type">String</span>] = withScope &#123;</span><br><span class="line">  assertNotStopped()</span><br><span class="line">  hadoopFile(path, classOf[<span class="type">TextInputFormat</span>], classOf[<span class="type">LongWritable</span>], classOf[<span class="type">Text</span>],</span><br><span class="line">    minPartitions).map(pair =&gt; pair._2.toString).setName(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hadoopFile</span></span>[<span class="type">K</span>, <span class="type">V</span>](</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    inputFormatClass: <span class="type">Class</span>[_ &lt;: <span class="type">InputFormat</span>[<span class="type">K</span>, <span class="type">V</span>]],</span><br><span class="line">    keyClass: <span class="type">Class</span>[<span class="type">K</span>],</span><br><span class="line">    valueClass: <span class="type">Class</span>[<span class="type">V</span>],</span><br><span class="line">    minPartitions: <span class="type">Int</span> = defaultMinPartitions): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = withScope &#123;</span><br><span class="line">  assertNotStopped()</span><br><span class="line">  <span class="type">FileSystem</span>.getLocal(hadoopConfiguration)</span><br><span class="line">  <span class="keyword">val</span> confBroadcast = broadcast(<span class="keyword">new</span> <span class="type">SerializableConfiguration</span>(hadoopConfiguration))</span><br><span class="line">  <span class="keyword">val</span> setInputPathsFunc = (jobConf: <span class="type">JobConf</span>) =&gt; <span class="type">FileInputFormat</span>.setInputPaths(jobConf, path)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">HadoopRDD</span>(</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    confBroadcast,</span><br><span class="line">    <span class="type">Some</span>(setInputPathsFunc),</span><br><span class="line">    inputFormatClass,</span><br><span class="line">    keyClass,</span><br><span class="line">    valueClass,</span><br><span class="line">    minPartitions).setName(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现最终实际上返回的一个HadoopRDD对象，并没有做什么具体的计算。OK，我们继续往下看：</p><p>第二步：<code>val words: RDD[String] = fileRDD.flatMap((x: String) =&gt; _.split(&quot; &quot;))</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：Spark源码学习-wordcount代码跟踪&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java学习-IO学习4-C10K问题及NIO精讲和IO模型性能压测</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-IO%E5%AD%A6%E4%B9%A04-C10K%E9%97%AE%E9%A2%98%E5%8F%8ANIO%E7%B2%BE%E8%AE%B2%E5%92%8CIO%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/"/>
    <id>https://shang.at/post/Java学习-IO学习4-C10K问题及NIO精讲和IO模型性能压测/</id>
    <published>2020-08-03T00:12:30.000Z</published>
    <updated>2020-08-03T00:12:30.028Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java学习-IO学习3-Socket编程BIO及TCP参数</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-IO%E5%AD%A6%E4%B9%A03-Socket%E7%BC%96%E7%A8%8BBIO%E5%8F%8ATCP%E5%8F%82%E6%95%B0/"/>
    <id>https://shang.at/post/Java学习-IO学习3-Socket编程BIO及TCP参数/</id>
    <published>2020-08-03T00:12:15.000Z</published>
    <updated>2020-08-03T00:12:15.163Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java学习-IO学习2-PageCache-mmap</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-IO%E5%AD%A6%E4%B9%A02-PageCache-mmap/"/>
    <id>https://shang.at/post/Java学习-IO学习2-PageCache-mmap/</id>
    <published>2020-08-03T00:11:59.000Z</published>
    <updated>2020-08-03T00:11:59.864Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java学习-IO学习1-虚拟文件系统-文件描述符-IO重定向</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-IO%E5%AD%A6%E4%B9%A01-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-IO%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://shang.at/post/Java学习-IO学习1-虚拟文件系统-文件描述符-IO重定向/</id>
    <published>2020-08-03T00:11:29.000Z</published>
    <updated>2020-08-03T00:11:29.125Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java学习-IO学习5-网络编程之多路复用器及Epoll</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-IO%E5%AD%A6%E4%B9%A05-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8%E5%8F%8AEpoll/"/>
    <id>https://shang.at/post/Java学习-IO学习5-网络编程之多路复用器及Epoll/</id>
    <published>2020-08-03T00:08:15.000Z</published>
    <updated>2020-08-03T00:10:28.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JAVA-IO" scheme="https://shang.at/tags/JAVA-IO/"/>
    
      <category term="Epoll" scheme="https://shang.at/tags/Epoll/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-0.3-抽象类</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-0-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://shang.at/post/Scala学习-0-3-抽象类/</id>
    <published>2020-07-31T00:34:32.000Z</published>
    <updated>2020-08-05T08:53:08.877Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>特质和抽象类可以包含一个抽象类型成员，意味着实际类型可由具体实现来确定。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">element</span></span>: <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义的抽象类型<code>T</code>是用来描述成员<code>element</code>的类型的。通过抽象类来扩展这个特质后，就可以添加一个类型上边界来让抽象类型<code>T</code>变得更加具体。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">U</span></span></span><br><span class="line"><span class="class">  <span class="title">type</span> <span class="title">T</span> <span class="title">&lt;</span></span>: <span class="type">Seq</span>[<span class="type">U</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">length</span> </span>= element.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里是如何借助另外一个抽象类型<code>U</code>来限定类型上边界的。通过声明类型<code>T</code>只可以是<code>Seq[U]</code>的子类（其中U是一个新的抽象类型），这个<code>SeqBuffer</code>类就限定了缓冲区中存储的元素类型只能是序列。</p><p>含有抽象类型成员的特质或类（<a href="https://docs.scala-lang.org/zh-cn/tour/classes.html" target="_blank" rel="noopener">classes</a>）经常和匿名类的初始化一起使用。为了能够阐明问题，下面看一段程序，它处理一个涉及整型列表的序列缓冲区。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSeqBuffer</span> <span class="keyword">extends</span> <span class="title">SeqBuffer</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">U</span> </span>= <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newIntSeqBuf</span></span>(elem1: <span class="type">Int</span>, elem2: <span class="type">Int</span>): <span class="type">IntSeqBuffer</span> =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">IntSeqBuffer</span> &#123;</span><br><span class="line">       <span class="class"><span class="keyword">type</span> <span class="title">T</span> </span>= <span class="type">List</span>[<span class="type">U</span>]</span><br><span class="line">       <span class="keyword">val</span> element = <span class="type">List</span>(elem1, elem2)</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">val</span> buf = newIntSeqBuf(<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">println(<span class="string">"length = "</span> + buf.length)</span><br><span class="line">println(<span class="string">"content = "</span> + buf.element)</span><br></pre></td></tr></table></figure><p>这里的工厂方法<code>newIntSeqBuf</code>使用了<code>IntSeqBuf</code>的匿名类实现方式，其类型<code>T</code>被设置成了<code>List[Int]</code>。</p><p>把抽象类型成员转成类的类型参数或者反过来，也是可行的。如下面这个版本只用了类的类型参数来转换上面的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> element: <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqBuffer</span>[<span class="type">U</span>, +<span class="type">T</span> &lt;: <span class="type">Seq</span>[<span class="type">U</span>]] <span class="keyword">extends</span> <span class="title">Buffer</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">length</span> </span>= element.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newIntSeqBuf</span></span>(e1: <span class="type">Int</span>, e2: <span class="type">Int</span>): <span class="type">SeqBuffer</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">Int</span>]] =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">SeqBuffer</span>[<span class="type">Int</span>, <span class="type">List</span>[<span class="type">Int</span>]] &#123;</span><br><span class="line">    <span class="keyword">val</span> element = <span class="type">List</span>(e1, e2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> buf = newIntSeqBuf(<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">println(<span class="string">"length = "</span> + buf.length)</span><br><span class="line">println(<span class="string">"content = "</span> + buf.element)</span><br></pre></td></tr></table></figure><p>需要注意的是为了隐藏从方法<code>newIntSeqBuf</code>返回的对象的具体序列实现的类型，这里的<a href="https://docs.scala-lang.org/zh-cn/tour/variances.html" target="_blank" rel="noopener">型变标号</a>（<code>+T &lt;: Seq[U]</code>）是必不可少的。此外要说明的是，有些情况下用类型参数替换抽象类型是行不通的。</p><h2 id="类型边界"><a href="#类型边界" class="headerlink" title="类型边界"></a>类型边界</h2><p>实际上就是定义了父类与子类的关系  还是有点疑惑的…</p><ul><li><p>类型上界</p><p>比如像<code>T &lt;: A</code>这样声明的类型上界表示类型变量<code>T</code>应该是类型<code>A</code>的子类</p></li><li><p>类型下界</p><p>术语 <code>B &gt;: A</code> 表示类型参数 <code>B</code> 或抽象类型 <code>B</code> 是类型 <code>A</code> 的超类型。 在大多数情况下，<code>A</code> 将是类的类型参数，而 <code>B</code> 将是方法的类型参数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala学习-0.2-泛型</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-0-2-%E6%B3%9B%E5%9E%8B/"/>
    <id>https://shang.at/post/Scala学习-0-2-泛型/</id>
    <published>2020-07-31T00:23:17.000Z</published>
    <updated>2020-08-05T08:42:04.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><p>与java不同，java中的泛型用<code>&lt;&gt;</code>包围，在scala中泛型用<code>[]</code>包围</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala泛型" scheme="https://shang.at/tags/Scala%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-0.1-import</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-0-1-import/"/>
    <id>https://shang.at/post/Scala学习-0-1-import/</id>
    <published>2020-07-31T00:23:01.000Z</published>
    <updated>2020-08-05T08:26:32.285Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><h1 id="Scala的import机制总结"><a href="#Scala的import机制总结" class="headerlink" title="Scala的import机制总结"></a>Scala的import机制总结</h1><p>import 主要用于导入各种名字空间（package）或其包含的成员，使它们在声明的作用域里可见。</p><h2 id="1-导入package"><a href="#1-导入package" class="headerlink" title="1 导入package"></a>1 导入package</h2><p>  访问package的成员需要用导入的package名作为前缀，主要用于当package嵌套较多时，可以起到简化及隔离名字空间的作用。</p><p>  当然任何时候使用完整package路径（full package path）都是可以的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.util</span><br><span class="line">new util.ArrayList[String]() // 需要有util作为前缀，省略掉util的父package “java”</span><br><span class="line">new java.util.ArrayList[String] // 通过完整package路径访问</span><br><span class="line"></span><br><span class="line">import java.sql</span><br><span class="line">new sql.Date(new util.Date().getTime) // 使用package名隔离Date类的名字冲突</span><br></pre></td></tr></table></figure><h2 id="2-导入package下所有成员"><a href="#2-导入package下所有成员" class="headerlink" title="2 导入package下所有成员"></a>2 导入package下所有成员</h2><p>  相比Java中使用‘*’，Scala使用’_’表示导入package下所有成员. </p><p>  如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>]</span><br><span class="line">&lt;console&gt;:<span class="number">7</span>: error: not found: <span class="class"><span class="keyword">type</span> <span class="title">HashMap</span></span></span><br><span class="line"><span class="class">       <span class="title">val</span> <span class="title">map</span> </span>= <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>]</span><br><span class="line">                     ^</span><br><span class="line">scala&gt; <span class="keyword">import</span> scala.collection.immutable.<span class="type">HashMap</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.immutable.<span class="type">HashMap</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>]</span><br><span class="line">map: scala.collection.immutable.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>()</span><br><span class="line"></span><br><span class="line">scala&gt; map += <span class="string">"itang"</span> -&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; map</span><br><span class="line">res1: scala.collection.immutable.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(itang -&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">import</span> java.util._</span><br><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">ArrayList</span>[<span class="type">String</span>]()</span><br></pre></td></tr></table></figure><h2 id="3-导入package下特定成员"><a href="#3-导入package下特定成员" class="headerlink" title="3 导入package下特定成员"></a>3 导入package下特定成员</h2><p>  指定package路径及要导入的类等的名称，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ArrayList[Int]</span><br></pre></td></tr></table></figure><h2 id="4-导入package下特定成员，并重命名"><a href="#4-导入package下特定成员，并重命名" class="headerlink" title="4 导入package下特定成员，并重命名"></a>4 导入package下特定成员，并重命名</h2><p>  在要导入package后使用”{}”,指定要导入的成员，并使用”=&gt;”重命名;如果在一个package下要导入多个成员，则使用逗号分隔.如: </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> java.util.&#123;<span class="type">ArrayList</span> =&gt; <span class="type">JList</span>, <span class="type">HashMap</span> =&gt; <span class="type">JMap</span>&#125;</span><br><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">JList</span>[<span class="type">Int</span>]</span><br><span class="line">res: java.util.<span class="type">ArrayList</span>[<span class="type">Int</span>] = []</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="class"><span class="keyword">type</span> <span class="title">JStringList</span> </span>= <span class="type">JList</span>[<span class="type">String</span>]</span><br><span class="line">defined <span class="class"><span class="keyword">type</span> <span class="title">alias</span> <span class="title">JStringList</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">new</span> <span class="title">JStringList</span></span></span><br><span class="line"><span class="class"><span class="title">res</span></span>: java.util.<span class="type">ArrayList</span>[<span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">JMap</span>[<span class="type">String</span>, <span class="type">String</span>]</span><br><span class="line">res: java.util.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">String</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">import</span> scala.<span class="type">Option</span>.&#123;empty =&gt; jempty&#125;</span><br><span class="line">scala&gt; jempty</span><br><span class="line">res: <span class="type">Option</span>[<span class="type">Nothing</span>] = <span class="type">None</span></span><br></pre></td></tr></table></figure><h2 id="5-导入package-object的成员"><a href="#5-导入package-object的成员" class="headerlink" title="5 导入package object的成员"></a>5 导入package object的成员</h2><p>  scala中package除了充当命名空间之外，还可以通过package object可定义一些成员，形如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">utils</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">JStringList</span> </span>= java.util.<span class="type">ArrayList</span>[<span class="type">String</span>]</span><br><span class="line">  <span class="keyword">val</span> <span class="type">Msg</span> = <span class="string">"Hello, World"</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">iw</span></span>(target: <span class="type">Int</span>) = <span class="keyword">new</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">times</span></span>(proc: =&gt; <span class="type">Any</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; target) &#123;</span><br><span class="line">  proc</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test.utils._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">tt</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="type">Msg</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">JStringList</span></span><br><span class="line">  <span class="number">10.</span>times(println(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-导入object的成员"><a href="#6-导入object的成员" class="headerlink" title="6 导入object的成员"></a>6 导入object的成员</h2><p>  Scala中是没有Java中类中静态成员的概念，反之，Scala使用object class（对象类型）单例模式</p><p>  <strong>Scala能导入object class的成员，也能导入运行时对象实例的成员</strong>。</p><p>在写spark应用的时候，<code>import spark.implicits._</code>的写法就是这种场景的一种应用，其中spark是SparkSession的对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> scala.<span class="type">Option</span>._</span><br><span class="line">scala&gt; empty</span><br><span class="line">res: <span class="type">Option</span>[<span class="type">Nothing</span>] = <span class="type">None</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">a</span> </span>= <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"itang"</span>, <span class="number">18</span>)</span><br><span class="line">println(<span class="string">"%s's age is %d"</span> format (a.name, a.age))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> a._</span><br><span class="line">println(<span class="string">"%s's age is %d"</span>, name, age) <span class="comment">//output: itang's age is 18</span></span><br></pre></td></tr></table></figure><h2 id="7-import-可以位于表达式的能放的任意位置，而且导入的成员有其“可见”的作用域"><a href="#7-import-可以位于表达式的能放的任意位置，而且导入的成员有其“可见”的作用域" class="headerlink" title="7 import 可以位于表达式的能放的任意位置，而且导入的成员有其“可见”的作用域"></a>7 import 可以位于表达式的能放的任意位置，而且导入的成员有其“可见”的作用域</h2><p>  如一下代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.actors.<span class="type">Actor</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPackagePosScope</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">  println(<span class="string">"Hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//new HashSet[String] ///not found type: HashSet</span></span><br><span class="line">  <span class="keyword">import</span> collection.immutable.<span class="type">HashSet</span></span><br><span class="line">  <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test1</span></span>() &#123;</span><br><span class="line">  <span class="keyword">import</span> java.text.&#123; <span class="type">SimpleDateFormat</span> =&gt; <span class="type">Sdf</span> &#125;</span><br><span class="line">  <span class="keyword">import</span> java.util.<span class="type">Date</span></span><br><span class="line">  <span class="keyword">new</span> <span class="type">Sdf</span>(<span class="string">"yyyy-MM-dd"</span>).format(<span class="keyword">new</span> <span class="type">Date</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//new Sdf("yyyy-MM-dd").format(new Date) //not found type: Sdf</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">import</span> java.util._</span><br><span class="line">  <span class="keyword">val</span> jlist = <span class="keyword">new</span> <span class="type">ArrayList</span>[<span class="type">String</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//val badJlist = new ArrayList[String] // not found type: ArrayList</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>import 使用上像表达式，但它不是表达式也不是函数，它没有返回值，存在于编译时</strong>，如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> some = <span class="keyword">import</span> java.util._</span><br><span class="line"></span><br><span class="line">&lt;console&gt;:<span class="number">1</span>: error: illegal start of simple expression</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> some = <span class="keyword">import</span> java.util._</span><br></pre></td></tr></table></figure><h2 id="8-scala默认已导入的名字空间及成员"><a href="#8-scala默认已导入的名字空间及成员" class="headerlink" title="8 scala默认已导入的名字空间及成员"></a>8 scala默认已导入的名字空间及成员</h2><p> <strong>scala包下成员默认可见</strong></p><p>  相当与每个编译单元里默认<code>import scala._</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Console</span>.println(<span class="string">"hello"</span>) <span class="comment">// scala.Console</span></span><br><span class="line">scala&gt; <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">scala&gt; scala.<span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p> 注意到scala也是一个package object，里面定义了很多不同package的下类型别名，如此可以将众多的类型组织到scala名字空间。</p><p>  <strong>java.lang包下成员默认可见</strong></p><p>  相当与每个编译单元里默认<code>import java.lang._</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Runtime</span>.getRuntime.availableProcessors <span class="comment">// java.lang.Runtime</span></span><br><span class="line">scala&gt; <span class="type">System</span>.getProperty(<span class="string">"user.home"</span>)</span><br></pre></td></tr></table></figure><p>  <strong>scala.Predef 这个object下成员默认可见</strong>（主要定义全局函数，类型别名，隐式转换等等)</p><p>  相当与每个编译单元里默认<code>import scala.Predef._</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; println(<span class="string">"hello"</span>)</span><br><span class="line">scala&gt; scala.<span class="type">Predef</span>.println(<span class="string">"hell"</span>)</span><br><span class="line">scala&gt; <span class="string">"msg"</span> -&gt; <span class="string">"Hello"</span></span><br><span class="line">scala&gt; any2ArrowAssoc(<span class="string">"msg"</span>).-&gt;(<span class="string">"Hello"</span>) <span class="comment">//scala.Predef.any2ArrowAssoc</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala-import" scheme="https://shang.at/tags/Scala-import/"/>
    
  </entry>
  
  <entry>
    <title>Spark学习-Encoder</title>
    <link href="https://shang.at/post/Spark%E5%AD%A6%E4%B9%A0-Encoder/"/>
    <id>https://shang.at/post/Spark学习-Encoder/</id>
    <published>2020-07-29T10:39:29.000Z</published>
    <updated>2020-07-29T10:39:44.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Encoder" scheme="https://shang.at/tags/Encoder/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-String</title>
    <link href="https://shang.at/post/Java%E5%AD%A6%E4%B9%A0-String/"/>
    <id>https://shang.at/post/Java学习-String/</id>
    <published>2020-07-29T10:23:44.000Z</published>
    <updated>2020-07-29T10:28:05.521Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><h2 id="intern方法介绍"><a href="#intern方法介绍" class="headerlink" title="intern方法介绍"></a>intern方法介绍</h2><p>​    Oracle的开发文档上讲解的很详细：String类内部维护一个字符串池(strings pool)，当调用String的intern()方法时，如果字符串池中已经存在该字符串，则直接返回池中字符串引用，如果不存在，则将该字符串添加到池中，并返回该字符串对象的引用。执行过intern()方法的字符串，我们就说这个字符串被拘禁了(interned)。默认情况下，代码中的字符串字面量和字符串常量值都是被拘禁的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 =<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回true</span></span><br><span class="line">System.out.println(s1 == s2.intern());</span><br></pre></td></tr></table></figure><p>​    同值字符串的intern()方法返回的引用都相同，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s2 = new String(&quot;abc&quot;);</span><br><span class="line">String s3 = new String(&quot;abc&quot;);</span><br><span class="line"> </span><br><span class="line">//返回true</span><br><span class="line">System.out.println(s2.intern() == s3.intern());</span><br><span class="line">//返回false</span><br><span class="line">System.out.println(s2 == s3);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA学习" scheme="https://shang.at/categories/JAVA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="String" scheme="https://shang.at/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-函数式编程</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://shang.at/post/Scala学习-函数式编程/</id>
    <published>2020-07-29T08:51:56.000Z</published>
    <updated>2020-07-29T10:03:54.466Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><p>函数的职责是单一的   ——— 这和面向接口的编程模型是一致的</p><p>纯函数：没有副作用的函数</p><p>什么是副作用：从输入到输出的过程中还干了一些额外的事情</p><p>​    修改了某些值、与外部系统发生交互、直接修改数据结构</p><p>函数式编程的好处：</p><p>功能模块化、易测试、易复用、并行化、泛化、推导</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="函数式编程" scheme="https://shang.at/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-编程Tips</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8BTips/"/>
    <id>https://shang.at/post/Scala学习-编程Tips/</id>
    <published>2020-07-27T17:53:33.000Z</published>
    <updated>2020-08-05T08:36:07.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><ol><li><p>和python一样不需要分号，但是如果在一行有多条语句，则需要加分号。如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"hello"</span>; println(s)</span><br></pre></td></tr></table></figure></li><li><p>scala中的Symbol 符号，参考<a href="/post/Java学习-String">java-String-intern</a></p><p>在scala中可以使用<code>&#39;abc</code>这样的形式创建一个Symbol对象，它是使用的<code>Scala&#39;s built-in quote mechanism</code></p><p>Symbol的优点：</p><p><strong>节省内存</strong>：在Scala中，Symbol类型的对象是被拘禁的(interned)，任意的同名symbols都指向同一个Symbol对象，避免了因冗余而造成的内存开销。而对于String类型，只有编译时确定的字符串是被拘禁的(interned)。Scala测试代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="symbol">'aSymbol</span></span><br><span class="line"><span class="comment">//输出true</span></span><br><span class="line">println( s == <span class="symbol">'aSymbol</span>)</span><br><span class="line"><span class="comment">//输出true</span></span><br><span class="line">println( s == <span class="type">Symbol</span>(<span class="string">"aSymbol"</span>))</span><br></pre></td></tr></table></figure><p><strong>快速比较</strong>：由于Symbol类型的对象是被拘禁的(interned)，任意的同名symbols都指向同一个Symbol对象，而不同名的symbols一定指向不同的Symbol对象，所以symbols对象之间可以使用操作符==快速地进行相等性比较，常数时间内便可以完成，而字符串的equals方法需要逐个字符比较两个字符串，执行时间取决于两个字符串的长度，速度很慢。(实际上，String.equals方法会先比较引用是否相同，但是在运行时产生的字符串对象，引用一般是不同的)</p><p>比如：Symbol类型一般用于快速比较，例如用于Map类型：Map<symbol, data>,根据一个Symbol对象，可以快速查询相应的Data, 而Map<string, data>的查询效率则低很多。</string,></symbol,></p><p><strong>相较于String.intern()的优点</strong>：利用String的intern方法也可以实现Map<string, data>的键值快速比较，但是由于需要显式地调用intern()方法，在编码时会造成很多的麻烦，而且如果忘了调用intern()方法，还会造成难以寻找的bug。从这个角度看，Scala的Symbol类型不仅有效率上的提升，而且也简化了编码的复杂度。</string,></p></li><li><p>scala中的<code>self =&gt;</code>写法  <a href="https://blog.csdn.net/beckham1984/article/details/43988521" target="_blank" rel="noopener">其他的一些情况参考</a></p><p>看scala的源码的话很发现很多源码开头都有一句：<code>self =&gt;</code> 。这句相当于给this起了一个别名为self</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkSession</span> <span class="title">private</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    @transient val sparkContext: <span class="type">SparkContext</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private val existingSharedState: <span class="type">Option</span>[<span class="type">SharedState</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private val parentSessionState: <span class="type">Option</span>[<span class="type">SessionState</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private[sql] val extensions: <span class="type">SparkSessionExtensions</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Serializable</span> <span class="keyword">with</span> <span class="title">Closeable</span> <span class="keyword">with</span> <span class="title">Logging</span> </span>&#123; self =&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>作为<code>this</code>关键字的别名，如</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Self</span> </span>&#123;</span><br><span class="line">  self =&gt; <span class="comment">//代表this指针  ，也就是说 self 就 this的别名</span></span><br><span class="line">  <span class="comment">//  anc =&gt;  // 作用与self =&gt; 一样，只不过人们习惯于用self =&gt; 的写法</span></span><br><span class="line">  <span class="keyword">val</span> tmp = <span class="string">"scala"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>: <span class="type">String</span> = self.tmp + <span class="keyword">this</span>.tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  out =&gt;</span><br><span class="line">  <span class="keyword">val</span> v1 = <span class="string">"spark"</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    println(out.v1) <span class="comment">// 用outer表示外部类，相当于Outer.this</span></span><br><span class="line">    v1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自身类型：混入trait，强制要求 S2的实现类 去实现 S1，如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">/**</span></span></span><br><span class="line"><span class="class"> <span class="title">*</span> <span class="title">this</span> <span class="title">不能称当别名，这里this</span></span>:<span class="type">S1</span> 是一个整体，就是说实例化<span class="type">S2</span>时，要求<span class="type">S1</span>必须混入</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">S1</span> =&gt;</span><br><span class="line">&#125; <span class="comment">// 混入trait S1，强制要求 S2的实现类 去实现 S1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S3</span> <span class="keyword">extends</span> <span class="title">S2</span> <span class="keyword">with</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>: <span class="type">S1</span> =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">S4</span> <span class="keyword">extends</span> <span class="title">T</span> <span class="keyword">with</span> <span class="title">S1</span></span></span><br></pre></td></tr></table></figure><p><code>this:S1 =&gt;</code> 要求S2在实例化时或定义S2的子类时，必须混入指定的S1 类型，这个X类型也可以指定为当前类型</p><p>自身类型的存在相当于让当前类变得<code>抽象</code>了，它假设当前对象(this)也符合指定的类型，因为自身类型 <code>this:S1 =&gt;</code>的存在，当前类构造实例时需要同时满足S1类型</p></li><li><p>scala中的<code>=&gt;</code>，<a href="https://stackoverflow.com/questions/6951895/what-does-and-mean-in-scala" target="_blank" rel="noopener">参考资料</a>，<a href="https://docs.scala-lang.org/tour/by-name-parameters.html" target="_blank" rel="noopener">例子来自于这里</a></p><ul><li>In a value, it introduces a function literal, or <em>lambda</em>. e.g. the bit inside the curly braces in <code>List(1,2,3).map { (x: Int) =&gt; x * 2 }</code></li></ul><p>用在函数声明上：连接参数和函数体</p><ul><li><p>In a type, with symbols on both sides of the arrow (e.g. <code>A =&gt; T</code>, <code>(A,B) =&gt; T</code>, <code>(A,B,C) =&gt; T</code>, etc.) it’s sugar for <code>Function&lt;n&gt;[A[,B,...],T]</code>, that is, a function that takes parameters of type <code>A[,B...]</code>, and returns a value of type <code>T</code>.</p><ul><li><p>Empty parens on the left hand side (e.g. <code>() =&gt; T</code>) indicate that the function takes no parameters (also sometimes called a “thunk”);</p></li><li><p>Empty parens on the right hand side denote that it returns <code>()</code>—the sole value of type <code>Unit</code>, whose name can also be written <code>()</code>—confused yet? :)</p><p>A function that returns Unit is also known as a <em>procedure</em>, normally a method that’s called only for its side effect.</p></li></ul></li></ul><p>用在类型声明上：表示类型的转换，一般用来表示函数的签名</p><ul><li>In the type declaration for a method or function parameter, with no symbol on the left hand side (e.g. <code>def f(param: =&gt; T)</code>) it’s a “by-name parameter”, meaning that is evaluated every time it’s used within the body of the function, and not before. Ordinary “by-value” parameters are evaluated before entry into the function/method.</li></ul><p>用在传名参数上：这种用法和其他三种都不一样，比较特殊，讲的是 用<code>=&gt;</code>修饰函数参数时，意味着只有该参数在函数体内第一次被使用时，才会去计算它(lazy initializing)(且每进入一次函数体就会被计算)，也被称为<code>传名参数(by-name parameters)</code>。与之对应的是<code>传值参数(by-value parameters)</code>，传值参数会被立刻计算一次，且只会计算一次。 如下面的例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFuncParameter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">whileLoop</span></span>(condition: =&gt; <span class="type">Boolean</span>)(body: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(condition)</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">      body</span><br><span class="line">      whileLoop(condition)(body)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">    whileLoop(i &gt; <span class="number">0</span>) &#123;  <span class="comment">// body</span></span><br><span class="line">      println(i)</span><br><span class="line">      i -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints </span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>正常情况下会打印上面写到的结果。如果把<code>condition: =&gt; Boolean</code>改成<code>condition: Boolean</code>，则会永远死循环下去，因为condition永远都是true，它只被计算了一次。</p><p>其中<code>(body: =&gt; Unit)</code>必须加<code>=&gt;</code>修饰，这里body指向的是<code>{println(i);i-=1}</code>，它是一个<code>Unit</code>类型的变量，可以理解成它指向了一个代码块，但是他不是一个函数，就是一个变量。再加上<code>=&gt;</code>关键字的修饰，<code>body</code>在<code>whileLoop</code>中<code>第一次遇见body</code>的时候，就会计算它一次(执行一次它所指向的代码块)，所以这里可以看成scala中的一种特殊的语法糖。</p><p>在spark中可以看到这种用法：rdd的几乎所有方法都有<code>withScope</code>这么一个调用，如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">  <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>withScope</code>是这样定义的： <code>body: =&gt; U</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">withScope</span></span>[<span class="type">U</span>](body: =&gt; <span class="type">U</span>): <span class="type">U</span> = <span class="type">RDDOperationScope</span>.withScope[<span class="type">U</span>](sc)(body)</span><br></pre></td></tr></table></figure><p>再来看一下<code>org.apache.spark.rdd.RDDOperationScope#withScope</code>的定义： <code>body: =&gt; T</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">withScope</span></span>[<span class="type">T</span>](</span><br><span class="line">    sc: <span class="type">SparkContext</span>,</span><br><span class="line">    allowNesting: <span class="type">Boolean</span> = <span class="literal">false</span>)(body: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>body: =&gt; Unit</code> 做了如下的测试：</p><p>这的Unit是根据body的具体类型可以推断出来，body指向了一个代码块，这个代码块如果有返回值，那么body就是那个返回的类型，如果没有返回值，那么body就是Unit类型。上面的写法就是没有返回值，下面的写法返回了一个Int类型的值，且这个值可以在函数体内自由使用，=&gt; 则使在函数内第一次调用的时候被计算</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFuncParameter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">whileLoop</span></span>(condition: =&gt; <span class="type">Boolean</span>)(body: =&gt; <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(condition)</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">      <span class="keyword">val</span> tmp: <span class="type">Int</span> = body</span><br><span class="line">      println(<span class="string">"tmp:"</span> + tmp)</span><br><span class="line">      whileLoop(condition)(body)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> i: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    whileLoop(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">      i -= <span class="number">1</span></span><br><span class="line">      i</span><br><span class="line">    &#125; <span class="comment">// prints 2 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// tmp:1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// tmp:0</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>传名参数的优点：</p><p>如果参数是计算密集型或长时间运行的代码块，如获取 URL资源，这种延迟计算参数直到它被使用时才计算的能力可以帮助提高性能。</p><ul><li>In a <code>case</code> clause, they separate the pattern (and optional guard) from the result expression, e.g. <code>case x =&gt; y</code>.</li></ul><p>用在模式匹配上：可以理解成和函数一样的作用，用来连接模式和具体的逻辑块</p><ul><li>除此之外，<code>=&gt;</code>还有一个使用场景：用在类的声明中，用作<code>this别名</code>或者<code>自身类型(self-type)</code>，详情请参考上一条的总结</li></ul></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala编程Tips" scheme="https://shang.at/tags/Scala%E7%BC%96%E7%A8%8BTips/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-9-Iterator设计模式</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-9-Iterator%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shang.at/post/Scala学习-9-Iterator设计模式/</id>
    <published>2020-07-26T08:26:23.000Z</published>
    <updated>2020-07-26T12:40:51.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：Iterator的数据处理模式贯穿了大数据处理流程的始终，是一个非常值得借鉴的设计模式</p></blockquote><a id="more"></a><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>使用scala编写了一段<code>wordcount</code>的代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> listStr = <span class="type">List</span>(</span><br><span class="line">      <span class="string">"hello world"</span>,</span><br><span class="line">      <span class="string">"hello msb"</span>,</span><br><span class="line">      <span class="string">"good idea"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> flatMap: <span class="type">List</span>[<span class="type">String</span>] = listStr.flatMap((x: <span class="type">String</span>) =&gt; x.split(<span class="string">" "</span>))</span><br><span class="line">    flatMap.foreach(println)</span><br><span class="line">    <span class="keyword">val</span> mapList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = flatMap.map((_, <span class="number">1</span>))</span><br><span class="line">    mapList.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下上面程序的执行过程：</p><ol><li>创建listStr对象</li><li>listStr调用flatMap，作用是将listStr的每个元素使用空格分隔，然后<code>合并</code>成一个大的list</li><li>继续调用map，将每个元素<code>转换</code>成一个[String,Int]的二元组</li><li>打印结果</li></ol><p>以上代码有一个致命的问题：在数据量非常的的时候，会急剧的消耗内存空间。为什么？简单分析下：第一步空间复杂度为O(N)，第二步又生成了一个全新的List[String]对象，又是O(N)的空间复杂度，第三步中又生成了一个List[(String,Int)]对象，空间复杂度依然是O(N)。通过分析可知，在数据统计的过程中，貌似并没有必要将中间过程的数据存储下来，不但占用空间，还没有任何用处。</p><p>于是，我们想到了一种设计模式-迭代器模式。迭代器模式在内部维护了一个指针，实际上并不会存储数据，在遍历数据集的时候，不断的消耗当前指针。</p><h3 id="现在开始复习一下迭代器模式"><a href="#现在开始复习一下迭代器模式" class="headerlink" title="现在开始复习一下迭代器模式"></a>现在开始复习一下迭代器模式</h3><p>迭代器一定有两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123; <span class="comment">//Element E //Type T //Key K //Value V</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;  <span class="comment">// 是否还有下一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;  <span class="comment">// 获取下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合类一定有一个返回迭代器的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的集合类实现Collection接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E[] objects = (E[]) <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == objects.length) &#123;</span><br><span class="line">            E[] newObjects = (E[]) <span class="keyword">new</span> Object[objects.length * <span class="number">2</span>];</span><br><span class="line">            System.arraycopy(objects, <span class="number">0</span>, newObjects, <span class="number">0</span>, objects.length);</span><br><span class="line">            objects = newObjects;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[index] = o;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex &gt;= index) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            E o = (E) objects[currentIndex];</span><br><span class="line">            currentIndex++;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，迭代器中不会存数据，只是保存了一个指针，指向当前遍历到了哪一个索引，只有真正开始遍历的时候，指针才会开始移动，并且没有回退的方法，即迭代器只能遍历一次(另有设计的除外)。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用迭代器实现上面的功能</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> listStr = <span class="type">List</span>(</span><br><span class="line">      <span class="string">"hello world"</span>,</span><br><span class="line">      <span class="string">"hello msb"</span>,</span><br><span class="line">      <span class="string">"good idea"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> iter: <span class="type">Iterator</span>[<span class="type">String</span>] = listStr.iterator <span class="comment">//什么是迭代器，为什么会有迭代器模式？  迭代器里不存数据！</span></span><br><span class="line">    <span class="keyword">val</span> iterFlatMap = iter.flatMap((x: <span class="type">String</span>) =&gt; x.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="comment">//    iterFlatMap.foreach(println)  // 中途不能打印，否则后续就读取不到数据了</span></span><br><span class="line">    <span class="keyword">val</span> iterMapList = iterFlatMap.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">while</span> (iterMapList.hasNext) &#123;</span><br><span class="line">      <span class="keyword">val</span> tuple: (<span class="type">String</span>, <span class="type">Int</span>) = iterMapList.next()</span><br><span class="line">      println(tuple)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.listStr真正的数据集，有数据的</span></span><br><span class="line">    <span class="comment">//2.iter.flatMap  没有发生计算，返回了一个新的迭代器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：基于迭代器的方案中，除了listStr中存储了数据，中间的过程中只有计算逻辑没有存储数据(faltMap会有一点少少的数据缓冲存储)。这和spark中的算子的思想一样啊，也可以说spark是借鉴了迭代器的编程模式。</p><ul><li>Spark的transformation算子：类比这里的flatMap/map</li><li>Spark的action算子：类比这里的foreach</li></ul><p>关于scala中flatMap、map、foreach的过程分析</p><p><img src="../../images/scala_iterator.jpg" alt="scala_iterator源码分析图"></p><ol><li><p>iter = listStr.iterator</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>: <span class="type">Iterator</span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">AbstractIterator</span>[<span class="type">A</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> these = self</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = !these.isEmpty</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">A</span> =</span><br><span class="line">    <span class="keyword">if</span> (hasNext) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = these.head; these = these.tail; result</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="type">Iterator</span>.empty.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterator返回的是一个AbstractIterator对象，重写了hasNext和next函数：</p><ul><li>hasNext：调用listStr的isEmpty方法，如果为空则返回false</li><li>next：<ul><li>先检测是否有元素，有的话返回listStr的头结点，并且移动these到剩余部分的头部；</li><li>否则返回空。按理说不会为空，因为都是先判断了hasNext为true才会调用next</li></ul></li></ul></li><li><p>iterFlatMap = iter.flatMap((x:String) =&gt; x.split(“ “))</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">GenTraversableOnce</span>[<span class="type">B</span>]): <span class="type">Iterator</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">AbstractIterator</span>[<span class="type">B</span>] &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> cur: <span class="type">Iterator</span>[<span class="type">B</span>] = empty</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">nextCur</span></span>() &#123; cur = f(self.next()).toIterator &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="comment">// Equivalent to cur.hasNext || self.hasNext &amp;&amp; &#123; nextCur(); hasNext &#125;</span></span><br><span class="line">    <span class="comment">// but slightly shorter bytecode (better JVM inlining!)</span></span><br><span class="line">    <span class="keyword">while</span> (!cur.hasNext) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!self.hasNext) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      nextCur()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">B</span> = (<span class="keyword">if</span> (hasNext) cur <span class="keyword">else</span> empty).next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flatMap返回的也是一个AbstractIterator，也重写了hasNext和next函数：</p><ul><li><p>它在这里维护了一个cur的小迭代器，之所以说小，是因为它会缓存上一个调用节点的一条记录经过f处理之后的结果</p></li><li><p>hasNext：<strong>重点看这个函数</strong></p><ul><li>这里会先判断cur是否有元素，有的话直接返回true；</li><li>否则的话，调用父类的hasNext，判断是否还有值，没有的话，返回false；</li><li>否则的话调用父类的next获取一条新的记录，并交给处理函数f处理，处理完之后交给cur缓存起来</li></ul></li><li>next：如果有值，则直接从cur中取值，而且永远都只从cur中取值</li></ul></li><li><p>iterMapList = iterFlatMap.map((_, 1))</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Iterator</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">AbstractIterator</span>[<span class="type">B</span>] &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span> </span>= self.hasNext</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>() = f(self.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map返回的也是一个AbstractIterator，也重写了hasNext和next函数，不过他这里的逻辑比较简单了，因为map只是完成了一个映射的过程</p></li><li><p>iterMapList.foreach(println)</p><p>打印收工。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：Iterator的数据处理模式贯穿了大数据处理流程的始终，是一个非常值得借鉴的设计模式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala-Iterator设计模式" scheme="https://shang.at/tags/Scala-Iterator%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-隐式转换</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-8-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>https://shang.at/post/Scala学习-8-隐式转换/</id>
    <published>2020-07-26T08:21:03.000Z</published>
    <updated>2020-07-26T11:30:50.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：一个从类型 <code>S</code> 到类型 <code>T</code> 的隐式转换由一个函数类型 <code>S =&gt; T</code> 的隐式值来定义，或者由一个可转换成所需值的隐式方法来定义。</p><p>隐式转换是scala中一个非常重要的特性，但同时也是挺难理解的一个特性。</p><p>隐式转换使用不当将会导致很难检查的bug</p></blockquote><a id="more"></a><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>例如在scala项目使用创建了一个LinkedList对象，我们想要对该对象调用foreach方法，但是却发现调用的时候会报错，没有该方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">LinkedList</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">    list.foreach(println)  <span class="comment">// 这里会报：Cannot resolve symbol foreach</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们应该怎么办呢？实际上我们可以有以下几种解决方案 不需要修改LinkedList的源代码(也修改不了)</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>分析一下<code>list.foreach(println)</code>，发现这一句中包含了三个内容：数据集list、遍历行为foreach、处理函数println，那么我们只需要通过某种方案将这三个元素组装好就可以了</p><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>定义一个foreach函数帮助完成遍历</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">LinkedList</span>[<span class="type">Int</span>]()</span><br><span class="line">    list.add(<span class="number">3</span>)</span><br><span class="line">    list.add(<span class="number">4</span>)</span><br><span class="line">    list.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    list.foreach(println)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">T</span>](list: util.<span class="type">LinkedList</span>[<span class="type">T</span>], f: (<span class="type">T</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> iter: util.<span class="type">Iterator</span>[<span class="type">T</span>] = list.iterator()</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext) f(iter.next())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foreach(list, println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>通过方案一看似可以满足我们的需求，但是我们不想通过把list当做foreach的参数来完成遍历，我们就想通过调用<code>obj.foreach</code>的形式来完成这个操作。那么我们可以通过定义一个class来包装下list对象，即在新定义的class中提供foreach的方法调用，然后有一个list的属性，那么就可以这样做</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span>[<span class="type">T</span>](<span class="params">list: util.<span class="type">LinkedList</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: (<span class="type">T</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> iter: util.<span class="type">Iterator</span>[<span class="type">T</span>] = list.iterator()</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext) f(iter.next())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">LinkedList</span>[<span class="type">Int</span>]()</span><br><span class="line">    list.add(<span class="number">3</span>)</span><br><span class="line">    list.add(<span class="number">4</span>)</span><br><span class="line">    list.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> xx = <span class="keyword">new</span> <span class="type">XXX</span>(list)</span><br><span class="line">    xx.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>方案二中通过一个新的class做到了类似<code>obj.foreach</code>的调用形式，但是我们还不满足，我们不想用其他的对象来调用foreach，就是想直接<code>list.foreach</code>，用list对象本身直接调用，那该怎么办呢？首先在原始的LinkedList类中是没有foreach方法的，我们又不能去修改LinkedList的源码。实际上在scala中为我们提供了一种更加方便快捷的方案，可以在不侵入源码的情况下，给一个对象赋予新的方法。那就是<code>隐式转换(implicit)</code>，实际上scala中的隐式转换在某种程度上与我们上面的两种方案有异曲同工之妙，但是它在编译器层面做了优化，是语言层面的支持，即我们可以通过<code>implicit</code>关键字直接告诉编译器：<strong>我这个对象不存在当前我要调用的方法，但是我有在其他地方定义了一个方法转换，可以让我拥有这个方法</strong>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">LinkedList</span>[<span class="type">Int</span>]()</span><br><span class="line">    list.add(<span class="number">3</span>)</span><br><span class="line">    list.add(<span class="number">4</span>)</span><br><span class="line">    list.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式转换：  隐式转换方法:接受一个类型，返回另外一个包含特定方法的类型</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">sdfsdf</span></span>[<span class="type">T</span>](list: util.<span class="type">LinkedList</span>[<span class="type">T</span>]) = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">XXX</span>(list)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span>[<span class="type">T</span>](<span class="params">list: util.<span class="type">LinkedList</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: (<span class="type">T</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> iter: util.<span class="type">Iterator</span>[<span class="type">T</span>] = list.iterator()</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext) f(iter.next())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以发现我们使用了一个新的关键字<code>implicit</code>，它修饰了一个函数，并且我们新创建的这个函数，它的名字很特殊，只是一个乱写的字符串，也许你可以猜出来了，这个函数的名字对我们来说没有用处，对的在scala中的隐式转换只关心类型，并不关心名称。但是在实际应用中一定不要如此随便的命名，这里只是做演示。</p><p>implicit关键字如注释中说的那样：<strong>接受一个类型，返回另一个包含特定方法的类型</strong>，但是我们不需要使用新的类型对象来调用foreach，这是因为scala在编译的阶段帮我们做了<em>改写</em>，其执行过程大致如下：</p><ol><li>scala编译器发现list对象并没有foreach方法 但是并不会立马报错</li><li>它回去寻找有没有implicit定义的方法，且方法的参数正好是list对象对应的类型</li><li>如果找到了，那么就可以编译通过；否则就会报错</li></ol><p>总而言之，scala编译器帮助我们完成了list类型的转换，也可以理解成编译器帮我们把代码改写了，但是这一步骤是我们所看不到，所以说是<code>隐式的</code>(个人这么理解)</p><p>方案三介绍的只是scala的一种隐式转换：<strong>隐式转换方法</strong></p><p>除此之外，scala中还有其他隐式转换形式：<strong>隐式转换类</strong>、<strong>隐式转换参数</strong></p><h4 id="隐式转换类"><a href="#隐式转换类" class="headerlink" title="隐式转换类"></a>隐式转换类</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//隐式转换类</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">KKK</span>[<span class="type">T</span>](<span class="params">list: util.<span class="type">LinkedList</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: (<span class="type">T</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> iter: util.<span class="type">Iterator</span>[<span class="type">T</span>] = list.iterator()</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext) f(iter.next())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">LinkedList</span>[<span class="type">Int</span>]()</span><br><span class="line">    list.add(<span class="number">3</span>)</span><br><span class="line">    list.add(<span class="number">4</span>)</span><br><span class="line">    list.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    list.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里需要注意的是：<code>implicit</code>只能用在类内部或者函数内部，<font color="red">不能使用在top-level的objects上</font>。否则会报如下的错误<code>&#39;implicit&#39; modifier cannot be used for top-level objects</code></p></blockquote><h4 id="隐式转换参数"><a href="#隐式转换参数" class="headerlink" title="隐式转换参数"></a>隐式转换参数</h4><p>最后这一种隐式转换的形式实际上对这个例子没有作用，他是在另外一些使用场景有使用</p><p>方法可以具有 <em>隐式</em> 参数列表，由参数列表开头的 <em>implicit</em> 关键字标记。 如果参数列表中的参数没有像往常一样传递， Scala 将查看它是否可以获得正确类型的隐式值，如果可以，则自动传递。</p><p>implicit如果出现在函数的参数列表中，如<code>def func(implicit name:String)</code>，那么表示在调用func函数的时候，name参数可以不传，也可以传。传与不传的区别如下：</p><ul><li>传：那么直接使用传递的参数，和普通的函数没有任何区别</li><li>不传：这种情况下，必须存在一个隐式的String类型的变量被声明，否则会编译报错</li></ul><p>使用方式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">"lisi"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span></span>(<span class="keyword">implicit</span> name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func   <span class="comment">// 打印 lisi</span></span><br><span class="line">    func(<span class="string">"zhangsan"</span>)  <span class="comment">// 打印 zhangsan</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式转换参数使用的时候需要注意以下几点</p><ol><li><p>如果参数列表中有implicit，那么所有的参数要么都传要么都定义隐式转换变量</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span></span>(<span class="keyword">implicit</span> name: <span class="type">String</span>, age: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同一种类型的隐私转换变量只能定义一个，否则会报错</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> a:<span class="type">String</span> = <span class="string">"wangwu"</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> b:<span class="type">String</span> = <span class="string">"lisi"</span></span><br></pre></td></tr></table></figure></li><li><p>如果有些参数有隐式转换变量定义，但是其他的参数不需要定义，该如何解决呢？</p><p>解决方案：使用scala的<code>函数柯里化(CURRYING)</code>特性</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span></span>(age: <span class="type">Int</span>)(<span class="keyword">implicit</span> name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(name + <span class="string">" "</span> + age)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">66</span>)(<span class="string">"jkljkl"</span>)</span><br><span class="line">func(<span class="number">66</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="隐式转换的作用域"><a href="#隐式转换的作用域" class="headerlink" title="隐式转换的作用域"></a>隐式转换的作用域</h4><p><a href="https://stackoverflow.com/questions/5512397/passing-scala-math-integral-as-implicit-parameter" target="_blank" rel="noopener">StackOverFlow</a></p><p>隐式转换本身是一种代码查找机制，所以下面会介绍隐式转换的查找范围：<br> -当前代码作用域。最直接的就是隐式定义和当前代码处在同一作用域中。<br> -当第一种解析方式没有找到合适的隐式转换时，编译器会继续在隐式参数类型的隐式作用域里查找。一个类型的隐式作用域指的是与该类型相关联的所有的伴生对象。</p><p><strong>对于一个类型T它的隐式搜索区域包括如下：</strong><br> -假如T是这样定义的：T with A with B with C，那么A, B, C的伴生对象都是T的搜索区域。<br> -如果T是类型参数，那么参数类型和基础类型都是T的搜索部分。比如对于类型List[Foo]，List和Foo都是搜索区域<br> -如果T是一个单例类型p.T，那么p和T都是搜索区域。<br> -如果T是类型注入p#T，那么p和T都是搜索区域。</p><p>所以，只要在上述的任何一个区域中搜索到合适的隐式转换，编译器都可以使编译通过。</p><h4 id="scala中预定义的隐式转换"><a href="#scala中预定义的隐式转换" class="headerlink" title="scala中预定义的隐式转换"></a>scala中预定义的隐式转换</h4><p>scala.Predef：scala的预定义对象，预定义了很多类型 (例如 <code>Pair</code>) 和方法 (例如 <code>assert</code>)，同时也声明了一些隐式转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：一个从类型 &lt;code&gt;S&lt;/code&gt; 到类型 &lt;code&gt;T&lt;/code&gt; 的隐式转换由一个函数类型 &lt;code&gt;S =&amp;gt; T&lt;/code&gt; 的隐式值来定义，或者由一个可转换成所需值的隐式方法来定义。&lt;/p&gt;
&lt;p&gt;隐式转换是scala中一个非常重要的特性，但同时也是挺难理解的一个特性。&lt;/p&gt;
&lt;p&gt;隐式转换使用不当将会导致很难检查的bug&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala隐式转换" scheme="https://shang.at/tags/Scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-偏函数</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-7-%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    <id>https://shang.at/post/Scala学习-7-偏函数/</id>
    <published>2020-07-26T08:20:55.000Z</published>
    <updated>2020-07-26T12:53:35.668Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestPartialFunction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xxx</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"hello"</span> =&gt; <span class="string">"val is hello"</span></span><br><span class="line">      <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; <span class="string">s"<span class="subst">$x</span>...is int"</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">"none"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> str: <span class="type">String</span> = xxx(<span class="number">44</span>)</span><br><span class="line">    println(str)</span><br><span class="line">    println(xxx(<span class="string">"hello"</span>))</span><br><span class="line">    println(xxx(<span class="string">"hi"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala偏函数" scheme="https://shang.at/tags/Scala%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-模式匹配</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-6-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>https://shang.at/post/Scala学习-6-模式匹配/</id>
    <published>2020-07-26T08:20:13.000Z</published>
    <updated>2020-07-26T12:55:03.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：scala的模式匹配功能非常强大，可以支持值匹配，类型匹配等</p></blockquote><a id="more"></a><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Lesson06_match</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tup: (<span class="type">Double</span>, <span class="type">Int</span>, <span class="type">String</span>, <span class="type">Boolean</span>, <span class="type">Int</span>) = (<span class="number">1.0</span>, <span class="number">88</span>, <span class="string">"abc"</span>, <span class="literal">false</span>, <span class="number">44</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> iter: <span class="type">Iterator</span>[<span class="type">Any</span>] = tup.productIterator</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> res: <span class="type">Iterator</span>[<span class="type">Unit</span>] = iter.map(</span><br><span class="line">      (x) =&gt; &#123;</span><br><span class="line">        x <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> =&gt; println(<span class="string">s"<span class="subst">$x</span>...is 1"</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="number">88</span> =&gt; println(<span class="string">s"<span class="subst">$x</span> ...is 88"</span>)</span><br><span class="line">          <span class="keyword">case</span> <span class="literal">false</span> =&gt; println(<span class="string">s"<span class="subst">$x</span>...is false"</span>)</span><br><span class="line">          <span class="keyword">case</span> w: <span class="type">Int</span> <span class="keyword">if</span> w &gt; <span class="number">50</span> =&gt; println(<span class="string">s"<span class="subst">$w</span>...is  &gt; 50"</span>)</span><br><span class="line">          <span class="keyword">case</span> _ =&gt; println(<span class="string">"wo ye bu zhi dao sha lei xing "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">while</span> (res.hasNext) println(res.next())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：scala的模式匹配功能非常强大，可以支持值匹配，类型匹配等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala模式匹配" scheme="https://shang.at/tags/Scala%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-案例类</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-5-%E6%A1%88%E4%BE%8B%E7%B1%BB/"/>
    <id>https://shang.at/post/Scala学习-5-案例类/</id>
    <published>2020-07-26T08:19:58.000Z</published>
    <updated>2020-07-26T13:02:56.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：</p></blockquote><a id="more"></a><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">name:<span class="type">String</span>,age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestCaseClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> dog1 =  <span class="type">Dog</span>(<span class="string">"hsq"</span>,<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">val</span> dog2 =  <span class="type">Dog</span>(<span class="string">"hsq"</span>,<span class="number">18</span>)</span><br><span class="line">    println(dog1.equals(dog2))</span><br><span class="line">    println(dog1 == dog2)</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">val</span> dog3: <span class="type">Dog</span> = dog2.copy(age=<span class="number">10</span>)</span><br><span class="line">    println(dog3)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>case class感觉上类似于tuple，默认情况下：属性都是public的val的，但是case class可以将val改成var</li><li>case class构造的时候不需要使用new关键字也可以，因为case class有一个默认的<code>apply</code>方法来负责对象的创建。</li><li><p>case class在比较的时候是按值比较而非按引用比较：在消息传递的时候非常有用，不关心引用，只关心值</p></li><li><p>可以通过<code>copy</code>方法创建一个案例类实例的浅拷贝，同时可以指定构造参数来做一些改变。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala案例类" scheme="https://shang.at/tags/Scala%E6%A1%88%E4%BE%8B%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Scala学习-特质和抽象类型</title>
    <link href="https://shang.at/post/Scala%E5%AD%A6%E4%B9%A0-4-%E7%89%B9%E8%B4%A8%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shang.at/post/Scala学习-4-特质和抽象类型/</id>
    <published>2020-07-26T08:19:37.000Z</published>
    <updated>2020-07-26T13:12:05.008Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：特质 (Traits) 用于在类 (Class)之间共享程序接口 (Interface)和字段 (Fields)。 它们类似于Java 8的接口。 类和对象 (Objects)可以扩展特质，但是特质不能被实例化，因此特质没有参数。</p></blockquote><a id="more"></a><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span>  <span class="title">God</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">"god...say"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Mg</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ku</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">"mg...say"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">haiRen</span></span>():<span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span></span>)  <span class="keyword">extends</span>   <span class="title">God</span> <span class="keyword">with</span> <span class="title">Mg</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">s"<span class="subst">$name</span> say hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">haiRen</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"ziji shixian ...."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Lesson04_trait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"zhangsan"</span>)</span><br><span class="line">    p.hello()</span><br><span class="line">    p.say()</span><br><span class="line">    p.ku()</span><br><span class="line">    p.haiRen()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trait就类似于java8中的接口，特性和接口的性质相似</p><ol><li>一次继承多次实现：只能继承一个父类，但是可以实现多个trait，使用关键字extends(和java中不同)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简介：特质 (Traits) 用于在类 (Class)之间共享程序接口 (Interface)和字段 (Fields)。 它们类似于Java 8的接口。 类和对象 (Objects)可以扩展特质，但是特质不能被实例化，因此特质没有参数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Scala学习" scheme="https://shang.at/categories/Scala%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Scala特质和抽象类型" scheme="https://shang.at/tags/Scala%E7%89%B9%E8%B4%A8%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
