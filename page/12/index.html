<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shang.at","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="努力，奋斗">
<meta property="og:url" content="https://shang.at/page/12/index.html">
<meta property="og:site_name" content="努力，奋斗">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="努力，奋斗">

<link rel="canonical" href="https://shang.at/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>努力，奋斗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">努力，奋斗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/BI工具使用之Tableau一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/BI工具使用之Tableau一/" class="post-title-link" itemprop="url">BI工具使用之Tableau一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-11 15:08:39" itemprop="dateCreated datePublished" datetime="2019-04-11T15:08:39+08:00">2019-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-12 08:22:00" itemprop="dateModified" datetime="2019-05-12T08:22:00+08:00">2019-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BI/" itemprop="url" rel="index"><span itemprop="name">BI</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/Spark学习笔记-DSL语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Spark学习笔记-DSL语法/" class="post-title-link" itemprop="url">Spark学习笔记-DSL语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-31 10:20:06" itemprop="dateCreated datePublished" datetime="2019-03-31T10:20:06+08:00">2019-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-01 17:10:14" itemprop="dateModified" datetime="2020-07-01T17:10:14+08:00">2020-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spark学习/" itemprop="url" rel="index"><span itemprop="name">Spark学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/数据结构与算法学习笔记-排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/数据结构与算法学习笔记-排序算法/" class="post-title-link" itemprop="url">数据结构与算法学习笔记-排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-29 08:49:58" itemprop="dateCreated datePublished" datetime="2019-03-29T08:49:58+08:00">2019-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-30 01:51:40" itemprop="dateModified" datetime="2020-06-30T01:51:40+08:00">2020-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h3><p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ul>
<p><img src="/images/排序算法1.png" alt="排序算法1"></p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><img src="/images/排序算法.png" alt="排序算法"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</li>
</ul>
<p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O($n^2$)"></a>O($n^2$)</h3><h4 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否符合大小关系要求。如果不满足就互换位置。一次冒泡至少会让一个元素移动到它应该在的位置，重复n次，就完成了n个元素的排序工作。</p>
<p><img src="/images/冒泡.png" alt="冒泡"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序：从小到大</span></span><br><span class="line"><span class="string">    :param nums:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums) - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + i]:</span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>]</span><br><span class="line">    print(bubble_sort(nums))</span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>将一个元素插入一个已经有序的序列，使其依然有序。首先，将原始的序列分为两个子序列，有序的和无序的，然后，从无序的序列中依次拿出一个元素，插入到有序的序列的合适位置，并保持有序的序列依然有序，直到无序的序列中没有元素了。</p>
<p><img src="/images/插入排序.png" alt="插入排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):  <span class="comment"># 遍历无序数组的每一个元素</span></span><br><span class="line">        tmp = nums[i]  <span class="comment"># 待插入元素</span></span><br><span class="line">        j = i - <span class="number">1</span>  <span class="comment"># 待插入子数组</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 从后往前遍历待插入子数组</span></span><br><span class="line">            <span class="keyword">if</span> tmp &gt;= nums[j]: <span class="keyword">break</span>  <span class="comment"># tmp大于等于当前元素，停止遍历   </span></span><br><span class="line">                					<span class="comment"># 相等元素不会改变其相对位置，故是稳定的</span></span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  <span class="comment"># 将nums[j]后移1个位置</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = tmp  <span class="comment"># 插入待插入元素 tmp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(insert_sort(nums))</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>选择排序是选择无序序列中的最小的元素放到有序序列的末尾，直到无序序列没有元素。</p>
<p><img src="/images/选择排序.png" alt="插入排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):  <span class="comment"># 遍历无序数组的每一个元素</span></span><br><span class="line">        <span class="comment"># i和nums[i]</span></span><br><span class="line">        min_val = nums[i] </span><br><span class="line">        min_j = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):  <span class="comment"># 寻找剩余待排数组的最小元素</span></span><br><span class="line">            <span class="keyword">if</span> min_val &gt; nums[j]:</span><br><span class="line">                min_val = nums[j]</span><br><span class="line">                min_j = j</span><br><span class="line">        nums[i], nums[min_j] = nums[min_j], nums[i]  <span class="comment"># 交换最小元素和</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(selection_sort(nums))</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">希尔排序是对插入排序的优化。</span><br><span class="line">希尔排序，通过将原始序列按照一定的步长划分为多个子序列</span><br><span class="line">	将原始的一维数组映射成二维数组，</span><br><span class="line">	然后按列进行插入排序，</span><br><span class="line">这样的话，可以让一个元素在一次比较中跨越较大的区间，随后算法在使用较小的步长，一直到步长为1</span><br><span class="line">(已知当对有序度较高数组进行排序时，插入排序的时间复杂度接近O(N)，因此可以大幅度提高插入排序的效率)。</span><br></pre></td></tr></table></figure>
<p><img src="/images/希尔排序.png" alt="希尔排序"></p>
<blockquote>
<p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F</a></p>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        print(gap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># 每个步长进行插入排序</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> list[j - gap] &gt; temp:</span><br><span class="line">                list[j] = list[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">                print(<span class="string">'inner='</span>, list)</span><br><span class="line">            list[j] = temp</span><br><span class="line">        print(list)</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort1</span><span class="params">(collection)</span>:</span></span><br><span class="line">    <span class="comment"># Marcin Ciura's gap sequence</span></span><br><span class="line">    gaps = [<span class="number">701</span>, <span class="number">301</span>, <span class="number">132</span>, <span class="number">57</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gap <span class="keyword">in</span> gaps:</span><br><span class="line">        i = gap</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(collection):</span><br><span class="line">            temp = collection[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> collection[j - gap] &gt; temp:</span><br><span class="line">                collection[j] = collection[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            collection[j] = temp</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> collection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(<span class="string">'\n'</span>, shell_sort1(nums))</span><br></pre></td></tr></table></figure>
<h3 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O($nlogn$)"></a>O($nlogn$)</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>将数组分为两部分，分别排序，最后将两部分排好序的数组合并成一个有序的数组。利用递归的方式，重复上述过程。</p>
<p>归并排序为什么会高效：<strong><code>合并两个有序数组的时间复杂度是O(N)的</code></strong>，将一个完整的数组递归的一分为二，那么分解到数组中只有一个元素时，分解的次数为logn，故整体的时间复杂度为O(nlogn)。</p>
<p><img src="/images/归并排序.png" alt="归并排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    print(<span class="string">'before='</span>, nums)</span><br><span class="line">    length = len(nums)</span><br><span class="line">    <span class="keyword">if</span> length &gt; <span class="number">1</span>:</span><br><span class="line">        midpoint = length // <span class="number">2</span></span><br><span class="line">        left_half = merge_sort(nums[:midpoint])</span><br><span class="line">        right_half = merge_sort(nums[midpoint:])</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        left_length = len(left_half)</span><br><span class="line">        right_length = len(right_half)</span><br><span class="line">        <span class="keyword">while</span> i &lt; left_length <span class="keyword">and</span> j &lt; right_length:</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</span><br><span class="line">                nums[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; left_length:</span><br><span class="line">            nums[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; right_length:</span><br><span class="line">            nums[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'after='</span>, nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(<span class="string">'\n'</span>, merge_sort(nums))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>  <span class="comment"># 二分</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 排列左半部分</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 排列右半部分</span></span><br><span class="line">    merge(nums, left, mid, right)  <span class="comment"># 合并左右两个已经有序的数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, left, mid, right)</span>:</span></span><br><span class="line">    tmp = [<span class="number">0</span>] * (right - left + <span class="number">1</span>)</span><br><span class="line">    i, j, k = left, mid + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[j]: tmp[k], i = nums[i], i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: tmp[k], j = nums[j], j + <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid: tmp[k], k, i = nums[i], k + <span class="number">1</span>, i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right: tmp[k], k, j = nums[j], k + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">    nums[left:right+<span class="number">1</span>] = tmp[:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">merge_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>  <span class="comment"># 二分</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 排列左半部分</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 排列右半部分</span></span><br><span class="line">    merge(nums, left, mid, right)  <span class="comment"># 合并左右两个已经有序的数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, left, mid, right)</span>:</span></span><br><span class="line">    tmp = []</span><br><span class="line">    i, j = left, mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[j]:</span><br><span class="line">            tmp.append(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(nums[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    tmp.extend(nums[i:mid + <span class="number">1</span>] <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> nums[j:right + <span class="number">1</span>])</span><br><span class="line">    nums[left:right + <span class="number">1</span>] = tmp[:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">-23</span>, <span class="number">88</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">99</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">merge_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>; <span class="comment">// (left + right) / 2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array, left, mid);</span><br><span class="line">    mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(array, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">// 中间数组</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)   temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; temp.length; p++) &#123;</span><br><span class="line">        arr[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也可以用 System.arraycopy(a, start1, b, start2, length)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">// 中间数组</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i&lt;=mid) System.arraycopy(arr, i, temp, k, mid-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (j&lt;=right) System.arraycopy(arr, j, temp, k, right-j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	System.arraycopy(temp, <span class="number">0</span>, arr, left, temp.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>随机选择一个pivot节点，然后将数组中的数据分成大于pivot和小于pivot的两部分，然后递归地将大于pivot和小于pivot的部分再按照相同的思路处理，直到每个pivot两端的部分都只有最多一个元素</p>
<p><img src="/images/快排.png" alt="快排"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(collection)</span>:</span></span><br><span class="line">    length = len(collection)</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> collection</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = collection[<span class="number">0</span>]</span><br><span class="line">        greater = [element <span class="keyword">for</span> element <span class="keyword">in</span> collection[<span class="number">1</span>:] <span class="keyword">if</span> element &gt; pivot]</span><br><span class="line">        lesser = [element <span class="keyword">for</span> element <span class="keyword">in</span> collection[<span class="number">1</span>:] <span class="keyword">if</span> element &lt;= pivot]</span><br><span class="line">        <span class="keyword">return</span> quick_sort(lesser) + [pivot] + quick_sort(greater)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>O(n) 时间复杂度内求无序数组中的第 K 大元素</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择数组的最后一个元素，作为pivot，然后将数组的所有元素分为大于pivot和小于pivot的两部分，</span></span><br><span class="line"><span class="comment"># 如果 len(lesser) == k - 1，则返回pivot</span></span><br><span class="line"><span class="comment"># 如果 len(lesser) &gt;= k，则说明要查找的元素在小于pivot的部分，那么继续在lesser中查找</span></span><br><span class="line"><span class="comment"># 否则的话，说明要查找的元素在大于pivot的部分，那么继续在greater中查找</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_k_max</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">    length = len(nums)</span><br><span class="line">    <span class="keyword">if</span> length &lt; k:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    pivot = nums[length - <span class="number">1</span>]</span><br><span class="line">    greater = [element <span class="keyword">for</span> element <span class="keyword">in</span> nums[:length - <span class="number">1</span>] <span class="keyword">if</span> element &gt; pivot]</span><br><span class="line">    lesser = [element <span class="keyword">for</span> element <span class="keyword">in</span> nums[:length - <span class="number">1</span>] <span class="keyword">if</span> element &lt;= pivot]</span><br><span class="line">    <span class="keyword">if</span> len(lesser) == k - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> pivot</span><br><span class="line">    <span class="keyword">elif</span> len(lesser) &gt;= k:</span><br><span class="line">        <span class="keyword">return</span> find_k_max(lesser, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> find_k_max(greater, k - len(lesser) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In-place算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums, begin, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> begin&gt;=end: <span class="keyword">return</span></span><br><span class="line">    pivot = partition(nums, begin, end)  <span class="comment"># 找到[begin,end]的pivot点，pivot点已经固定了，是不需要对它进行排序的</span></span><br><span class="line">    quick_sort(nums, begin, pivot<span class="number">-1</span>)  <span class="comment"># 递归调用nums[begin, pivot-1]</span></span><br><span class="line">    quick_sort(nums, pivot+<span class="number">1</span>, end)  <span class="comment"># 递归调用nums[pivot+1, end]</span></span><br><span class="line">   	<span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, begin, end)</span>:</span></span><br><span class="line">    <span class="comment"># pivot是作为对比的值</span></span><br><span class="line">    <span class="comment"># last_smaller是指向小于pivot的子数组的下一个位置的指针   类似于leetcode [移动零] 那一题的解法</span></span><br><span class="line">    pivot, last_smaller = end, begin</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, end): <span class="comment"># 从前往后遍历待排数组</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]&lt;nums[pivot]: <span class="comment"># 如果当前元素小于pivot，那么调换当前元素和last_smaller位置的元素</span></span><br><span class="line">            nums[i], nums[last_smaller] = nums[last_smaller], nums[i]</span><br><span class="line">            last_smaller+=<span class="number">1</span>  <span class="comment"># last_smaller 向后移动一位</span></span><br><span class="line">    <span class="comment"># 把pivot的值移动到last_smaller位置</span></span><br><span class="line">    nums[last_smaller], nums[pivot] = nums[pivot], nums[last_smaller]</span><br><span class="line">    <span class="keyword">return</span> last_smaller</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">nums = []</span><br><span class="line">quick_sort(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= begin) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(array, begin, end);</span><br><span class="line">    quickSort(array, begin, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置</span></span><br><span class="line">    <span class="comment">// last_smaller是指向小于pivot的子数组的下一个位置的指针   类似于leetcode [移动零] 那一题的解法</span></span><br><span class="line">    <span class="keyword">int</span> pivot = end, last_smaller = begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[pivot]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[last_smaller]; a[last_smaller] = a[i]; a[i] = temp;</span><br><span class="line">            last_smaller++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = a[pivot]; a[pivot] = a[last_smaller]; a[last_smaller] = temp;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>使用大顶堆和小顶堆的数据结构，进行排序：大顶堆，每次取堆顶元素，遍历完则得到从大到小的序列；小顶堆则相反。</p>
<p>堆有很多种实现，这里只看二叉堆。二叉堆是一种近似完全二叉树，所以可以使用数组存储，每个父亲节点都要比其孩子节点大(大顶堆，小顶堆相反)</p>
<p>利用堆进行排序，包含两个步骤：第一、将数据放入堆中以满足堆的条件；第二、将数据从堆中取出。即为有序数组</p>
<p><img src="/images/堆排序.png" alt="堆排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(parent_index, length, nums)</span>:</span></span><br><span class="line">    temp = nums[parent_index]</span><br><span class="line">    child_index = <span class="number">2</span>*parent_index+<span class="number">1</span> <span class="comment"># 取到左孩子</span></span><br><span class="line">    <span class="keyword">while</span> child_index &lt; length: </span><br><span class="line">        <span class="comment"># 先检查右孩子，看右孩子是不是比左孩子大，是的话更新孩子节点索引到 右孩子</span></span><br><span class="line">        <span class="keyword">if</span> child_index+<span class="number">1</span> &lt; length <span class="keyword">and</span> nums[child_index+<span class="number">1</span>] &gt; nums[child_index]:</span><br><span class="line">            child_index = child_index+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果父结点大于孩子节点，那么停止循环</span></span><br><span class="line">        <span class="keyword">if</span> temp &gt; nums[child_index]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 将父结点更新到新检查的孩子节点，重复上面的操作</span></span><br><span class="line">        nums[parent_index] = nums[child_index]</span><br><span class="line">        parent_index = child_index</span><br><span class="line">        child_index = <span class="number">2</span>*parent_index + <span class="number">1</span></span><br><span class="line">    nums[parent_index] = temp  <span class="comment"># 最后，把父结点元素归位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment">## start from (len(nums)-2)//2:看一下图就知道了</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((len(nums)<span class="number">-2</span>)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heapify(i, len(nums), nums)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[j], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[j]</span><br><span class="line">        heapify(<span class="number">0</span>, j, nums)</span><br></pre></td></tr></table></figure>
<p><img src="/images/二叉堆.png" alt="image-20200614085943287"></p>
<p>当len=12，那么从数组下标为5开始调整，图中的6位置</p>
<p>当len=11，那么从数组下标为4开始调整，图中的5位置</p>
<p>依次类推</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> length, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span>；</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; length &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; length &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i]; array[i] = array[largest]; array[largest] = temp;</span><br><span class="line">        heapify(array, length, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        heapify(array, length, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>]; array[<span class="number">0</span>] = array[i]; array[i] = temp;</span><br><span class="line">        heapify(array, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的第K个最大元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O($n$)"></a>O($n$)</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<p>步骤</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<p>使用的局限性：</p>
<ol>
<li><p>待排序的数组元素只能为有确定范围的整数，因为要使用数组的索引来标识元素的顺序</p>
<p>有时候，小数和负数，可以通过乘以一个倍数或者加上一个正数，来调整成可以使用计数排序的形式</p>
</li>
<li><p>待排序数组的范围不能太大，否则会占用大量的内存，如果数据倾斜严重，可能只会使用到一小部分的位置，会造成大量的内存白白消耗</p>
</li>
</ol>
<p>升级：</p>
<p>可以使用下面要讲的桶排序，来弥补计数排序的两点不足</p>
<p><img src="/images/计数排序.png" alt="计数排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">max_value = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    bucket = [<span class="number">0</span>] * max_value</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        bucket[num] += <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_value):</span><br><span class="line">        nums[j:j + bucket[i]] = ([i] * bucket[i])[:]</span><br><span class="line">        j += bucket[i]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">56</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">78</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line">count_sort(nums)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>步骤</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<p><img src="/images/基数排序.png" alt="849589-20171015232453668-1397662527"></p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums, max_digit)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    max_digit 表示最大的位数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># 十进制数每位只能有10个选择：0-9</span></span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> range(max_digit):  <span class="comment"># 从低位开始分桶</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 对每个数整除10的倍数 取余，填入对一个的坑位</span></span><br><span class="line">            bucket[(num // (<span class="number">10</span> ** digit)) % <span class="number">10</span>].append(num)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 遍历10个坑位，把数据回填入nums</span></span><br><span class="line">            nums[j:j + len(bucket[i])] = bucket[i][:]</span><br><span class="line">            j += len(bucket[i])</span><br><span class="line"></span><br><span class="line">        bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># 一轮结束后，清空原来的bucket</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = radix_sort([<span class="number">32</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">134</span>, <span class="number">4</span>, <span class="number">53</span>, <span class="number">34</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, ], <span class="number">3</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大</p>
<p><img src="/images/桶排序.png" alt="桶排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> TheAlgorithms.sorts.insert_sort <span class="keyword">import</span> insert_sort1</span><br><span class="line"></span><br><span class="line">DEFAULT_BUCKET_SIZE = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(my_list, bucket_size=DEFAULT_BUCKET_SIZE)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(my_list) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'You don\'t have any elements in array!'</span>)</span><br><span class="line"></span><br><span class="line">    minValue = my_list[<span class="number">0</span>]</span><br><span class="line">    maxValue = my_list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For finding minimum and maximum values</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(my_list)):</span><br><span class="line">        <span class="keyword">if</span> my_list[i] &lt; minValue:</span><br><span class="line">            minValue = my_list[i]</span><br><span class="line">        <span class="keyword">elif</span> my_list[i] &gt; maxValue:</span><br><span class="line">            maxValue = my_list[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize buckets</span></span><br><span class="line">    bucketCount = math.floor((maxValue - minValue) / bucket_size) + <span class="number">1</span></span><br><span class="line">    buckets = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, bucketCount):</span><br><span class="line">        buckets.append([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For putting values in buckets</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(my_list)):</span><br><span class="line">        buckets[math.floor((my_list[i] - minValue) / bucket_size)].append(my_list[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sort buckets and place back into input array</span></span><br><span class="line">    sorted_array = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(buckets)):</span><br><span class="line">        insert_sort1(buckets[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(buckets[i])):</span><br><span class="line">            sorted_array.append(buckets[i][j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sorted_array = bucket_sort([<span class="number">12</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">81</span>, <span class="number">56</span>, <span class="number">95</span>])</span><br><span class="line">    print(sorted_array)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/数据分析-reduce函数引发的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/数据分析-reduce函数引发的/" class="post-title-link" itemprop="url">数据分析-reduce函数引发的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-28 13:35:25" itemprop="dateCreated datePublished" datetime="2019-03-28T13:35:25+08:00">2019-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-10 23:36:43" itemprop="dateModified" datetime="2019-04-10T23:36:43+08:00">2019-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据分析/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="reduce-in-python"><a href="#reduce-in-python" class="headerlink" title="reduce in python"></a>reduce in python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _functools.reduce</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(function, sequence, initial=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    reduce(function, sequence[, initial]) -&gt; value</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Apply a function of two arguments cumulatively to the items of a sequence,</span></span><br><span class="line"><span class="string">    from left to right, so as to reduce the sequence to a single value.</span></span><br><span class="line"><span class="string">    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates</span></span><br><span class="line"><span class="string">    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items</span></span><br><span class="line"><span class="string">    of the sequence in the calculation, and serves as a default when the</span></span><br><span class="line"><span class="string">    sequence is empty.</span></span><br><span class="line"><span class="string">    :param function:给定的一个func，func具有两个参数，参数1是临时聚合值，参数2是序列中下一个待聚合的值</span></span><br><span class="line"><span class="string">    :param sequence:待处理的可迭代的序列</span></span><br><span class="line"><span class="string">    :param initial:聚合数据的初始值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>工作原理：reduce函数对给定的序列遍历调用func函数，每次调用返回一个临时聚合值，直到整个序列遍历结束。如果设置了初始值，那么在第一次执行func函数的时候，会将func的参数1设置为初始值。</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">100</span>)</span><br><span class="line"><span class="number">115</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x, y: str(x)+str(y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="string">''</span>)</span><br><span class="line"><span class="string">'12345'</span></span><br></pre></td></tr></table></figure>
<p>reduce函数不仅可以完成这种聚合的功能，还可以完成更加复杂的操作，</p>
<h3 id="reduce-amp-foldLeft-amp-foldRight-amp-reduce-in-scala"><a href="#reduce-amp-foldLeft-amp-foldRight-amp-reduce-in-scala" class="headerlink" title="reduce&amp;foldLeft&amp;foldRight&amp;reduce in scala"></a>reduce&amp;foldLeft&amp;foldRight&amp;reduce in scala</h3><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="hive的UDAF"><a href="#hive的UDAF" class="headerlink" title="hive的UDAF"></a>hive的UDAF</h3><h3 id="spark的UDAF"><a href="#spark的UDAF" class="headerlink" title="spark的UDAF"></a>spark的UDAF</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/信贷数据统计的相关指标/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/信贷数据统计的相关指标/" class="post-title-link" itemprop="url">信贷数据统计的相关指标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-22 19:19:47" itemprop="dateCreated datePublished" datetime="2019-03-22T19:19:47+08:00">2019-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-03-28 22:24:24" itemprop="dateModified" datetime="2019-03-28T22:24:24+08:00">2019-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据分析/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="贷款类型"><a href="#贷款类型" class="headerlink" title="贷款类型"></a>贷款类型</h3><ul>
<li>等额本息贷款</li>
</ul>
<p>根据固定的还款时间，计算出应还的总利息，再加上本金，然后每个月平均等额的还款。</p>
<ul>
<li>等额本金贷款</li>
</ul>
<p>等额本金相对来说要简单一些，每月所还的本金是相同的，利息由每个月的剩余本金计算得出。</p>
<ul>
<li>固定点数贷款</li>
</ul>
<p>按照定义，我们在首次还款时先按固定的点数还一部分贷款，然后再按较低的利率还完剩余的贷款。</p>
<ul>
<li>双利率贷款</li>
</ul>
<p>前x个月以较低的r1利率还款，后m-x个月以较高的r2利率还款（假设还款总月数为m）</p>
<h3 id="相关指标"><a href="#相关指标" class="headerlink" title="相关指标"></a>相关指标</h3><ul>
<li>同比增长</li>
<li>环比增长</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/airflow安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/airflow安装/" class="post-title-link" itemprop="url">airflow安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 19:24:02" itemprop="dateCreated datePublished" datetime="2019-03-19T19:24:02+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-03-24 09:33:47" itemprop="dateModified" datetime="2019-03-24T09:33:47+08:00">2019-03-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># airflow needs a home, ~/airflow is the default,</span><br><span class="line"># but you can lay foundation somewhere else if you prefer</span><br><span class="line"># (optional)</span><br><span class="line">export AIRFLOW_HOME=~/airflow</span><br><span class="line"></span><br><span class="line"># install from pypi using pip</span><br><span class="line">pip install apache-airflow</span><br><span class="line"></span><br><span class="line"># initialize the database</span><br><span class="line">airflow initdb</span><br><span class="line"></span><br><span class="line"># start the web server, default port is 8080</span><br><span class="line">airflow webserver -p 8080</span><br><span class="line"></span><br><span class="line"># start the scheduler</span><br><span class="line">airflow scheduler</span><br><span class="line"></span><br><span class="line"># visit localhost:8080 in the browser and enable the example dag in the home page</span><br></pre></td></tr></table></figure>
<h3 id="USE-Mysql"><a href="#USE-Mysql" class="headerlink" title="USE Mysql"></a>USE Mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim $AIRFLOW_HOME/airflow.cfg</span><br><span class="line">	sql_alchemy_conn = mysql+pymysql://root:123456@localhost:3306/airflow</span><br><span class="line">	需要pip install pymysql</span><br></pre></td></tr></table></figure>
<h3 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ERROR [airflow.models.DagBag] Failed to import: /anaconda3/lib/python3.7/site-packages/airflow/example_dags/example_http_operator.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/anaconda3/lib/python3.7/site-packages/airflow/models.py&quot;, line 374, in process_file</span><br><span class="line">    m = imp.load_source(mod_name, filepath)</span><br><span class="line">  File &quot;/anaconda3/lib/python3.7/imp.py&quot;, line 171, in load_source</span><br><span class="line">    module = _load(spec)</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 696, in _load</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 677, in _load_unlocked</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 728, in exec_module</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed</span><br><span class="line">  File &quot;/anaconda3/lib/python3.7/site-packages/airflow/example_dags/example_http_operator.py&quot;, line 27, in &lt;module&gt;</span><br><span class="line">    from airflow.operators.http_operator import SimpleHttpOperator</span><br><span class="line">  File &quot;/anaconda3/lib/python3.7/site-packages/airflow/operators/http_operator.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    from airflow.hooks.http_hook import HttpHook</span><br><span class="line">  File &quot;/anaconda3/lib/python3.7/site-packages/airflow/hooks/http_hook.py&quot;, line 23, in &lt;module&gt;</span><br><span class="line">    import tenacity</span><br><span class="line">  File &quot;/anaconda3/lib/python3.7/site-packages/tenacity/__init__.py&quot;, line 352</span><br><span class="line">    from tenacity.async import AsyncRetrying</span><br><span class="line">                      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>修复方式：修改from tenacity.async import AsyncRetrying为from tenacity.async_a import AsyncRetrying，同时tenacity包下的async文件名为async_a</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/Spark学习笔记-抽样方法和自增ID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Spark学习笔记-抽样方法和自增ID/" class="post-title-link" itemprop="url">Spark学习笔记-抽样方法和自增ID</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 16:33:24" itemprop="dateCreated datePublished" datetime="2019-03-19T16:33:24+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-01 17:09:37" itemprop="dateModified" datetime="2020-07-01T17:09:37+08:00">2020-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spark学习/" itemprop="url" rel="index"><span itemprop="name">Spark学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="抽样方法"><a href="#抽样方法" class="headerlink" title="抽样方法"></a>抽样方法</h3><p><code>sample</code>(<em>withReplacement=None</em>, <em>fraction=None</em>, <em>seed=None</em>)</p>
<p>Returns a sampled subset of this <a href="http://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.DataFrame" target="_blank" rel="noopener"><code>DataFrame</code></a>.</p>
<ul>
<li><p><strong>withReplacement</strong> – Sample with replacement or not (default False).</p>
<ul>
<li>true时会将抽样的数据放回数据集，导致抽样数据有重复的</li>
<li>false时不会放回</li>
</ul>
</li>
<li><p><strong>fraction</strong> – Fraction of rows to generate, range [0.0, 1.0].</p>
<p>表示子集占数据集的占比</p>
</li>
<li><p><strong>seed</strong> – Seed for sampling (default a random seed).</p>
</li>
</ul>
<blockquote>
<p>fraction并不能保证完全按照占比抽样数据</p>
</blockquote>
<h3 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h3><p><code>monotonically_increasing_id()</code></p>
<p>每个分区分别排序生成一个64位的整数，但不是连续的。会将分区值放到高31位，然后将每条记录的序列放到低33位。限制：分区数不能大于10亿，每个分区的数据量不能大于80亿。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/Spark学习笔记-SparkSQL内置函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Spark学习笔记-SparkSQL内置函数/" class="post-title-link" itemprop="url">Spark学习笔记-SparkSQL内置函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 09:27:01" itemprop="dateCreated datePublished" datetime="2019-03-19T09:27:01+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-01 17:10:30" itemprop="dateModified" datetime="2020-07-01T17:10:30+08:00">2020-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spark学习/" itemprop="url" rel="index"><span itemprop="name">Spark学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>学习SparkSQL中的一些内置函数</p>
</blockquote>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul>
<li><p>获取默认时区</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark.conf.get(<span class="string">'spark.sql.session.timeZone'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前时间</p>
<ul>
<li><p>获取当前日期：current_date()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark.sql(<span class="string">"""</span></span><br><span class="line"><span class="string">    select current_date()</span></span><br><span class="line"><span class="string">"""</span>).toPandas()</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">2019</span><span class="number">-03</span><span class="number">-19</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前时间：current_timestamp()/now()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark.sql(<span class="string">"""</span></span><br><span class="line"><span class="string">    select current_timestamp()</span></span><br><span class="line"><span class="string">"""</span>).toPandas()</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">2019</span><span class="number">-03</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">54</span>:<span class="number">22.236</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从日期中截取字段</p>
<ul>
<li><p>截取年月日、时分秒:year,month,day/dayofmonth,hour,minute,second</p>
</li>
<li><p>dayofweek ,dayofyear</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 = Sunday, 2 = Monday, ..., 7 = Saturday</span><br></pre></td></tr></table></figure>
</li>
<li><p>weekofyear</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Extract the week number of a given date as integer.</span><br></pre></td></tr></table></figure>
</li>
<li><p>trunc截取某部分的日期，其他部分默认为01</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returns date truncated to the unit specified by the format.</span><br><span class="line"></span><br><span class="line">Parameters:	format – ‘year’, ‘yyyy’, ‘yy’ or ‘month’, ‘mon’, ‘mm’</span><br></pre></td></tr></table></figure>
</li>
<li><p>date_trunc [“YEAR”, “YYYY”, “YY”, “MON”, “MONTH”, “MM”, “DAY”, “DD”, “HOUR”, “MINUTE”, “SECOND”, “WEEK”, “QUARTER”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returns timestamp truncated to the unit specified by the format.</span><br><span class="line"></span><br><span class="line">Parameters:	format – ‘year’, ‘yyyy’, ‘yy’, ‘month’, ‘mon’, ‘mm’, ‘day’, ‘dd’, ‘hour’, ‘minute’, ‘second’, ‘week’, ‘quarter’</span><br></pre></td></tr></table></figure>
</li>
<li><p>date_format将时间转化为某种格式的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converts a date/timestamp/string to a value of string in the format specified by the date format given by the second argument.</span><br><span class="line"></span><br><span class="line">A pattern could be for instance dd.MM.yyyy and could return a string like ‘18.03.1993’. All pattern letters of the Java class java.text.SimpleDateFormat can be used.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>日期时间转换</p>
<ul>
<li><p>unix_timestamp返回当前时间的unix时间戳</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Convert time string with given pattern (‘yyyy-MM-dd HH:mm:ss’, by default) to Unix time stamp (in seconds), using the default timezone and the default locale, return null if fail.</span><br><span class="line"></span><br><span class="line">if timestamp is None, then it returns current timestamp.</span><br></pre></td></tr></table></figure>
</li>
<li><p>from_unixtime将时间戳换算成当前时间，to_unix_timestamp将时间转化为时间戳</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Converts the number of seconds from unix epoch (1970-01-01 00:00:00 UTC) to a string representing the timestamp of that moment in the current system time zone in the given format.</span><br></pre></td></tr></table></figure>
</li>
<li><p>to_date/date将字符串转化为日期格式，to_timestamp（Since: 2.2.0）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converts a Column of pyspark.sql.types.StringType or pyspark.sql.types.TimestampType into pyspark.sql.types.DateType using the optionally specified format. Specify formats according to SimpleDateFormats. By default, it follows casting rules to pyspark.sql.types.DateType if the format is omitted (equivalent to col.cast(&quot;date&quot;)).</span><br><span class="line"></span><br><span class="line">Converts a Column of pyspark.sql.types.StringType or pyspark.sql.types.TimestampType into pyspark.sql.types.DateType using the optionally specified format. Specify formats according to SimpleDateFormats. By default, it follows casting rules to pyspark.sql.types.TimestampType if the format is omitted (equivalent to col.cast(&quot;timestamp&quot;)).</span><br></pre></td></tr></table></figure>
</li>
<li><p>quarter 将1年4等分(range 1 to 4)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Extract the quarter of a given date as integer.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>日期、时间计算</p>
<ul>
<li>months_between两个日期之间的月数</li>
<li>add_months返回日期后n个月后的日期</li>
<li>last_day(date),next_day(start_date, day_of_week)</li>
<li>date_add,date_sub(减)</li>
<li>datediff（两个日期间的天数）</li>
</ul>
</li>
<li>utc</li>
</ul>
<blockquote>
<p>在集群中对于时间戳的转换，如果不指定时区，默认会采用集群配置的时区，集群默认时区可以通过如下方式获取：spark.conf.get(‘spark.sql.session.timeZone’)。一般而言，这个值应该是集群统一设置，独立提交job的时候，不需要设置。 </p>
</blockquote>
<ul>
<li><ul>
<li><p>to_utc_timestamp(timestamp, tz)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将timestamp按照给定的tz解释，返回utc timestamp</span><br></pre></td></tr></table></figure>
</li>
<li><p>from_utc_timestamp(timestamp, tz)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将timestamp按照utc解释，返回给定tz的timestamp</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于有时区相关的数据统计时，需要注意。比如：集群默认时区设置为UTC，一般将数据存到集群中的时候会将时间戳转为utc timestamp以便后续的操作。此时如果有一个需求是统计北京时间的当天的数据，那么第一个想到的方式是使用current_date()获取当前日期，然后将数据中的时间戳使用to_date(from_utc_timestamp(from_unixtime(ts), ‘Asia/Beijing’))，然后进行比较。但是current_date()获取的日期，是根据集群默认时区得来的，因此会有时区的不同导致的数据统计错误，因此，这种情况不能直接使用current_date()，正确的使用方式是：to_date(from_utc_timestamp(current_timestamp(), ‘Asia/Beijing’))，然后在进行比较。</p>
</blockquote>
<h3 id="表关联"><a href="#表关联" class="headerlink" title="表关联"></a>表关联</h3><ul>
<li><p>Join(<em>other</em>, <em>on=None</em>, <em>how=None</em>)</p>
<ul>
<li>on：a string for the join column name, a list of column names, a join expression (Column), or a list of Columns. If on is a string or a list of strings indicating the name of the join column(s), the column(s) must exist on both sides, and this performs an equi-join.</li>
<li>how：str, default <code>inner</code>. Must be one of: <code>inner</code>, <code>cross</code>, <code>outer</code>, <code>full</code>, <code>full_outer</code>, <code>left</code>, <code>left_outer</code>, <code>right</code>, <code>right_outer</code>, <code>left_semi</code>, and <code>left_anti</code><ul>
<li>inner:内连，返回joinDF1和joinDF2合并的rows，如果joinDF2中有多条记录对应于joinDF1的同一条记录，那么返回的row number会大于joinDF1的row number</li>
<li>outer,full,full_outer：全连</li>
<li>left, left_outer：左连</li>
<li>right，right_outer:右连</li>
<li>left_semi：过滤出joinDF1中和joinDF2共有的部分，只返回joinDF1中的rows</li>
<li>left_anti：过滤出joinDF1中joinDF2没有的部分，只返回joinDF1中的rows</li>
</ul>
</li>
</ul>
</li>
<li><p>crossJoin(<em>other</em>)</p>
</li>
</ul>
<blockquote>
<p>返回两个DF的笛卡尔积</p>
</blockquote>
<h3 id="Parses-the-expression"><a href="#Parses-the-expression" class="headerlink" title="Parses the expression"></a>Parses the expression</h3><ul>
<li>expr</li>
</ul>
<blockquote>
<p>将字符串表示的表达式，翻译成DSL</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr(<span class="string">"length(name)"</span>)</span><br><span class="line"></span><br><span class="line">expr(<span class="string">"array_contains(user_id_set, user_id)"</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/数据分析小知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/数据分析小知识点/" class="post-title-link" itemprop="url">数据分析小知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-19 09:25:56" itemprop="dateCreated datePublished" datetime="2019-03-19T09:25:56+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-03 10:17:49" itemprop="dateModified" datetime="2019-08-03T10:17:49+08:00">2019-08-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据分析/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>总结一下在数据分析中需要注意的一些tips，持续更新</p>
</blockquote>
<h3 id="Tip1-时区"><a href="#Tip1-时区" class="headerlink" title="Tip1 时区"></a>Tip1 时区</h3><p>在进行跨境业务处理的时候，时区的控制是十分必要的。平时对于国内的业务，部署在国内的服务器，使用的时区一般都是北京时间(北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间)，在数据库中一般存储相对于unix epoch (1970-01-01 00:00:00 UTC)的毫秒时间戳，做某个地区的数据统计时，需要将时间戳转换成当地的时间(即加一个时区的属性)</p>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda6103214cd61d0c2000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda6103214cd61d0c2000</a></p>
<h3 id="Tip-2-Excel函数"><a href="#Tip-2-Excel函数" class="headerlink" title="Tip 2 Excel函数"></a>Tip 2 Excel函数</h3><ul>
<li>去重计数：SUMPRODUCT(1/COUNTIF(A2:A20,A2:A20))</li>
<li>VLOOKUP(要查找的值,查找返回,返回查找到的第几列,是否精确查找[1])</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><em>落地页</em>，也称：着陆页、引导页，是指访问者在其他地方看到发出的某个具有明确主题的特定营销活动——通过Email、社交媒体或广告发布的诱人优惠信息等，点击后被链接到你网站上的第一个页面</p>
<p>PRD：产品需求文档，产品需求文档是将商业需求文档（BRD）和市场需求文档（MRD）用更加专业的语言进行描述</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shang.at/post/Spark学习笔记-窗口函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Spark学习笔记-窗口函数/" class="post-title-link" itemprop="url">Spark学习笔记-窗口函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-12 10:15:03" itemprop="dateCreated datePublished" datetime="2019-03-12T10:15:03+08:00">2019-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-03 18:37:41" itemprop="dateModified" datetime="2020-07-03T18:37:41+08:00">2020-07-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spark学习/" itemprop="url" rel="index"><span itemprop="name">Spark学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Window</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> StructType, StringType, StructField, IntegerType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">schema = StructType([</span><br><span class="line">    StructField(<span class="string">'shop_id'</span>, StringType()),</span><br><span class="line">    StructField(<span class="string">'date'</span>, StringType()),</span><br><span class="line">    StructField(<span class="string">'amount'</span>, IntegerType())</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark = SparkSession \</span><br><span class="line">        .builder \</span><br><span class="line">        .master(<span class="string">'local[*]'</span>) \</span><br><span class="line">        .enableHiveSupport() \</span><br><span class="line">        .getOrCreate()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">        &#123;<span class="string">'shop_id'</span>: <span class="string">'10006'</span>, <span class="string">'date'</span>: <span class="string">'201501120030'</span>, <span class="string">'amount'</span>: <span class="number">2313</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'shop_id'</span>: <span class="string">'10006'</span>, <span class="string">'date'</span>: <span class="string">'201501120100'</span>, <span class="string">'amount'</span>: <span class="number">23112</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'shop_id'</span>: <span class="string">'10006'</span>, <span class="string">'date'</span>: <span class="string">'201501120130'</span>, <span class="string">'amount'</span>: <span class="number">23112</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'shop_id'</span>: <span class="string">'10006'</span>, <span class="string">'date'</span>: <span class="string">'201501120200'</span>, <span class="string">'amount'</span>: <span class="number">24234</span>&#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = spark.createDataFrame(data, schema)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.printSchema()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- shop_id: string (nullable = true)</span><br><span class="line"> |-- date: string (nullable = true)</span><br><span class="line"> |-- amount: integer (nullable = true)</span><br></pre></td></tr></table></figure>
<h2 id="关于子窗口"><a href="#关于子窗口" class="headerlink" title="关于子窗口"></a>关于子窗口</h2><p>子窗口需要指定一个边界，有以下两种方式：</p>
<ul>
<li>ROWS between CURRENT ROW | UNBOUNDED PRECEDING | [num] PRECEDING AND  UNBOUNDED FOLLOWING | [num] FOLLOWING| CURRENT ROW</li>
<li>RANGE between [num] PRECEDING  AND [num] FOLLOWING</li>
</ul>
<p>窗口的含义<br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g10643qf18j30de06h3yq.jpg" alt></p>
<p>ROWS是物理窗口，从行数上控制窗口的尺寸的；<br>RANGE是逻辑窗口，从列值上控制窗口的尺寸</p>
<p>通常会结合order by子句使用，如果在order by子句后面没有指定窗口子句，则默认为：rows between unbounded preceding and current row</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">spark中关于Window函数的学习</span><br><span class="line"></span><br><span class="line">在spark中涉及Window函数的主要有以下两个类和一个Column的方法</span><br><span class="line">pyspark.sql.column.Column#over   在窗口上应用某一种分析函数</span><br><span class="line">pyspark.sql.window.Window        创建WindowSpec的工具类</span><br><span class="line">    pyspark.sql.window.Window.unboundedPreceding</span><br><span class="line">    pyspark.sql.window.Window.unboundedFollowing</span><br><span class="line">    pyspark.sql.window.Window.currentRow</span><br><span class="line">    pyspark.sql.window.Window#partitionBy</span><br><span class="line">    pyspark.sql.window.Window#orderBy</span><br><span class="line">    pyspark.sql.window.Window#rowsBetween(start, end)</span><br><span class="line">    pyspark.sql.window.Window#rangeBetween(start, end)</span><br><span class="line">pyspark.sql.window.WindowSpec    窗口的规范</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pyspark.sql.window.Window#rowsBetween(start, end)</span><br><span class="line">定义窗口的边界，[start, end]，在边界处是闭区间</span><br><span class="line">start和end都是相对于当前row的相对位置，例如：</span><br><span class="line">- 0：当前row</span><br><span class="line">- -1：当前行的前1row</span><br><span class="line">- 5：当前行的后5row</span><br><span class="line">- (-1, 5)：窗口的范围为，当前row+当前行的前1row+当前行的后5row = 7rows</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="统计截止到当前时间段的店铺累计销售金额"><a href="#统计截止到当前时间段的店铺累计销售金额" class="headerlink" title="统计截止到当前时间段的店铺累计销售金额"></a>统计截止到当前时间段的店铺累计销售金额</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(</span><br><span class="line">    <span class="string">'t_amount'</span>,</span><br><span class="line">    sum(<span class="string">'amount'</span>).over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(asc(<span class="string">'date'</span>)))</span><br><span class="line">).select(</span><br><span class="line">    <span class="string">'shop_id'</span>, <span class="string">'date'</span>, <span class="string">'t_amount'</span></span><br><span class="line">).show(<span class="number">50</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析：<br>根据shop_id分组，根据date正序排列，由于orderBy后面没有追加rowsBetween()，则默认的rowsBetween为：[Window.unboundedPreceding，Window.currentRow]。即会统计根据date排序后，从第一行计算到当前行，从而达到了<code>统计截止到当前时间段的店铺累计销售金额</code>的效果</p>
<h3 id="统计每个时间段的销售占比"><a href="#统计每个时间段的销售占比" class="headerlink" title="统计每个时间段的销售占比"></a>统计每个时间段的销售占比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(</span><br><span class="line">    <span class="string">'t_amount'</span>,</span><br><span class="line">    col(<span class="string">'amount'</span>)/sum(<span class="string">'amount'</span>).over(Window.partitionBy(<span class="string">'shop_id'</span>))</span><br><span class="line">).select(</span><br><span class="line">    <span class="string">'shop_id'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>,<span class="string">'t_amount'</span></span><br><span class="line">).show(<span class="number">50</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析：<br>根据shop_id分组，不排序，窗口大小默认就是整个分组。</p>
<h3 id="找出2点的销售金额及前半小时的销售金额和后1个小时的销售金额"><a href="#找出2点的销售金额及前半小时的销售金额和后1个小时的销售金额" class="headerlink" title="找出2点的销售金额及前半小时的销售金额和后1个小时的销售金额"></a>找出2点的销售金额及前半小时的销售金额和后1个小时的销售金额</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(</span><br><span class="line">    <span class="string">'pre_half_hour'</span>,</span><br><span class="line">    lag(<span class="string">'date'</span>, <span class="number">1</span>).over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(asc(<span class="string">'date'</span>)))</span><br><span class="line">).withColumn(</span><br><span class="line">    <span class="string">'pre_half_hour_amount'</span>,</span><br><span class="line">    lag(<span class="string">'amount'</span>, <span class="number">1</span>).over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(asc(<span class="string">'date'</span>)))</span><br><span class="line">).withColumn(</span><br><span class="line">    <span class="string">'follow_one_hour'</span>,</span><br><span class="line">    lead(<span class="string">'date'</span>, <span class="number">2</span>).over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(asc(<span class="string">'date'</span>)))</span><br><span class="line">).withColumn(</span><br><span class="line">    <span class="string">'follow_one_hour_amount'</span>,</span><br><span class="line">    lead(<span class="string">'amount'</span>, <span class="number">2</span>).over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(asc(<span class="string">'date'</span>)))</span><br><span class="line">).filter(</span><br><span class="line">    col(<span class="string">'date'</span>) == <span class="string">'201501120200'</span></span><br><span class="line">).select(</span><br><span class="line">    <span class="string">'shop_id'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>,<span class="string">'pre_half_hour'</span>, <span class="string">'pre_half_hour_amount'</span>, <span class="string">'follow_one_hour'</span>, <span class="string">'follow_one_hour_amount'</span></span><br><span class="line">).show(truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------+------------+------+-------------+--------------------+---------------+----------------------+</span><br><span class="line">|shop_id|date        |amount|pre_half_hour|pre_half_hour_amount|follow_one_hour|follow_one_hour_amount|</span><br><span class="line">+-------+------------+------+-------------+--------------------+---------------+----------------------+</span><br><span class="line">|10006  |201501120200|24234 |201501120130 |2342                |201501120300   |31232                 |</span><br><span class="line">+-------+------------+------+-------------+--------------------+---------------+----------------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">pyspark.sql.functions.lag(col, count=1, default=none)</span><br><span class="line">是取前N行的值</span><br><span class="line"></span><br><span class="line">pyspark.sql.functions.lead(col, count=1, default=none)</span><br><span class="line">是取后N行的值。</span><br></pre></td></tr></table></figure>
<h3 id="按照销售金额进行排名，金额最大的排最前（limit可以取topn的数）"><a href="#按照销售金额进行排名，金额最大的排最前（limit可以取topn的数）" class="headerlink" title="按照销售金额进行排名，金额最大的排最前（limit可以取topn的数）"></a>按照销售金额进行排名，金额最大的排最前（limit可以取topn的数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(</span><br><span class="line">    <span class="string">'rn'</span>,</span><br><span class="line">    dense_rank().over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(desc(<span class="string">'amount'</span>)))</span><br><span class="line">).select(</span><br><span class="line">    <span class="string">'shop_id'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>, <span class="string">'rn'</span>    </span><br><span class="line">).show(<span class="number">50</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(</span><br><span class="line">    <span class="string">'rn'</span>,</span><br><span class="line">    rank().over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(desc(<span class="string">'amount'</span>)))</span><br><span class="line">).select(</span><br><span class="line">    <span class="string">'shop_id'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>, <span class="string">'rn'</span>    </span><br><span class="line">).show(<span class="number">50</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(</span><br><span class="line">    <span class="string">'rn'</span>,</span><br><span class="line">    row_number().over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(desc(<span class="string">'amount'</span>)))</span><br><span class="line">).select(</span><br><span class="line">    <span class="string">'shop_id'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>, <span class="string">'rn'</span>    </span><br><span class="line">).show(<span class="number">50</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析：<br>dense_rank和rank都是排名函数，区别在于dense_rank是连续排名，rank遇到排名并列时，下一列排名跳空。<br>row_number是加行号，次序是连续的，不会存在重复的行号</p>
<h3 id="按销售金额排序，取出前20-的时间段和相应金额"><a href="#按销售金额排序，取出前20-的时间段和相应金额" class="headerlink" title="按销售金额排序，取出前20%的时间段和相应金额"></a>按销售金额排序，取出前20%的时间段和相应金额</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.withColumn(</span><br><span class="line">    <span class="string">'tile'</span>,</span><br><span class="line">    ntile(<span class="number">5</span>).over(Window.partitionBy(<span class="string">'shop_id'</span>).orderBy(desc(<span class="string">'amount'</span>)))</span><br><span class="line">).select(</span><br><span class="line">    <span class="string">'shop_id'</span>, <span class="string">'date'</span>, <span class="string">'amount'</span>, <span class="string">'tile'</span>    </span><br><span class="line">).show(<span class="number">50</span>, truncate=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>NTILE就是把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号</p>
<p>设置n=5，那么ntile就会把排好序的数据均分成n个组，ntile函数会返回每条数据所在组的组编号，从而可以达到取前百分比的数据</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>思考：在使用row_number函数的时候，并没有指定rowsBetween，那么默认应该是默认的rows between unbounded preceding and current row。<br>但是，结果却是把组内的所有元素都进行了标号</p>
<p>rowsBetween应该是针对于具有聚合性质的函数起作用</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">王尚</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王尚</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>

  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script>


  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>