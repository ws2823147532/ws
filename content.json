{"meta":{"title":"努力，奋斗","subtitle":"记录学习","description":null,"author":"王尚","url":"https://shang.at","root":"/"},"pages":[{"title":"About","date":"2019-03-24T01:33:47.232Z","updated":"2019-03-24T01:33:47.232Z","comments":true,"path":"about/index.html","permalink":"https://shang.at/about/index.html","excerpt":"","text":"大数据工程师一枚 邮箱：2823147532@qq.com 此博客仅为个人学习数据结构和算法的一个笔记，就是想督促自己坚持学习。笔记内容主要来源于其他的博客和读完博客后的自己的一点思考"},{"title":"Tags","date":"2019-03-24T01:33:47.233Z","updated":"2019-03-24T01:33:47.233Z","comments":true,"path":"tags/index.html","permalink":"https://shang.at/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spark应用之import spark.implicits._","slug":"Spark应用之import-spark-implicits","date":"2020-03-25T09:10:54.000Z","updated":"2020-03-25T09:15:05.594Z","comments":true,"path":"post/Spark应用之import-spark-implicits/","link":"","permalink":"https://shang.at/post/Spark应用之import-spark-implicits/","excerpt":"","text":"在初期使用spark的时候，大家都会遇见一个很奇怪的写法","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Spark应用","slug":"Spark应用","permalink":"https://shang.at/tags/Spark应用/"}]},{"title":"hadoop源码学习一","slug":"hadoop源码学习一","date":"2019-07-10T03:03:43.000Z","updated":"2019-08-03T02:17:49.590Z","comments":true,"path":"post/hadoop源码学习一/","link":"","permalink":"https://shang.at/post/hadoop源码学习一/","excerpt":"","text":"","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://shang.at/categories/Hadoop/"}],"tags":[{"name":"源码学习","slug":"源码学习","permalink":"https://shang.at/tags/源码学习/"}]},{"title":"Pandas-学习","slug":"Pandas-学习","date":"2019-06-11T01:53:35.000Z","updated":"2019-08-03T02:17:49.584Z","comments":true,"path":"post/Pandas-学习/","link":"","permalink":"https://shang.at/post/Pandas-学习/","excerpt":"","text":"","categories":[{"name":"Pandas","slug":"Pandas","permalink":"https://shang.at/categories/Pandas/"}],"tags":[]},{"title":"Python学习-时间处理","slug":"Python学习-时间处理","date":"2019-06-06T08:37:46.000Z","updated":"2019-08-03T02:17:49.584Z","comments":true,"path":"post/Python学习-时间处理/","link":"","permalink":"https://shang.at/post/Python学习-时间处理/","excerpt":"","text":"关于时间戳的几个概念时间戳，根据1970年1月1日00:00:00开始按秒计算的偏移量。时间元组（struct_time），包含9个元素。 time.struct_time(tm_year=2017, tm_mon=10, tm_mday=1, tm_hour=14, tm_min=21, tm_sec=57, tm_wday=6, tm_yday=274, tm_isdst=0) 时间格式字符串，字符串形式的时间。time模块与时间戳和时间相关的重要函数 time.time() # 生成当前的时间戳，格式为10位整数的浮点数。time.strftime() # 根据时间元组生成时间格式化字符串。time.strptime() # 根据时间格式化字符串生成时间元组。time.strptime()与time.strftime()为互操作。time.localtime() # 根据时间戳生成当前时区的时间元组。time.mktime() # 根据时间元组生成时间戳。 示例 import time##生成当前时间的时间戳，只有一个参数即时间戳的位数，默认为10位，输入位数即生成相应位数的时间戳，比如可以生成常用的13位时间戳def now_to_timestamp(digits = 10): time_stamp = time.time() digits = 10 ** (digits -10) time_stamp = int(round(time_stamp*digits)) return time_stamp##将时间戳规范为10位时间戳def timestamp_to_timestamp10(time_stamp): time_stamp = int (time_stamp* (10 ** (10-len(str(time_stamp))))) return time_stamp##将当前时间转换为时间字符串，默认为2017-10-01 13:37:04格式def now_to_date(format_string=\"%Y-%m-%d %H:%M:%S\"): time_stamp = int(time.time()) time_array = time.localtime(time_stamp) str_date = time.strftime(format_string, time_array) return str_date##将10位时间戳转换为时间字符串，默认为2017-10-01 13:37:04格式def timestamp_to_date(time_stamp, format_string=\"%Y-%m-%d %H:%M:%S\"): time_array = time.localtime(time_stamp) str_date = time.strftime(format_string, time_array) return str_date##将时间字符串转换为10位时间戳，时间字符串默认为2017-10-01 13:37:04格式def date_to_timestamp(date, format_string=\"%Y-%m-%d %H:%M:%S\"): time_array = time.strptime(date, format_string) time_stamp = int(time.mktime(time_array)) return time_stamp##不同时间格式字符串的转换def date_style_transfomation(date, format_string1=\"%Y-%m-%d %H:%M:%S\",format_string2=\"%Y-%m-%d %H-%M-%S\"): time_array = time.strptime(date, format_string1) str_date = time.strftime(format_string2, time_array) return str_dateprint(now_to_date())print(timestamp_to_date(1506816572))print(date_to_timestamp('2017-10-01 08:09:32'))print(timestamp_to_timestamp10(1506816572546))print(date_style_transfomation('2017-10-01 08:09:32')) 结果为 15068362240002017-10-01 13:37:042017-10-01 08:09:3215068165721506816572","categories":[{"name":"Python","slug":"Python","permalink":"https://shang.at/categories/Python/"}],"tags":[{"name":"python中的时间处理","slug":"python中的时间处理","permalink":"https://shang.at/tags/python中的时间处理/"}]},{"title":"Spark学习笔记-Configuration","slug":"Spark学习笔记-Configuration","date":"2019-06-03T09:32:33.000Z","updated":"2019-08-03T02:17:49.585Z","comments":true,"path":"post/Spark学习笔记-Configuration/","link":"","permalink":"https://shang.at/post/Spark学习笔记-Configuration/","excerpt":"","text":"submit 参数 运行时可配置参数：在代码中使用spark.conf.set(‘’， ‘’)的方式设置。运行时设置的参数不会在WebUI中显示","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Configuration","slug":"Configuration","permalink":"https://shang.at/tags/Configuration/"}]},{"title":"Python学习-队列","slug":"Python学习-队列","date":"2019-06-03T02:10:48.000Z","updated":"2019-08-03T02:17:49.585Z","comments":true,"path":"post/Python学习-队列/","link":"","permalink":"https://shang.at/post/Python学习-队列/","excerpt":"","text":"队列from queue import Queue #LILO队列q = Queue() #创建队列对象q.put(0) #在队列尾部插入元素q.put(1)q.put(2)print(&apos;LILO队列&apos;,q.queue) #查看队列中的所有元素print(q.get()) #返回并删除队列头部元素print(q.queue)from queue import LifoQueue #LIFO队列lifoQueue = LifoQueue()lifoQueue.put(1)lifoQueue.put(2)lifoQueue.put(3)print(&apos;LIFO队列&apos;,lifoQueue.queue)lifoQueue.get() #返回并删除队列尾部元素lifoQueue.get()print(lifoQueue.queue)from queue import PriorityQueue #优先队列priorityQueue = PriorityQueue() #创建优先队列对象priorityQueue.put(3) #插入元素priorityQueue.put(78) #插入元素priorityQueue.put(100) #插入元素print(priorityQueue.queue) #查看优先级队列中的所有元素priorityQueue.put(1) #插入元素priorityQueue.put(2) #插入元素print(&apos;优先级队列:&apos;,priorityQueue.queue) #查看优先级队列中的所有元素priorityQueue.get() #返回并删除优先级最低的元素print(&apos;删除后剩余元素&apos;,priorityQueue.queue)priorityQueue.get() #返回并删除优先级最低的元素print(&apos;删除后剩余元素&apos;,priorityQueue.queue) #删除后剩余元素priorityQueue.get() #返回并删除优先级最低的元素print(&apos;删除后剩余元素&apos;,priorityQueue.queue) #删除后剩余元素priorityQueue.get() #返回并删除优先级最低的元素print(&apos;删除后剩余元素&apos;,priorityQueue.queue) #删除后剩余元素priorityQueue.get() #返回并删除优先级最低的元素print(&apos;全部被删除后:&apos;,priorityQueue.queue) #查看优先级队列中的所有元素from collections import deque #双端队列dequeQueue = deque([&apos;Eric&apos;,&apos;John&apos;,&apos;Smith&apos;])print(dequeQueue)dequeQueue.append(&apos;Tom&apos;) #在右侧插入新元素dequeQueue.appendleft(&apos;Terry&apos;) #在左侧插入新元素print(dequeQueue)dequeQueue.rotate(2) #循环右移2次print(&apos;循环右移2次后的队列&apos;,dequeQueue)dequeQueue.popleft() #返回并删除队列最左端元素print(&apos;删除最左端元素后的队列：&apos;,dequeQueue)dequeQueue.pop() #返回并删除队列最右端元素print(&apos;删除最右端元素后的队列：&apos;,dequeQueue)","categories":[{"name":"Python","slug":"Python","permalink":"https://shang.at/categories/Python/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shang.at/tags/数据结构/"}]},{"title":"Spark学习笔记-广播变量","slug":"Spark学习笔记-广播变量","date":"2019-05-28T08:19:03.000Z","updated":"2019-08-03T02:17:49.589Z","comments":true,"path":"post/Spark学习笔记-广播变量/","link":"","permalink":"https://shang.at/post/Spark学习笔记-广播变量/","excerpt":"","text":"Shared Variables通常，当在远程集群节点上执行传递给Spark操作（例如mapor reduce）的函数时，它将在函数中使用的所有变量的单独副本上工作。这些变量将复制到每台计算机，并且远程计算机上的变量的更新不会传播回驱动程序。支持跨任务的通用，读写共享变量效率低下。但是，Spark确实为两种常见的使用模式提供了两种有限类型的共享变量：广播变量和累加器。 Broadcast广播变量允许程序员在每台机器上保留一个只读变量，而不是随副本一起发送它的副本。例如，它们可用于以有效的方式为每个节点提供大输入数据集的副本。Spark还尝试使用有效的广播算法来分发广播变量，以降低通信成本。 Spark动作通过一组阶段执行，由分布式“shuffle”操作分隔。Spark自动广播每个阶段中任务所需的公共数据。以这种方式广播的数据以序列化形式缓存并在运行每个任务之前反序列化。这意味着显式创建广播变量仅在跨多个阶段的任务需要相同数据或以反序列化形式缓存数据很重要时才有用。 广播变量是v通过调用从变量创建的SparkContext.broadcast(v)。广播变量是一个包装器v，可以通过调用该value 方法来访问它的值。下面的代码显示了这个： &gt;&gt;&gt; broadcastVar = sc.broadcast([1, 2, 3])&lt;pyspark.broadcast.Broadcast object at 0x102789f10&gt;&gt;&gt;&gt; broadcastVar.value[1, 2, 3] 创建广播变量后，应该使用它来代替v群集上运行的任何函数中的值，这样v就不会多次传送到节点。此外，在v广播之后不应修改对象 ，以确保所有节点获得相同的广播变量值（例如，如果稍后将变量发送到新节点）。 Performance Tuning == Physical Plan ==InMemoryTableScan [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_outstanding_amount_ex_dp90#6075] +- InMemoryRelation [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_outstanding_amount_ex_dp90#6075], true, 10000, StorageLevel(disk, 1 replicas) +- *(34) Project [bill_create_date#4955, week_last_day#5015, month_last_day#5075, ((coalesce(nanvl(total_disburse_amount#5203, null), 0.0) - cast(coalesce(total_repay_principal_amount#5974, 0) as double)) - coalesce(nanvl(total_write_off_principal#5986, null), 0.0)) AS total_outstanding_amount_ex_dp90#6075] +- SortMergeJoin [bill_create_date#4955], [write_off_date#4776], LeftOuter :- *(23) Project [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_disburse_amount#5203, total_repay_principal_amount#5974] : +- SortMergeJoin [bill_create_date#4955], [repay_date#5789], LeftOuter : :- *(6) Sort [bill_create_date#4955 ASC NULLS FIRST], false, 0 : : +- Exchange hashpartitioning(bill_create_date#4955, 200) : : +- *(5) Project [bill_create_date#4955, week_last_day#5015, month_last_day#5075, total_disburse_amount#5203] : : +- Window [sum(disburse_amount#5197) windowspecdefinition(1, bill_create_date#4955 ASC NULLS FIRST, specifiedwindowframe(RangeFrame, unboundedpreceding$(), currentrow$())) AS total_disburse_amount#5203], [1], [bill_create_date#4955 ASC NULLS FIRST] : : +- *(4) Sort [1 ASC NULLS FIRST, bill_create_date#4955 ASC NULLS FIRST], false, 0 : : +- Exchange hashpartitioning(1, 200) : : +- *(3) HashAggregate(keys=[bill_create_date#4955, week_last_day#5015, month_last_day#5075], functions=[sum(cast(principal#615 as double))]) : : +- Exchange hashpartitioning(bill_create_date#4955, week_last_day#5015, month_last_day#5075, 200) : : +- *(2) HashAggregate(keys=[bill_create_date#4955, week_last_day#5015, month_last_day#5075], functions=[partial_sum(cast(principal#615 as double))]) : : +- *(2) Project [principal#615, cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) AS bill_create_date#4955, next_day(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), Sun) AS week_last_day#5015, last_day(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date)) AS month_last_day#5075] : : +- *(2) BroadcastHashJoin [id#392], [loan_id#609], Inner, BuildRight : : :- *(2) Project [id#392] : : : +- *(2) Filter (status#397 IN (COMPLETED,CURRENT,LATE) &amp;&amp; isnotnull(id#392)) : : : +- *(2) FileScan parquet [id#392,status#397] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [In(status, [COMPLETED,CURRENT,LATE]), IsNotNull(id)], ReadSchema: struct&lt;id:string,status:string&gt; : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true])) : : +- *(1) Project [loan_id#609, principal#615, create_time#632L] : : +- *(1) Filter ((cast(from_utc_timestamp(cast(from_unixtime(cast((cast(create_time#632L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) &lt;= 18043) &amp;&amp; isnotnull(loan_id#609)) : : +- *(1) FileScan parquet [loan_id#609,principal#615,create_time#632L] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [IsNotNull(loan_id)], ReadSchema: struct&lt;loan_id:string,principal:string,create_time:bigint&gt; : +- *(22) Sort [repay_date#5789 ASC NULLS FIRST], false, 0 : +- Exchange hashpartitioning(repay_date#5789, 200) : +- *(21) Project [repay_date#5789, total_repay_principal_amount#5974] : +- Window [sum(repay_principal_amount#5970) windowspecdefinition(1, repay_date#5789 ASC NULLS FIRST, specifiedwindowframe(RangeFrame, unboundedpreceding$(), currentrow$())) AS total_repay_principal_amount#5974], [1], [repay_date#5789 ASC NULLS FIRST] : +- *(20) Sort [1 ASC NULLS FIRST, repay_date#5789 ASC NULLS FIRST], false, 0 : +- Exchange hashpartitioning(1, 200) : +- *(19) HashAggregate(keys=[repay_date#5789], functions=[sum(CASE WHEN (isnull(write_off_date#4776) || (write_off_date#4776 &gt; repay_date#5789)) THEN repaid_principal#684 END)]) : +- Exchange hashpartitioning(repay_date#5789, 200) : +- *(18) HashAggregate(keys=[repay_date#5789], functions=[partial_sum(CASE WHEN (isnull(write_off_date#4776) || (write_off_date#4776 &gt; repay_date#5789)) THEN repaid_principal#684 END)]) : +- *(18) Project [repaid_principal#684, write_off_date#4776, cast(from_utc_timestamp(repay_time#692, Asia/Ho_Chi_Minh) as date) AS repay_date#5789] : +- SortMergeJoin [loan_id#609], [loan_id#5672], LeftOuter : :- *(12) Sort [loan_id#609 ASC NULLS FIRST], false, 0 : : +- Exchange hashpartitioning(loan_id#609, 200) : : +- *(11) Project [loan_id#609, repaid_principal#684, repay_time#692] : : +- *(11) BroadcastHashJoin [id#608], [bill_id#670], Inner, BuildRight : : :- *(11) Project [id#608, loan_id#609] : : : +- *(11) BroadcastHashJoin [id#392], [loan_id#609], Inner, BuildRight : : : :- *(11) Project [id#392] : : : : +- *(11) Filter (status#397 IN (COMPLETED,CURRENT,LATE) &amp;&amp; isnotnull(id#392)) : : : : +- *(11) FileScan parquet [id#392,status#397] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [In(status, [COMPLETED,CURRENT,LATE]), IsNotNull(id)], ReadSchema: struct&lt;id:string,status:string&gt; : : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[1, string, true])) : : : +- *(7) Project [id#608, loan_id#609] : : : +- *(7) Filter (isnotnull(loan_id#609) &amp;&amp; isnotnull(id#608)) : : : +- *(7) FileScan parquet [id#608,loan_id#609] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [IsNotNull(loan_id), IsNotNull(id)], ReadSchema: struct&lt;id:string,loan_id:string&gt; : : +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[0, string, true])) : : +- *(10) Project [bill_id#670, repaid_principal#684, repay_time#692] : : +- *(10) Filter ((isnotnull(rn#5382) &amp;&amp; (rn#5382 = 1)) &amp;&amp; (cast(from_utc_timestamp(repay_time#692, Asia/Ho_Chi_Minh) as date) &lt;= 18043)) : : +- Window [row_number() windowspecdefinition(bill_id#670, repay_time#692 DESC NULLS LAST, specifiedwindowframe(RowFrame, unboundedpreceding$(), currentrow$())) AS rn#5382], [bill_id#670], [repay_time#692 DESC NULLS LAST] : : +- *(9) Sort [bill_id#670 ASC NULLS FIRST, repay_time#692 DESC NULLS LAST], false, 0 : : +- Exchange hashpartitioning(bill_id#670, 200) : : +- *(8) Project [bill_id#670, repaid_principal#684, repay_time#692] : : +- *(8) Filter isnotnull(bill_id#670) : : +- *(8) FileScan parquet [bill_id#670,repaid_principal#684,repay_time#692] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [IsNotNull(bill_id)], ReadSchema: struct&lt;bill_id:string,repaid_principal:decimal(20,0),repay_time:timestamp&gt; : +- *(17) Sort [loan_id#5672 ASC NULLS FIRST], false, 0 : +- *(17) HashAggregate(keys=[loan_id#5672], functions=[first(write_off_date#4705, true)]) : +- *(17) HashAggregate(keys=[loan_id#5672], functions=[partial_first(write_off_date#4705, true)]) : +- *(17) Project [loan_id#5672, write_off_date#4705] : +- *(17) BroadcastHashJoin [bill_id#4714], [bill_id#670], LeftOuter, BuildRight : :- *(17) Project [loan_id#5672, write_off_date#4705, bill_id#4714] : : +- *(17) BroadcastHashJoin [loan_id#5672], [loan_id#4718], LeftOuter, BuildRight : : :- *(17) Project [loan_id#5672, write_off_date#4705] : : : +- *(17) BroadcastHashJoin [loan_id#5672], [loan_id#4708], LeftOuter, BuildRight : : : :- *(17) HashAggregate(keys=[loan_id#5672], functions=[min(CASE WHEN is_write_off_bill#4594 THEN write_off_date#4630 END)]) : : : : +- Exchange hashpartitioning(loan_id#5672, 200) : : : : +- *(13) HashAggregate(keys=[loan_id#5672], functions=[partial_min(CASE WHEN is_write_off_bill#4594 THEN write_off_date#4630 END)]) : : : : +- *(13) Project [loan_id#5672, (CASE WHEN isnotnull(CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END WHEN isnotnull(CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END ELSE 0 END &gt;= 91) AS is_write_off_bill#4594, date_add(cast(due_date#5686 as date), 91) AS write_off_date#4630] : : : : +- *(13) Filter (CASE WHEN isnotnull(CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 = OVERDUE) THEN datediff(18044, cast(due_date#5686 as date)) END WHEN isnotnull(CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END) THEN CASE WHEN (status#5676 IN (REBALANCED,REPAID) &amp;&amp; (cast(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date) as string) &gt; due_date#5686)) THEN datediff(cast(from_utc_timestamp(cast(from_unixtime(cast((cast(repay_time#5694L as double) / 1000.0) as bigint), yyyy-MM-dd HH:mm:ss, Some(UTC)) as timestamp), Asia/Ho_Chi_Minh) as date), cast(due_date#5686 as date)) END ELSE 0 END &gt;= 91) : : : : +- *(13) FileScan parquet [loan_id#5672,status#5676,due_date#5686,repay_time#5694L] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;loan_id:string,status:string,due_date:string,repay_time:bigint&gt; : : : +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[0, string, true])) : : : +- *(14) Project [id#392 AS loan_id#4708] : : : +- *(14) FileScan parquet [id#392] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;id:string&gt; : : +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[1, string, true])) : : +- *(15) Project [id#4717 AS bill_id#4714, loan_id#4718] : : +- *(15) FileScan parquet [id#4717,loan_id#4718] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;id:string,loan_id:string&gt; : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true])) : +- *(16) FileScan parquet [bill_id#670] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;bill_id:string&gt; +- *(33) Sort [write_off_date#4776 ASC NULLS FIRST], false, 0 +- Exchange hashpartitioning(write_off_date#4776, 200) +- *(32) Project [write_off_date#4776, total_write_off_principal#5986] +- Window [sum(write_off_principal#5982) windowspecdefinition(1, write_off_date#4776 ASC NULLS FIRST, specifiedwindowframe(RangeFrame, unboundedpreceding$(), currentrow$())) AS total_write_off_principal#5986], [1], [write_off_date#4776 ASC NULLS FIRST] +- *(31) Sort [1 ASC NULLS FIRST, write_off_date#4776 ASC NULLS FIRST], false, 0 +- Exchange hashpartitioning(1, 200) +- *(30) HashAggregate(keys=[write_off_date#4776], functions=[sum(write_off_principal#4779)]) +- Exchange hashpartitioning(write_off_date#4776, 200) +- *(29) HashAggregate(keys=[write_off_date#4776], functions=[partial_sum(write_off_principal#4779)]) +- SortAggregate(key=[loan_id#609], functions=[first(write_off_date#4705, true), first(amount#398, true), sum(CASE WHEN (isnotnull(repayment_date#4760) &amp;&amp; (repayment_date#4760 &lt; write_off_date#4705)) THEN repaid_principal#684 ELSE 0 END)]) +- SortAggregate(key=[loan_id#609], functions=[partial_first(write_off_date#4705, true), partial_first(amount#398, true), partial_sum(CASE WHEN (isnotnull(repayment_date#4760) &amp;&amp; (repayment_date#4760 &lt; write_off_date#4705)) THEN repaid_principal#684 ELSE 0 END)]) +- *(28) Sort [loan_id#609 ASC NULLS FIRST], false, 0 +- *(28) Project [loan_id#609, write_off_date#4705, amount#398, repaid_principal#684, cast(from_utc_timestamp(repay_time#692, Asia/Ho_Chi_Minh) as date) AS repayment_date#4760] +- *(28) BroadcastHashJoin [bill_id#4714], [bill_id#670], LeftOuter, BuildRight :- *(28) Project [loan_id#609, write_off_date#4705, amount#398, bill_id#4714] : +- *(28) BroadcastHashJoin [loan_id#609], [loan_id#4718], LeftOuter, BuildRight : :- *(28) Project [loan_id#609, write_off_date#4705, amount#398] : : +- *(28) BroadcastHashJoin [loan_id#609], [loan_id#4708], LeftOuter, BuildRight : : :- *(28) HashAggregate(keys=[loan_id#609], functions=[min(CASE WHEN is_write_off_bill#4594 THEN write_off_date#4630 END)]) : : : +- ReusedExchange [loan_id#609, min#6101], Exchange hashpartitioning(loan_id#5672, 200) : : +- BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[0, string, true])) : : +- *(25) Project [id#392 AS loan_id#4708, amount#398] : : +- *(25) FileScan parquet [id#392,amount#398] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;id:string,amount:string&gt; : +- ReusedExchange [bill_id#4714, loan_id#4718], BroadcastExchange HashedRelationBroadcastMode(ArrayBuffer(input[1, string, true])) +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, string, true])) +- *(27) Project [bill_id#670, repay_time#692, repaid_principal#684] +- *(27) FileScan parquet [bill_id#670,repaid_principal#684,repay_time#692] Batched: true, Format: Parquet, Location: InMemoryFileIndex[...], PartitionFilters: [], PushedFilters: [], ReadSchema: struct&lt;bill_id:string,repaid_principal:decimal(20,0),repay_time:timestamp&gt;","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Spark学习","slug":"Spark学习","permalink":"https://shang.at/tags/Spark学习/"}]},{"title":"数据结构学习笔记二-算法","slug":"数据结构学习笔记二-算法","date":"2019-05-16T09:54:29.000Z","updated":"2019-05-16T14:39:58.762Z","comments":true,"path":"post/数据结构学习笔记二-算法/","link":"","permalink":"https://shang.at/post/数据结构学习笔记二-算法/","excerpt":"","text":"递归二分查找哈希算法堆排序深度和广度优先搜索字符串匹配贪心算法##分治算法 回溯算法动态规划拓扑排序最短路径并行算法","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://shang.at/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shang.at/tags/算法/"}]},{"title":"Spark学习笔记-pivot透视图","slug":"Spark学习笔记-pivot透视图","date":"2019-05-09T02:52:07.000Z","updated":"2019-08-03T02:17:49.587Z","comments":true,"path":"post/Spark学习笔记-pivot透视图/","link":"","permalink":"https://shang.at/post/Spark学习笔记-pivot透视图/","excerpt":"","text":"df = spark.createDataFrame([ ('2018-01','项目1',100, 'xm'), ('2018-01','项目1',100, 'xl'), ('2018-01','项目1',100, 'xp'), ('2018-01','项目2',200, 'ch'), ('2018-01','项目3',300, 'xl'), ('2018-02','项目1',1000, 'xp'), ('2018-02','项目2',2000, 'xl'), ('2018-03','项目x',999, 'xm')], ['date','project','income', 'saler']) df.toPandas() date project income saler 0 2018-01 项目1 100 xm 1 2018-01 项目1 100 xl 2 2018-01 项目1 100 xp 3 2018-01 项目2 200 ch 4 2018-01 项目3 300 xl 5 2018-02 项目1 1000 xp 6 2018-02 项目2 2000 xl 7 2018-03 项目x 999 xm pivotdf_pivot = df.groupBy('date').pivot( 'project', ['项目1', '项目2', '项目3', '项目x']).agg( sum('income')).na.fill(0)df_pivot.toPandas() date 项目1 项目2 项目3 项目x 0 2018-03 0 0 0 999 1 2018-02 1000 2000 0 0 2 2018-01 300 200 300 0 df.groupBy('project').pivot( 'date').agg( sum('income')).na.fill(0).toPandas() project 2018-01 2018-02 2018-03 0 项目2 200 2000 0 1 项目x 0 0 999 2 项目1 300 1000 0 3 项目3 300 0 0 unpivotdf_pivot.selectExpr(\"date\", \"stack(4, '项目11', `项目1`, '项目22', `项目2`, '项目33', `项目3`, '项目xx', `项目x`) as (`project`,`income`)\")\\ .filter(\"income &gt; 0 \")\\ .orderBy([\"date\", \"project\"])\\ .toPandas() date project income 0 2018-01 项目11 300 1 2018-01 项目22 200 2 2018-01 项目33 300 3 2018-02 项目11 1000 4 2018-02 项目22 2000 5 2018-03 项目xx 999 stack(n, expr1, ..., exprk) 将k个[expr1, ..., exprk]拆解成n rows","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Spark学习","slug":"Spark学习","permalink":"https://shang.at/tags/Spark学习/"}]},{"title":"Spark学习笔记-tips","slug":"Spark学习笔记-tips","date":"2019-04-15T05:50:00.000Z","updated":"2019-08-03T02:17:49.589Z","comments":true,"path":"post/Spark学习笔记-tips/","link":"","permalink":"https://shang.at/post/Spark学习笔记-tips/","excerpt":"","text":"写spark dataframe的时候，最好用哪些字段就取哪些字段，否则spark会默认把所有字段都读进内存，如果进行cache操作，就会无故占用大量内存 没有被明确select的字段依然可以作为filter的条件 获取周的第一天日期和当前日期位于周的第几天，周的第一天定义不同 周日 周一 Spark Shuffle spill (Memory) and (Disk) on SPARK UI? What do they mean? https://community.hortonworks.com/questions/202809/spark-shuffle-spill-memory.html 窗口函数会引起重分区吗？分区数(200)是固定的吗？ test_df = kreditpintar.spark.range(0, end=100, numPartitions=5).toDF(&apos;input&apos;)test_df.rdd.getNumPartitions() # 5test_1_df = test_df.withColumn(&apos;id&apos;, row_number().over(Window.partitionBy(lit(1)).orderBy(&apos;input&apos;)))test_1_df.rdd.getNumPartitions() # 200test_2_df = test_df.withColumn(&apos;id&apos;, monotonically_increasing_id())test_2_df.rdd.getNumPartitions() # 5 通过withColumn(‘group’, lit(‘aaaabbb’))添加的新列，不能最为后续的join操作的condition expression？ groupBy 和 窗口函数的实现原理 哪一个效率更高 groupby 、窗口函数、distinct三种方式去重 哪个效率高 distinct&gt;groupby&gt;窗口函数 循环的去跑脚本，然后union每次循环的结果。 这样的使用 task可能会失败，需要优化 转化long列类型到时间戳，保留毫秒信息 a_df = spark.createDataFrame([[1556613225852]], ['a'])a_df.select((col('a')/1000.0).cast('timestamp')).toPandas()#CAST((a / 1000.0) AS TIMESTAMP)#0 2019-04-30 08:33:45.852 spark进行计算的过程中间检查数据没有问题，但是执行collect后出现数据不一致的情况(丢失数据和union后的数据重复)","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Spark学习","slug":"Spark学习","permalink":"https://shang.at/tags/Spark学习/"}]},{"title":"BI工具使用之Tableau一","slug":"BI工具使用之Tableau一","date":"2019-04-11T07:08:39.000Z","updated":"2019-05-12T00:22:00.389Z","comments":true,"path":"post/BI工具使用之Tableau一/","link":"","permalink":"https://shang.at/post/BI工具使用之Tableau一/","excerpt":"","text":"","categories":[{"name":"BI","slug":"BI","permalink":"https://shang.at/categories/BI/"}],"tags":[{"name":"Tableau","slug":"Tableau","permalink":"https://shang.at/tags/Tableau/"}]},{"title":"Spark学习笔记-DSL语法","slug":"Spark学习笔记-DSL语法","date":"2019-03-31T02:20:06.000Z","updated":"2019-03-31T02:21:41.762Z","comments":true,"path":"post/Spark学习笔记-DSL语法/","link":"","permalink":"https://shang.at/post/Spark学习笔记-DSL语法/","excerpt":"","text":"","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"sparkSql-DSL语法","slug":"sparkSql-DSL语法","permalink":"https://shang.at/tags/sparkSql-DSL语法/"}]},{"title":"数据结构与算法学习笔记-排序算法","slug":"数据结构与算法学习笔记-排序算法","date":"2019-03-29T00:49:58.000Z","updated":"2019-05-12T00:22:00.390Z","comments":true,"path":"post/数据结构与算法学习笔记-排序算法/","link":"","permalink":"https://shang.at/post/数据结构与算法学习笔记-排序算法/","excerpt":"","text":"O(n^2)冒泡排序(Bubble Sort) 算法描述 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否符合大小关系要求。如果不满足就互换位置。一次冒泡至少会让一个元素移动到它应该在的位置，重复n次，就完成了n个元素的排序工作。 算法实现 def bubble_sort(nums): \"\"\" 冒泡排序：从小到大 :param nums: :return: \"\"\" if len(nums) &lt;= 1: return nums for i in range(len(nums) - 1): for j in range(i + 1, len(nums)): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] return nums def bubble_sort1(nums): if len(nums) &lt;= 1: return nums for i in range(len(nums) - 1): for j in range(len(nums) - 1 - i): if nums[j] &gt; nums[j + i]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return numsif __name__ == '__main__': nums = [-23, 0, 6, -4, 34] print(bubble_sort(nums)) 插入排序 算法描述 将一个元素插入一个已经有序的序列，使其依然有序。首先，将原始的序列分为两个子序列，有序的和无序的，然后，从无序的序列中依次拿出一个元素，插入到有序的序列的合适位置，并保持有序的序列依然有序，直到无序的序列中没有元素了。 算法实现 def insert_sort(nums): if len(nums) &lt;= 1: return nums for i in range(1, len(nums)): tmp = nums[i] j = i - 1 for j in range(i - 1, -1, -1): if tmp &lt; nums[j]: nums[j + 1] = nums[j] else: break nums[j + 1] = tmp return nums if __name__ == '__main__': nums = [-23, 0, 6, -4, 34, 2] print(insert_sort(nums)) 选择排序 算法描述 选择排序是选择无序序列中的最小的元素放到有序序列的末尾，直到无序序列没有元素。 算法实现 def selection_sort(nums): if len(nums) &lt;= 1: return nums for i in range(len(nums) - 1): min_val = nums[i] min_j = i for j in range(i + 1, len(nums)): if min_val &gt; nums[j]: min_val = nums[j] min_j = j nums[i], nums[min_j] = nums[min_j], nums[i] return numsif __name__ == '__main__': nums = [-23, 0, 6, -4, 34, 2] print(selection_sort(nums)) 希尔排序 算法描述 希尔排序是对插入排序的优化。希尔排序，通过将原始序列按照一定的步长划分为多个子序列 将原始的一维数组映射成二维数组， 然后按列进行插入排序，这样的话，可以让一个元素在一次比较中跨越较大的区间，随后算法在使用较小的步长，一直到步长为1(已知当对有序度较高数组进行排序时，插入排序的时间复杂度接近O(N)，因此可以大幅度提高插入排序的效率)。 常见的步长选择有 算法实现 def shell_sort(list): n = len(list) # 初始步长 gap = n // 2 while gap &gt; 0: print(gap) for i in range(gap, n): # 每个步长进行插入排序 temp = list[i] j = i # 插入排序 while j &gt;= gap and list[j - gap] &gt; temp: list[j] = list[j - gap] j -= gap print('inner=', list) list[j] = temp print(list) # 得到新的步长 gap = gap // 2 return listdef shell_sort1(collection): # Marcin Ciura's gap sequence gaps = [701, 301, 132, 57, 23, 10, 4, 1] for gap in gaps: i = gap while i &lt; len(collection): temp = collection[i] j = i while j &gt;= gap and collection[j - gap] &gt; temp: collection[j] = collection[j - gap] j -= gap collection[j] = temp i += 1 return collectionif __name__ == '__main__': nums = [-23, 0, 6, -4, 34, 2] print('\\n', shell_sort1(nums)) O(nlogn)归并排序 算法描述 将数组分为两部分，分别排序，最后将两部分排好序的数组合并成一个有序的数组。利用递归的方式，重复上述过程。 算法实现 def merge_sort(nums): print('before=', nums) length = len(nums) if length &gt; 1: midpoint = length // 2 left_half = merge_sort(nums[:midpoint]) right_half = merge_sort(nums[midpoint:]) i = 0 j = 0 k = 0 left_length = len(left_half) right_length = len(right_half) while i &lt; left_length and j &lt; right_length: if left_half[i] &lt; right_half[j]: nums[k] = left_half[i] i += 1 else: nums[k] = right_half[j] j += 1 k += 1 while i &lt; left_length: nums[k] = left_half[i] i += 1 k += 1 while j &lt; right_length: nums[k] = right_half[j] j += 1 k += 1 print('after=', nums) return numsif __name__ == '__main__': nums = [-23, 0, 6, -4, 34, 2] print('\\n', merge_sort(nums)) 快速排序 算法描述 随机选择一个pivot节点，然后将少数组中的数据分成大于pivot和小于pivot的两部分，然后递归地将大于pivot和小于pivot的部分再按照相同的思路处理，直到每个pivot两端的部分都只有最多一个元素 算法实现 def quick_sort(collection): length = len(collection) if length &lt;= 1: return collection else: pivot = collection[0] greater = [element for element in collection[1:] if element &gt; pivot] lesser = [element for element in collection[1:] if element &lt;= pivot] return quick_sort(lesser) + [pivot] + quick_sort(greater) O(n) 时间复杂度内求无序数组中的第 K 大元素 # 选择数组的最后一个元素，作为pivot，然后将数组的所有元素分为大于pivot和小于pivot的两部分，# 如果 len(lesser) == k - 1，则返回pivot# 如果 len(lesser) &gt;= k，则说明要查找的元素在小于pivot的部分，那么继续在lesser中查找# 否则的话，说明要查找的元素在大于pivot的部分，那么继续在greater中查找def find_k_max(nums, k): length = len(nums) if length &lt; k: return None pivot = nums[length - 1] greater = [element for element in nums[:length - 1] if element &gt; pivot] lesser = [element for element in nums[:length - 1] if element &lt;= pivot] if len(lesser) == k - 1: return pivot elif len(lesser) &gt;= k: return find_k_max(lesser, k) else: return find_k_max(greater, k - len(lesser) - 1) 堆排序 算法描述 算法实现 O(n)计数排序 算法描述 算法实现 基数排序 算法描述 算法实现 桶排序 算法描述 算法实现 总结 排序算法 时间复杂度 空间复杂度 稳定性 是否基于比较 冒泡排序 O($$n^2$$) O(1) 是 是 选择排序 O($$n^2$$) O(1) 否 是 插入排序 O($$n^2$$) O(1) 是 是 希尔排序 O($$nlog^2n$$) O(1) 是 是 归并排序 O($$nlogn$$) O(n) 是 是 快速排序 O($$nlogn$$) O(1) 否 是 堆排序 O($$nlogn$$) 是 计数排序 O($$n$$) 否 计数排序 O($$n$$) 否 桶排序 O($$n$$) 否","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://shang.at/categories/数据结构与算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://shang.at/tags/排序算法/"}]},{"title":"数据分析-reduce函数引发的","slug":"数据分析-reduce函数引发的","date":"2019-03-28T05:35:25.000Z","updated":"2019-04-10T15:36:43.244Z","comments":true,"path":"post/数据分析-reduce函数引发的/","link":"","permalink":"https://shang.at/post/数据分析-reduce函数引发的/","excerpt":"","text":"reduce in python# _functools.reducedef reduce(function, sequence, initial=None): \"\"\" reduce(function, sequence[, initial]) -&gt; value Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. :param function:给定的一个func，func具有两个参数，参数1是临时聚合值，参数2是序列中下一个待聚合的值 :param sequence:待处理的可迭代的序列 :param initial:聚合数据的初始值 \"\"\" pass 工作原理：reduce函数对给定的序列遍历调用func函数，每次调用返回一个临时聚合值，直到整个序列遍历结束。如果设置了初始值，那么在第一次执行func函数的时候，会将func的参数1设置为初始值。 例子： &gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])15&gt;&gt;&gt; reduce(lambda x, y: x+y, [1, 2, 3, 4, 5], 100)115&gt;&gt;&gt; reduce(lambda x, y: str(x)+str(y), [1, 2, 3, 4, 5], '')'12345' reduce函数不仅可以完成这种聚合的功能，还可以完成更加复杂的操作， reduce&amp;foldLeft&amp;foldRight&amp;reduce in scala### hive的UDAFspark的UDAF","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://shang.at/categories/数据分析/"}],"tags":[{"name":"reduce","slug":"reduce","permalink":"https://shang.at/tags/reduce/"},{"name":"数据分析技巧","slug":"数据分析技巧","permalink":"https://shang.at/tags/数据分析技巧/"},{"name":"有初始值的聚合操作","slug":"有初始值的聚合操作","permalink":"https://shang.at/tags/有初始值的聚合操作/"}]},{"title":"信贷数据统计的相关指标","slug":"信贷数据统计的相关指标","date":"2019-03-22T11:19:47.000Z","updated":"2019-03-28T14:24:24.845Z","comments":true,"path":"post/信贷数据统计的相关指标/","link":"","permalink":"https://shang.at/post/信贷数据统计的相关指标/","excerpt":"","text":"贷款类型 等额本息贷款 根据固定的还款时间，计算出应还的总利息，再加上本金，然后每个月平均等额的还款。 等额本金贷款 等额本金相对来说要简单一些，每月所还的本金是相同的，利息由每个月的剩余本金计算得出。 固定点数贷款 按照定义，我们在首次还款时先按固定的点数还一部分贷款，然后再按较低的利率还完剩余的贷款。 双利率贷款 前x个月以较低的r1利率还款，后m-x个月以较高的r2利率还款（假设还款总月数为m） 相关指标 同比增长 环比增长","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://shang.at/categories/数据分析/"}],"tags":[{"name":"分析指标","slug":"分析指标","permalink":"https://shang.at/tags/分析指标/"}]},{"title":"airflow安装","slug":"airflow安装","date":"2019-03-19T11:24:02.000Z","updated":"2019-03-24T01:33:47.230Z","comments":true,"path":"post/airflow安装/","link":"","permalink":"https://shang.at/post/airflow安装/","excerpt":"","text":"# airflow needs a home, ~/airflow is the default,# but you can lay foundation somewhere else if you prefer# (optional)export AIRFLOW_HOME=~/airflow# install from pypi using pippip install apache-airflow# initialize the databaseairflow initdb# start the web server, default port is 8080airflow webserver -p 8080# start the schedulerairflow scheduler# visit localhost:8080 in the browser and enable the example dag in the home page USE Mysqlvim $AIRFLOW_HOME/airflow.cfg sql_alchemy_conn = mysql+pymysql://root:123456@localhost:3306/airflow 需要pip install pymysql 启动失败ERROR [airflow.models.DagBag] Failed to import: /anaconda3/lib/python3.7/site-packages/airflow/example_dags/example_http_operator.pyTraceback (most recent call last): File &quot;/anaconda3/lib/python3.7/site-packages/airflow/models.py&quot;, line 374, in process_file m = imp.load_source(mod_name, filepath) File &quot;/anaconda3/lib/python3.7/imp.py&quot;, line 171, in load_source module = _load(spec) File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 696, in _load File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 677, in _load_unlocked File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 728, in exec_module File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed File &quot;/anaconda3/lib/python3.7/site-packages/airflow/example_dags/example_http_operator.py&quot;, line 27, in &lt;module&gt; from airflow.operators.http_operator import SimpleHttpOperator File &quot;/anaconda3/lib/python3.7/site-packages/airflow/operators/http_operator.py&quot;, line 21, in &lt;module&gt; from airflow.hooks.http_hook import HttpHook File &quot;/anaconda3/lib/python3.7/site-packages/airflow/hooks/http_hook.py&quot;, line 23, in &lt;module&gt; import tenacity File &quot;/anaconda3/lib/python3.7/site-packages/tenacity/__init__.py&quot;, line 352 from tenacity.async import AsyncRetrying ^SyntaxError: invalid syntax 修复方式：修改from tenacity.async import AsyncRetrying为from tenacity.async_a import AsyncRetrying，同时tenacity包下的async文件名为async_a","categories":[],"tags":[]},{"title":"Spark学习笔记-抽样方法和自增ID","slug":"Spark学习笔记-抽样方法和自增ID","date":"2019-03-19T08:33:24.000Z","updated":"2019-03-24T01:33:47.229Z","comments":true,"path":"post/Spark学习笔记-抽样方法和自增ID/","link":"","permalink":"https://shang.at/post/Spark学习笔记-抽样方法和自增ID/","excerpt":"","text":"抽样方法sample(withReplacement=None, fraction=None, seed=None) Returns a sampled subset of this DataFrame. withReplacement – Sample with replacement or not (default False). true时会将抽样的数据放回数据集，导致抽样数据有重复的 false时不会放回 fraction – Fraction of rows to generate, range [0.0, 1.0]. 表示子集占数据集的占比 seed – Seed for sampling (default a random seed). fraction并不能保证完全按照占比抽样数据 自增IDmonotonically_increasing_id() 每个分区分别排序生成一个64位的整数，但不是连续的。会将分区值放到高31位，然后将每条记录的序列放到低33位。限制：分区数不能大于10亿，每个分区的数据量不能大于80亿。","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Spark学习","slug":"Spark学习","permalink":"https://shang.at/tags/Spark学习/"}]},{"title":"Spark学习笔记-SparkSQL内置函数","slug":"Spark学习笔记-SparkSQL内置函数","date":"2019-03-19T01:27:01.000Z","updated":"2019-04-10T15:36:43.243Z","comments":true,"path":"post/Spark学习笔记-SparkSQL内置函数/","link":"","permalink":"https://shang.at/post/Spark学习笔记-SparkSQL内置函数/","excerpt":"","text":"学习SparkSQL中的一些内置函数 日期函数 获取默认时区 spark.conf.get('spark.sql.session.timeZone')&gt;&gt; 'Asia/Shanghai' 获取当前时间 获取当前日期：current_date() spark.sql(\"\"\" select current_date()\"\"\").toPandas()&gt;&gt; 2019-03-19 获取当前时间：current_timestamp()/now() spark.sql(\"\"\" select current_timestamp()\"\"\").toPandas()&gt;&gt; 2019-03-19 13:54:22.236 从日期中截取字段 截取年月日、时分秒:year,month,day/dayofmonth,hour,minute,second dayofweek ,dayofyear 1 = Sunday, 2 = Monday, ..., 7 = Saturday weekofyear Extract the week number of a given date as integer. trunc截取某部分的日期，其他部分默认为01 Returns date truncated to the unit specified by the format.Parameters: format – ‘year’, ‘yyyy’, ‘yy’ or ‘month’, ‘mon’, ‘mm’ date_trunc [“YEAR”, “YYYY”, “YY”, “MON”, “MONTH”, “MM”, “DAY”, “DD”, “HOUR”, “MINUTE”, “SECOND”, “WEEK”, “QUARTER”] Returns timestamp truncated to the unit specified by the format.Parameters: format – ‘year’, ‘yyyy’, ‘yy’, ‘month’, ‘mon’, ‘mm’, ‘day’, ‘dd’, ‘hour’, ‘minute’, ‘second’, ‘week’, ‘quarter’ date_format将时间转化为某种格式的字符串 Converts a date/timestamp/string to a value of string in the format specified by the date format given by the second argument.A pattern could be for instance dd.MM.yyyy and could return a string like ‘18.03.1993’. All pattern letters of the Java class java.text.SimpleDateFormat can be used. 日期时间转换 unix_timestamp返回当前时间的unix时间戳 Convert time string with given pattern (‘yyyy-MM-dd HH:mm:ss’, by default) to Unix time stamp (in seconds), using the default timezone and the default locale, return null if fail.if timestamp is None, then it returns current timestamp. from_unixtime将时间戳换算成当前时间，to_unix_timestamp将时间转化为时间戳 Converts the number of seconds from unix epoch (1970-01-01 00:00:00 UTC) to a string representing the timestamp of that moment in the current system time zone in the given format. to_date/date将字符串转化为日期格式，to_timestamp（Since: 2.2.0） Converts a Column of pyspark.sql.types.StringType or pyspark.sql.types.TimestampType into pyspark.sql.types.DateType using the optionally specified format. Specify formats according to SimpleDateFormats. By default, it follows casting rules to pyspark.sql.types.DateType if the format is omitted (equivalent to col.cast(&quot;date&quot;)).Converts a Column of pyspark.sql.types.StringType or pyspark.sql.types.TimestampType into pyspark.sql.types.DateType using the optionally specified format. Specify formats according to SimpleDateFormats. By default, it follows casting rules to pyspark.sql.types.TimestampType if the format is omitted (equivalent to col.cast(&quot;timestamp&quot;)). quarter 将1年4等分(range 1 to 4) Extract the quarter of a given date as integer. 日期、时间计算 months_between两个日期之间的月数 add_months返回日期后n个月后的日期 last_day(date),next_day(start_date, day_of_week) date_add,date_sub(减) datediff（两个日期间的天数） utc 在集群中对于时间戳的转换，如果不指定时区，默认会采用集群配置的时区，集群默认时区可以通过如下方式获取：spark.conf.get(‘spark.sql.session.timeZone’)。一般而言，这个值应该是集群统一设置，独立提交job的时候，不需要设置。 to_utc_timestamp(timestamp, tz) 将timestamp按照给定的tz解释，返回utc timestamp from_utc_timestamp(timestamp, tz) 将timestamp按照utc解释，返回给定tz的timestamp 对于有时区相关的数据统计时，需要注意。比如：集群默认时区设置为UTC，一般将数据存到集群中的时候会将时间戳转为utc timestamp以便后续的操作。此时如果有一个需求是统计北京时间的当天的数据，那么第一个想到的方式是使用current_date()获取当前日期，然后将数据中的时间戳使用to_date(from_utc_timestamp(from_unixtime(ts), ‘Asia/Beijing’))，然后进行比较。但是current_date()获取的日期，是根据集群默认时区得来的，因此会有时区的不同导致的数据统计错误，因此，这种情况不能直接使用current_date()，正确的使用方式是：to_date(from_utc_timestamp(current_timestamp(), ‘Asia/Beijing’))，然后在进行比较。 表关联 Join(other, on=None, how=None) on：a string for the join column name, a list of column names, a join expression (Column), or a list of Columns. If on is a string or a list of strings indicating the name of the join column(s), the column(s) must exist on both sides, and this performs an equi-join. how：str, default inner. Must be one of: inner, cross, outer, full, full_outer, left, left_outer, right, right_outer, left_semi, and left_anti inner:内连，返回joinDF1和joinDF2合并的rows，如果joinDF2中有多条记录对应于joinDF1的同一条记录，那么返回的row number会大于joinDF1的row number outer,full,full_outer：全连 left, left_outer：左连 right，right_outer:右连 left_semi：过滤出joinDF1中和joinDF2共有的部分，只返回joinDF1中的rows left_anti：过滤出joinDF1中joinDF2没有的部分，只返回joinDF1中的rows crossJoin(other) 返回两个DF的笛卡尔积 Parses the expression expr 将字符串表示的表达式，翻译成DSL expr(\"length(name)\")expr(\"array_contains(user_id_set, user_id)\")","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"sparkSql内置函数","slug":"sparkSql内置函数","permalink":"https://shang.at/tags/sparkSql内置函数/"}]},{"title":"数据分析小知识点","slug":"数据分析小知识点","date":"2019-03-19T01:25:56.000Z","updated":"2019-08-03T02:17:49.591Z","comments":true,"path":"post/数据分析小知识点/","link":"","permalink":"https://shang.at/post/数据分析小知识点/","excerpt":"","text":"总结一下在数据分析中需要注意的一些tips，持续更新 Tip1 时区在进行跨境业务处理的时候，时区的控制是十分必要的。平时对于国内的业务，部署在国内的服务器，使用的时区一般都是北京时间(北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间)，在数据库中一般存储相对于unix epoch (1970-01-01 00:00:00 UTC)的毫秒时间戳，做某个地区的数据统计时，需要将时间戳转换成当地的时间(即加一个时区的属性) https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431937554888869fb52b812243dda6103214cd61d0c2000 Tip 2 Excel函数 去重计数：SUMPRODUCT(1/COUNTIF(A2:A20,A2:A20)) VLOOKUP(要查找的值,查找返回,返回查找到的第几列,是否精确查找[1]) 概念落地页，也称：着陆页、引导页，是指访问者在其他地方看到发出的某个具有明确主题的特定营销活动——通过Email、社交媒体或广告发布的诱人优惠信息等，点击后被链接到你网站上的第一个页面 PRD：产品需求文档，产品需求文档是将商业需求文档（BRD）和市场需求文档（MRD）用更加专业的语言进行描述","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://shang.at/categories/数据分析/"}],"tags":[{"name":"数据分析Tips","slug":"数据分析Tips","permalink":"https://shang.at/tags/数据分析Tips/"}]},{"title":"Spark学习笔记-窗口函数","slug":"Spark学习笔记-窗口函数","date":"2019-03-12T02:15:03.000Z","updated":"2019-03-24T01:33:47.229Z","comments":true,"path":"post/Spark学习笔记-窗口函数/","link":"","permalink":"https://shang.at/post/Spark学习笔记-窗口函数/","excerpt":"","text":"from pyspark.sql import SparkSessionfrom pyspark.sql.functions import *from pyspark.sql import Windowfrom pyspark.sql.types import StructType, StringType, StructField, IntegerTypeschema = StructType([ StructField('shop_id', StringType()), StructField('date', StringType()), StructField('amount', IntegerType())]) spark = SparkSession \\ .builder \\ .master('local[*]') \\ .enableHiveSupport() \\ .getOrCreate() data = [ &#123;'shop_id': '10006', 'date': '201501120030', 'amount': 2313&#125;, &#123;'shop_id': '10006', 'date': '201501120100', 'amount': 23112&#125;, &#123;'shop_id': '10006', 'date': '201501120130', 'amount': 23112&#125;, &#123;'shop_id': '10006', 'date': '201501120200', 'amount': 24234&#125;, &#123;'shop_id': '10006', 'date': '201501120230', 'amount': 132&#125;, &#123;'shop_id': '10006', 'date': '201501120300', 'amount': 31232&#125;, &#123;'shop_id': '10006', 'date': '201501120330', 'amount': 221313&#125;, &#123;'shop_id': '10006', 'date': '201501120400', 'amount': 2134&#125;, &#123;'shop_id': '10006', 'date': '201501120430', 'amount': 2231&#125;, &#123;'shop_id': '10006', 'date': '201501120500', 'amount': 2234&#125;, &#123;'shop_id': '10006', 'date': '201501120530', 'amount': 2234&#125;, &#123;'shop_id': '10006', 'date': '201501120600', 'amount': 231635&#125;, &#123;'shop_id': '10006', 'date': '201501120630', 'amount': 2536&#125;, &#123;'shop_id': '10006', 'date': '201501120700', 'amount': 425432&#125;, &#123;'shop_id': '10006', 'date': '201501120730', 'amount': 36362&#125;, &#123;'shop_id': '10006', 'date': '201501120800', 'amount': 5645622&#125;, &#123;'shop_id': '10006', 'date': '201501120830', 'amount': 34532&#125;, &#123;'shop_id': '10006', 'date': '201501120900', 'amount': 366642&#125;, &#123;'shop_id': '10006', 'date': '201501120930', 'amount': 74632&#125;, &#123;'shop_id': '10006', 'date': '201501121000', 'amount': 63562&#125;, &#123;'shop_id': '10006', 'date': '201501121030', 'amount': 26353&#125;, &#123;'shop_id': '10006', 'date': '201501121100', 'amount': 2353&#125;, &#123;'shop_id': '10006', 'date': '201501121130', 'amount': 26352&#125;, &#123;'shop_id': '10006', 'date': '201501121200', 'amount': 254352&#125;, &#123;'shop_id': '10006', 'date': '201501121230', 'amount': 534236&#125;, &#123;'shop_id': '10006', 'date': '201501121300', 'amount': 35432&#125;, &#123;'shop_id': '10006', 'date': '201501121330', 'amount': 353462&#125;, &#123;'shop_id': '10006', 'date': '201501121400', 'amount': 64562&#125;, &#123;'shop_id': '10006', 'date': '201501121430', 'amount': 652562&#125;, &#123;'shop_id': '10006', 'date': '201501121500', 'amount': 2456&#125;, &#123;'shop_id': '10006', 'date': '201501121530', 'amount': 6422&#125;, &#123;'shop_id': '10006', 'date': '201501121600', 'amount': 422&#125;, &#123;'shop_id': '10006', 'date': '201501121630', 'amount': 27843&#125;, &#123;'shop_id': '10006', 'date': '201501121700', 'amount': 2362&#125;, &#123;'shop_id': '10006', 'date': '201501121730', 'amount': 24683&#125;, &#123;'shop_id': '10006', 'date': '201501121800', 'amount': 4532&#125;, &#123;'shop_id': '10006', 'date': '201501121830', 'amount': 5342&#125;, &#123;'shop_id': '10006', 'date': '201501121900', 'amount': 65642&#125;, &#123;'shop_id': '10006', 'date': '201501121930', 'amount': 2534&#125;, &#123;'shop_id': '10006', 'date': '201501122000', 'amount': 25376&#125;, &#123;'shop_id': '10006', 'date': '201501122030', 'amount': 242443&#125;, &#123;'shop_id': '10006', 'date': '201501122100', 'amount': 2344562&#125;, &#123;'shop_id': '10006', 'date': '201501122130', 'amount': 5462&#125;, &#123;'shop_id': '10006', 'date': '201501122200', 'amount': 2535&#125;, &#123;'shop_id': '10006', 'date': '201501122230', 'amount': 242546&#125;, &#123;'shop_id': '10006', 'date': '201501122300', 'amount': 6542&#125;, &#123;'shop_id': '10006', 'date': '201501122330', 'amount': 2546&#125;, &#123;'shop_id': '10006', 'date': '201501130000', 'amount': 45245&#125;, ] df = spark.createDataFrame(data, schema) df.printSchema() root |-- shop_id: string (nullable = true) |-- date: string (nullable = true) |-- amount: integer (nullable = true) 关于子窗口： 子窗口需要指定一个边界，有以下两种方式： ROWS between CURRENT ROW | UNBOUNDED PRECEDING | [num] PRECEDING AND UNBOUNDED FOLLOWING | [num] FOLLOWING| CURRENT ROW RANGE between [num] PRECEDING AND [num] FOLLOWING 窗口的含义 ROWS是物理窗口，从行数上控制窗口的尺寸的；RANGE是逻辑窗口，从列值上控制窗口的尺寸 通常会结合order by子句使用，如果在order by子句后面没有指定窗口子句，则默认为：rows between unbounded preceding and current row spark中关于Window函数的学习在spark中涉及Window函数的主要有以下两个类和一个Column的方法pyspark.sql.column.Column#over 在窗口上应用某一种分析函数pyspark.sql.window.Window 创建WindowSpec的工具类 pyspark.sql.window.Window.unboundedPreceding pyspark.sql.window.Window.unboundedFollowing pyspark.sql.window.Window.currentRow pyspark.sql.window.Window#partitionBy pyspark.sql.window.Window#orderBy pyspark.sql.window.Window#rowsBetween(start, end) pyspark.sql.window.Window#rangeBetween(start, end)pyspark.sql.window.WindowSpec 窗口的规范pyspark.sql.window.Window#rowsBetween(start, end)定义窗口的边界，[start, end]，在边界处是闭区间start和end都是相对于当前row的相对位置，例如：- 0：当前row- -1：当前行的前1row- 5：当前行的后5row- (-1, 5)：窗口的范围为，当前row+当前行的前1row+当前行的后5row = 7rows df.show(50) +-------+------------+-------+|shop_id| date| amount|+-------+------------+-------+| 10006|201501120030| 2313|| 10006|201501120100| 23112|| 10006|201501120130| 2342|| 10006|201501120200| 24234|| 10006|201501120230| 132|| 10006|201501120300| 31232|| 10006|201501120330| 221313|| 10006|201501120400| 2134|| 10006|201501120430| 2231|| 10006|201501120500| 2234|| 10006|201501120530| 2234|| 10006|201501120600| 231635|| 10006|201501120630| 2536|| 10006|201501120700| 425432|| 10006|201501120730| 36362|| 10006|201501120800|5645622|| 10006|201501120830| 34532|| 10006|201501120900| 366642|| 10006|201501120930| 74632|| 10006|201501121000| 63562|| 10006|201501121030| 26353|| 10006|201501121100| 2353|| 10006|201501121130| 26352|| 10006|201501121200| 254352|| 10006|201501121230| 534236|| 10006|201501121300| 35432|| 10006|201501121330| 353462|| 10006|201501121400| 64562|| 10006|201501121430| 652562|| 10006|201501121500| 2456|| 10006|201501121530| 6422|| 10006|201501121600| 422|| 10006|201501121630| 27843|| 10006|201501121700| 2362|| 10006|201501121730| 24683|| 10006|201501121800| 4532|| 10006|201501121830| 5342|| 10006|201501121900| 65642|| 10006|201501121930| 2534|| 10006|201501122000| 25376|| 10006|201501122030| 242443|| 10006|201501122100|2344562|| 10006|201501122130| 5462|| 10006|201501122200| 2535|| 10006|201501122230| 242546|| 10006|201501122300| 6542|| 10006|201501122330| 2546|| 10006|201501130000| 45245|+-------+------------+-------+ 1.统计截止到当前时间段的店铺累计销售金额 df.withColumn( 't_amount', sum('amount').over(Window.partitionBy('shop_id').orderBy(asc('date')))).select( 'shop_id', 'date', 't_amount').show(50, truncate=False) +-------+------------+--------+|shop_id|date |t_amount|+-------+------------+--------+|10006 |201501120030|2313 ||10006 |201501120100|25425 ||10006 |201501120130|27767 ||10006 |201501120200|52001 ||10006 |201501120230|52133 ||10006 |201501120300|83365 ||10006 |201501120330|304678 ||10006 |201501120400|306812 ||10006 |201501120430|309043 ||10006 |201501120500|311277 ||10006 |201501120530|313511 ||10006 |201501120600|545146 ||10006 |201501120630|547682 ||10006 |201501120700|973114 ||10006 |201501120730|1009476 ||10006 |201501120800|6655098 ||10006 |201501120830|6689630 ||10006 |201501120900|7056272 ||10006 |201501120930|7130904 ||10006 |201501121000|7194466 ||10006 |201501121030|7220819 ||10006 |201501121100|7223172 ||10006 |201501121130|7249524 ||10006 |201501121200|7503876 ||10006 |201501121230|8038112 ||10006 |201501121300|8073544 ||10006 |201501121330|8427006 ||10006 |201501121400|8491568 ||10006 |201501121430|9144130 ||10006 |201501121500|9146586 ||10006 |201501121530|9153008 ||10006 |201501121600|9153430 ||10006 |201501121630|9181273 ||10006 |201501121700|9183635 ||10006 |201501121730|9208318 ||10006 |201501121800|9212850 ||10006 |201501121830|9218192 ||10006 |201501121900|9283834 ||10006 |201501121930|9286368 ||10006 |201501122000|9311744 ||10006 |201501122030|9554187 ||10006 |201501122100|11898749||10006 |201501122130|11904211||10006 |201501122200|11906746||10006 |201501122230|12149292||10006 |201501122300|12155834||10006 |201501122330|12158380||10006 |201501130000|12203625|+-------+------------+--------+ 分析：根据shop_id分组，根据date正序排列，由于orderBy后面没有追加rowsBetween()，则默认的rowsBetween为：[Window.unboundedPreceding，Window.currentRow]。即会统计根据date排序后，从第一行计算到当前行，从而达到了统计截止到当前时间段的店铺累计销售金额的效果 2.统计每个时间段的销售占比 df.withColumn( 't_amount', col('amount')/sum('amount').over(Window.partitionBy('shop_id'))).select( 'shop_id', 'date', 'amount','t_amount').show(50, truncate=False) +-------+------------+-------+---------------------+|shop_id|date |amount |t_amount |+-------+------------+-------+---------------------+|10006 |201501120030|2313 |1.8953384752481333E-4||10006 |201501120100|23112 |0.0018938635036720647||10006 |201501120130|2342 |1.919101906195905E-4 ||10006 |201501120200|24234 |0.0019858033985803397||10006 |201501120230|132 |1.0816458224502965E-5||10006 |201501120300|31232 |0.002559239570209671 ||10006 |201501120330|221313 |0.01813502135635928 ||10006 |201501120400|2134 |1.748660746294646E-4 ||10006 |201501120430|2231 |1.8281453256716753E-4||10006 |201501120500|2234 |1.8306036116317898E-4||10006 |201501120530|2234 |1.8306036116317898E-4||10006 |201501120600|231635 |0.018980835612369275 ||10006 |201501120630|2536 |2.0780710649499637E-4||10006 |201501120700|425432 |0.03486111708611171 ||10006 |201501120730|36362 |0.0029796064693892186||10006 |201501120800|5645622|0.46261844329041574 ||10006 |201501120830|34532 |0.0028296510258222453||10006 |201501120900|366642 |0.030043696032941034 ||10006 |201501120930|74632 |0.006115559925841707 ||10006 |201501121000|63562 |0.005208452406559526 ||10006 |201501121030|26353 |0.0021594403302297475||10006 |201501121100|2353 |1.9281156213829908E-4||10006 |201501121130|26352 |0.00215935838736441 ||10006 |201501121200|254352 |0.02084233168423317 ||10006 |201501121230|534236 |0.04377682860625429 ||10006 |201501121300|35432 |0.0029033996046256747||10006 |201501121330|353462 |0.028963689067797477 ||10006 |201501121400|64562 |0.00529039527189667 ||10006 |201501121430|652562 |0.05347280009013715 ||10006 |201501121500|2456 |2.0125167726802487E-4||10006 |201501121530|6422 |5.262370811951367E-4 ||10006 |201501121600|422 |3.457988917227463E-5 ||10006 |201501121630|27843 |0.002281535199582091 ||10006 |201501121700|2362 |1.9354904792633337E-4||10006 |201501121730|24683 |0.0020225957451167173||10006 |201501121800|4532 |3.7136506570793515E-4||10006 |201501121830|5342 |4.377387866310215E-4 ||10006 |201501121900|65642 |0.0053788935664607854||10006 |201501121930|2534 |2.0764322076432208E-4||10006 |201501122000|25376 |0.002079382150795358 ||10006 |201501122030|242443 |0.019866474100933125 ||10006 |201501122100|2344562|0.19212012824058425 ||10006 |201501122130|5462 |4.4757193047147874E-4||10006 |201501122200|2535 |2.0772516362965921E-4||10006 |201501122230|242546 |0.01987491421606285 ||10006 |201501122300|6542 |5.360702250355939E-4 ||10006 |201501122330|2546 |2.086265351483678E-4 ||10006 |201501130000|45245 |0.0037075049421790656|+-------+------------+-------+---------------------+ 分析：根据shop_id分组，不排序，窗口大小默认就是整个分组。 3.找出2点的销售金额及前半小时的销售金额和后1个小时的销售金额 df.withColumn( 'pre_half_hour', lag('date', 1).over(Window.partitionBy('shop_id').orderBy(asc('date')))).withColumn( 'pre_half_hour_amount', lag('amount', 1).over(Window.partitionBy('shop_id').orderBy(asc('date')))).withColumn( 'follow_one_hour', lead('date', 2).over(Window.partitionBy('shop_id').orderBy(asc('date')))).withColumn( 'follow_one_hour_amount', lead('amount', 2).over(Window.partitionBy('shop_id').orderBy(asc('date')))).filter( col('date') == '201501120200').select( 'shop_id', 'date', 'amount','pre_half_hour', 'pre_half_hour_amount', 'follow_one_hour', 'follow_one_hour_amount').show(truncate=False) +-------+------------+------+-------------+--------------------+---------------+----------------------+|shop_id|date |amount|pre_half_hour|pre_half_hour_amount|follow_one_hour|follow_one_hour_amount|+-------+------------+------+-------------+--------------------+---------------+----------------------+|10006 |201501120200|24234 |201501120130 |2342 |201501120300 |31232 |+-------+------------+------+-------------+--------------------+---------------+----------------------+ 分析：pyspark.sql.functions.lag(col, count=1, default=none)是取前N行的值pyspark.sql.functions.lead(col, count=1, default=none)是取后N行的值。 4.按照销售金额进行排名，金额最大的排最前（limit可以取topn的数） df.withColumn( 'rn', dense_rank().over(Window.partitionBy('shop_id').orderBy(desc('amount')))).select( 'shop_id', 'date', 'amount', 'rn' ).show(50, truncate=False) +-------+------------+-------+---+|shop_id|date |amount |rn |+-------+------------+-------+---+|10006 |201501120800|5645622|1 ||10006 |201501122100|2344562|2 ||10006 |201501121430|652562 |3 ||10006 |201501121230|534236 |4 ||10006 |201501120700|425432 |5 ||10006 |201501120900|366642 |6 ||10006 |201501121330|353462 |7 ||10006 |201501121200|254352 |8 ||10006 |201501122230|242546 |9 ||10006 |201501122030|242443 |10 ||10006 |201501120600|231635 |11 ||10006 |201501120330|221313 |12 ||10006 |201501120930|74632 |13 ||10006 |201501121900|65642 |14 ||10006 |201501121400|64562 |15 ||10006 |201501121000|63562 |16 ||10006 |201501130000|45245 |17 ||10006 |201501120730|36362 |18 ||10006 |201501121300|35432 |19 ||10006 |201501120830|34532 |20 ||10006 |201501120300|31232 |21 ||10006 |201501121630|27843 |22 ||10006 |201501121030|26353 |23 ||10006 |201501121130|26352 |24 ||10006 |201501122000|25376 |25 ||10006 |201501121730|24683 |26 ||10006 |201501120200|24234 |27 ||10006 |201501120100|23112 |28 ||10006 |201501120130|23112 |28 ||10006 |201501122300|6542 |29 ||10006 |201501121530|6422 |30 ||10006 |201501122130|5462 |31 ||10006 |201501121830|5342 |32 ||10006 |201501121800|4532 |33 ||10006 |201501122330|2546 |34 ||10006 |201501120630|2536 |35 ||10006 |201501122200|2535 |36 ||10006 |201501121930|2534 |37 ||10006 |201501121500|2456 |38 ||10006 |201501121700|2362 |39 ||10006 |201501121100|2353 |40 ||10006 |201501120030|2313 |41 ||10006 |201501120500|2234 |42 ||10006 |201501120530|2234 |42 ||10006 |201501120430|2231 |43 ||10006 |201501120400|2134 |44 ||10006 |201501121600|422 |45 ||10006 |201501120230|132 |46 |+-------+------------+-------+---+ df.withColumn( 'rn', rank().over(Window.partitionBy('shop_id').orderBy(desc('amount')))).select( 'shop_id', 'date', 'amount', 'rn' ).show(50, truncate=False) +-------+------------+-------+---+|shop_id|date |amount |rn |+-------+------------+-------+---+|10006 |201501120800|5645622|1 ||10006 |201501122100|2344562|2 ||10006 |201501121430|652562 |3 ||10006 |201501121230|534236 |4 ||10006 |201501120700|425432 |5 ||10006 |201501120900|366642 |6 ||10006 |201501121330|353462 |7 ||10006 |201501121200|254352 |8 ||10006 |201501122230|242546 |9 ||10006 |201501122030|242443 |10 ||10006 |201501120600|231635 |11 ||10006 |201501120330|221313 |12 ||10006 |201501120930|74632 |13 ||10006 |201501121900|65642 |14 ||10006 |201501121400|64562 |15 ||10006 |201501121000|63562 |16 ||10006 |201501130000|45245 |17 ||10006 |201501120730|36362 |18 ||10006 |201501121300|35432 |19 ||10006 |201501120830|34532 |20 ||10006 |201501120300|31232 |21 ||10006 |201501121630|27843 |22 ||10006 |201501121030|26353 |23 ||10006 |201501121130|26352 |24 ||10006 |201501122000|25376 |25 ||10006 |201501121730|24683 |26 ||10006 |201501120200|24234 |27 ||10006 |201501120100|23112 |28 ||10006 |201501120130|23112 |28 ||10006 |201501122300|6542 |30 ||10006 |201501121530|6422 |31 ||10006 |201501122130|5462 |32 ||10006 |201501121830|5342 |33 ||10006 |201501121800|4532 |34 ||10006 |201501122330|2546 |35 ||10006 |201501120630|2536 |36 ||10006 |201501122200|2535 |37 ||10006 |201501121930|2534 |38 ||10006 |201501121500|2456 |39 ||10006 |201501121700|2362 |40 ||10006 |201501121100|2353 |41 ||10006 |201501120030|2313 |42 ||10006 |201501120500|2234 |43 ||10006 |201501120530|2234 |43 ||10006 |201501120430|2231 |45 ||10006 |201501120400|2134 |46 ||10006 |201501121600|422 |47 ||10006 |201501120230|132 |48 |+-------+------------+-------+---+ df.withColumn( 'rn', row_number().over(Window.partitionBy('shop_id').orderBy(desc('amount')))).select( 'shop_id', 'date', 'amount', 'rn' ).show(50, truncate=False) +-------+------------+-------+---+|shop_id|date |amount |rn |+-------+------------+-------+---+|10006 |201501120800|5645622|1 ||10006 |201501122100|2344562|2 ||10006 |201501121430|652562 |3 ||10006 |201501121230|534236 |4 ||10006 |201501120700|425432 |5 ||10006 |201501120900|366642 |6 ||10006 |201501121330|353462 |7 ||10006 |201501121200|254352 |8 ||10006 |201501122230|242546 |9 ||10006 |201501122030|242443 |10 ||10006 |201501120600|231635 |11 ||10006 |201501120330|221313 |12 ||10006 |201501120930|74632 |13 ||10006 |201501121900|65642 |14 ||10006 |201501121400|64562 |15 ||10006 |201501121000|63562 |16 ||10006 |201501130000|45245 |17 ||10006 |201501120730|36362 |18 ||10006 |201501121300|35432 |19 ||10006 |201501120830|34532 |20 ||10006 |201501120300|31232 |21 ||10006 |201501121630|27843 |22 ||10006 |201501121030|26353 |23 ||10006 |201501121130|26352 |24 ||10006 |201501122000|25376 |25 ||10006 |201501121730|24683 |26 ||10006 |201501120200|24234 |27 ||10006 |201501120100|23112 |28 ||10006 |201501120130|23112 |29 ||10006 |201501122300|6542 |30 ||10006 |201501121530|6422 |31 ||10006 |201501122130|5462 |32 ||10006 |201501121830|5342 |33 ||10006 |201501121800|4532 |34 ||10006 |201501122330|2546 |35 ||10006 |201501120630|2536 |36 ||10006 |201501122200|2535 |37 ||10006 |201501121930|2534 |38 ||10006 |201501121500|2456 |39 ||10006 |201501121700|2362 |40 ||10006 |201501121100|2353 |41 ||10006 |201501120030|2313 |42 ||10006 |201501120500|2234 |43 ||10006 |201501120530|2234 |44 ||10006 |201501120430|2231 |45 ||10006 |201501120400|2134 |46 ||10006 |201501121600|422 |47 ||10006 |201501120230|132 |48 |+-------+------------+-------+---+ 分析：dense_rank和rank都是排名函数，区别在于dense_rank是连续排名，rank遇到排名并列时，下一列排名跳空。row_number是加行号，次序是连续的，不会存在重复的行号 5.按销售金额排序，取出前20%的时间段和相应金额 df.withColumn( 'tile', ntile(5).over(Window.partitionBy('shop_id').orderBy(desc('amount')))).select( 'shop_id', 'date', 'amount', 'tile' ).show(50, truncate=False) +-------+------------+-------+----+|shop_id|date |amount |tile|+-------+------------+-------+----+|10006 |201501120800|5645622|1 ||10006 |201501122100|2344562|1 ||10006 |201501121430|652562 |1 ||10006 |201501121230|534236 |1 ||10006 |201501120700|425432 |1 ||10006 |201501120900|366642 |1 ||10006 |201501121330|353462 |1 ||10006 |201501121200|254352 |1 ||10006 |201501122230|242546 |1 ||10006 |201501122030|242443 |1 ||10006 |201501120600|231635 |2 ||10006 |201501120330|221313 |2 ||10006 |201501120930|74632 |2 ||10006 |201501121900|65642 |2 ||10006 |201501121400|64562 |2 ||10006 |201501121000|63562 |2 ||10006 |201501130000|45245 |2 ||10006 |201501120730|36362 |2 ||10006 |201501121300|35432 |2 ||10006 |201501120830|34532 |2 ||10006 |201501120300|31232 |3 ||10006 |201501121630|27843 |3 ||10006 |201501121030|26353 |3 ||10006 |201501121130|26352 |3 ||10006 |201501122000|25376 |3 ||10006 |201501121730|24683 |3 ||10006 |201501120200|24234 |3 ||10006 |201501120100|23112 |3 ||10006 |201501120130|23112 |3 ||10006 |201501122300|6542 |3 ||10006 |201501121530|6422 |4 ||10006 |201501122130|5462 |4 ||10006 |201501121830|5342 |4 ||10006 |201501121800|4532 |4 ||10006 |201501122330|2546 |4 ||10006 |201501120630|2536 |4 ||10006 |201501122200|2535 |4 ||10006 |201501121930|2534 |4 ||10006 |201501121500|2456 |4 ||10006 |201501121700|2362 |5 ||10006 |201501121100|2353 |5 ||10006 |201501120030|2313 |5 ||10006 |201501120500|2234 |5 ||10006 |201501120530|2234 |5 ||10006 |201501120430|2231 |5 ||10006 |201501120400|2134 |5 ||10006 |201501121600|422 |5 ||10006 |201501120230|132 |5 |+-------+------------+-------+----+ 分析： NTILE就是把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号 设置n=5，那么ntile就会把排好序的数据均分成n个组，ntile函数会返回每条数据所在组的组编号，从而可以达到取前百分比的数据 思考：在使用row_number函数的时候，并没有指定rowsBetween，那么默认应该是默认的rows between unbounded preceding and current row。但是，结果却是把组内的所有元素都进行了标号 rowsBetween应该是针对于具有聚合性质的函数起作用","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Spark学习","slug":"Spark学习","permalink":"https://shang.at/tags/Spark学习/"}]},{"title":"Spark学习笔记-union方法","slug":"Spark学习笔记-union方法","date":"2019-03-12T01:53:56.000Z","updated":"2019-03-24T01:33:47.225Z","comments":true,"path":"post/Spark学习笔记-union方法/","link":"","permalink":"https://shang.at/post/Spark学习笔记-union方法/","excerpt":"","text":"方法简介pyspark.sql.dataframe.DataFrame#union(other) union两个df，效果相当于union all(pyspark.sql.dataframe.DataFrame#unionAll在2.0以后就被Deprecated了)。 union方法的特点是： schema会使用前面df的schema， 只有两个有相同数量列的df才能进行union， union的时候会根据列的顺序进行union，与属性名无关 案例测试from pyspark.sql import SparkSessionfrom pyspark.sql.functions import *spark = SparkSession \\ .builder \\ .master('local[*]') \\ .enableHiveSupport() \\ .getOrCreate() df1 = spark.createDataFrame([&#123;'name':'cc', 'age':24&#125;, &#123;'name':'aa', 'age':25&#125;])df1.printSchema() root |-- age: long (nullable = true) |-- name: string (nullable = true)df2 = spark.createDataFrame([&#123;'name1':'bb', 'age1':2&#125;, &#123;'name1':'dd', 'age1':3&#125;])df2.printSchema() root |-- age1: long (nullable = true) |-- name1: string (nullable = true)df1.union(df2) DataFrame[age: bigint, name: string]union_df = df1.union(df2)union_df.printSchema() root |-- age: long (nullable = true) |-- name: string (nullable = true)union_df.show() +---+----+ |age|name| +---+----+ | 24| cc| | 25| aa| | 2| bb| | 3| dd| +---+----+select_union_df = df1.select('name').union(df2.select('age1'))select_union_df.printSchema() root |-- name: string (nullable = true)select_union_df.show() +----+ |name| +----+ | cc| | aa| | 2| | 3| +----+select_union_df = df1.select('name', 'age').union(df2.select('age1')) pyspark.sql.utils.AnalysisException: \"Union can only be performed on tables with the same number of columns, but the first table has 2 columns and the second table has 1 columns;;\\n'Union\\n:- Project [name#1, age#0L]\\n: +- LogicalRDD [age#0L, name#1], false\\n+- Project [age1#4L]\\n +- LogicalRDD [age1#4L, name1#5], false\\n\"select_union_df = df1.select('age').union(df2.select('name1'))select_union_df.show() +---+ |age| +---+ | 24| | 25| | bb| | dd| +---+select_union_df.printSchema() root |-- age: string (nullable = true)select_union_df = df1.select('name', 'age').union(df2.select('age1', 'name1'))select_union_df.printSchema() root |-- name: string (nullable = true) |-- age: string (nullable = true)select_union_df.show() +----+---+ |name|age| +----+---+ | cc| 24| | aa| 25| | 2| bb| | 3| dd| +----+---+ 其他案例要想实现sql中union的效果，需要结合distinct()来使用: df1 = spark.createDataFrame([&#123;'name':'cc', 'age':24&#125;, &#123;'name':'aa', 'age':25&#125;])df2 = spark.createDataFrame([&#123;'name1':'cc', 'age1':24&#125;, &#123;'name1':'dd', 'age1':3&#125;])df1.union(df2).show() +---+----+ |age|name| +---+----+ | 24| cc| | 25| aa| | 24| cc| | 3| dd| +---+----+df1.union(df2).distinct().show() +---+----+ |age|name| +---+----+ | 24| cc| | 3| dd| | 25| aa| +---+----+","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"Spark学习","slug":"Spark学习","permalink":"https://shang.at/tags/Spark学习/"}]},{"title":"Spark学习笔记一","slug":"Spark学习笔记一","date":"2019-03-10T10:45:03.000Z","updated":"2019-03-24T01:33:47.230Z","comments":true,"path":"post/Spark学习笔记一/","link":"","permalink":"https://shang.at/post/Spark学习笔记一/","excerpt":"","text":"版本：pyspark 2.4.0 主要包 pyspark pyspark.sql module pyspark.streaming module pyspark.ml package pyspark.mllib package pyspark pyspark.SparkConf(loadDefaults=True, _jvm=None, _jconf=None) 是spark应用的配置类，默认loadDefaults=True，会自动加载java系统参数中的spark.*的参数，_jconf是一个已经存在的sparkConf句柄 主要api： setMaster() 设置应用的提交类型：local|local[n]|local[*] or 不填，本地测试时可以填local系列，提交到集群运行时可以不用填，提交任务的时候会根据集群的配置，自动选择提交的类型：standalone或者yarn模式 setAppName() 设置应用的名称 pyspark.SparkContext(master=None, appName=None, sparkHome=None, pyFiles=None, environment=None, batchSize=0, serializer=PickleSerializer(), conf=None, gateway=None, jsc=None, profiler_cls=) spark应用上下文，是spark应用的主要入口。代表了与spark cluster的链接，可以用来在集群中创建RDD和广播变量。 主要api讲解： addFile(self, path, recursive=False) 为spark job添加一个可下载文件，spark的每一个node都会下载一份，可以是local file、hdfs file、http file、https file或ftp file。可以使用SparkFiles通过文件名来读取设置的文件， 注意，每个应用中，每个文件名只能设置一次。recursive设置为True时，传递的path可以是目录，但是目前只支持hdfs file的场景 import osfrom tempfile import gettempdirfrom pyspark import SparkConffrom pyspark import SparkContextif __name__ == '__main__': from pyspark import SparkFiles conf = SparkConf() conf.setMaster(\"local\").setAppName(\"My app\") sc = SparkContext(conf=conf) path = os.path.join(gettempdir(), \"test.txt\") print(path) with open(path, \"w\") as testFile: _ = testFile.write(\"100\") sc.addFile(path) def func(iterator): with open(SparkFiles.get('test.txt')) as testFile: fileVal = int(testFile.readline()) print(fileVal) return [x * fileVal for x in iterator] result = sc.parallelize([1, 2, 3, 4]).mapPartitions(func).collect() print(result) accumulator(value, accum_param=None) 创建一个累加器。一个全局共享的可以进行累加的变量，只能在worker上进行update操作，在driver上获取结果值得操作。值类型默认是int和float类型，也可以使用accum_param参数设置为自定义的数据类型 # 代码后加 broadcast(value) 在集群中广播一个只读的值，返回一个Broadcast对象，以便在分布式方法中调用。被广播的变量只会被发送到集群的各个node上一次","categories":[{"name":"Spark","slug":"Spark","permalink":"https://shang.at/categories/Spark/"}],"tags":[{"name":"pyspark官方文档学习","slug":"pyspark官方文档学习","permalink":"https://shang.at/tags/pyspark官方文档学习/"}]},{"title":"数据仓库学习笔记二-建模流程","slug":"数据仓库学习笔记二-建模流程","date":"2019-03-03T11:36:50.000Z","updated":"2019-03-03T12:26:38.927Z","comments":true,"path":"post/数据仓库学习笔记二-建模流程/","link":"","permalink":"https://shang.at/post/数据仓库学习笔记二-建模流程/","excerpt":"","text":"数据建模的基本流程在建模的不同阶段，将数据模型分为三个层次，每层的作用各不相同。 概念模型:确定系统的核心以及划清系统范围和 边界 逻辑模型:梳理业务规则以及对概念模型的求精 物理模型:从性能、访问、开发等多方面考虑， 做系统的实现 概念模型概念建模小贴士1 注重全局的理解而非细节 在概念模型阶段，即需要对整体架构做思考 概念模型通常是自上而下的模式，通过会议等模式反复沟通，澄清需求 在此阶段，应粗略地估算出整个项目需要的时间以及项目计划草案 根据计划粗略地估算出项目的费用 是数据模型工程师与客户沟通的破冰之旅，使他们在此期间达成共识并奠定未来良好的沟通基础以及私人关系 出品的概念模型可以帮助划定系统边界以及避免方向性的错误 商业主导，相比技术专家而言，更需要商业专家 是未来逻辑模型的沟通基础，以及逐步求精的依据 概念模型交付品通常具备如下特点: 与客户一致的商业语言 尽量一页纸描述清楚整个模型 通常用实体关系型图表示，但不需添加实体的属性 允许多对多的关系存在 逻辑模型逻辑建模小提示1 应更精确估算出整个项目需要的时间以及项目计划草案 并且根据计划更精确地估算出项目的费用 当实体数量超过100时，需要定义术语表 规范化 先规范化再逆规范化，不可一步到位 不可缺少约束的定义 使用CASE工具做逻辑模型 多对多关系需要解决 需要同级评审(Peer Review) 确定可信赖数据源，关键属性需用真实数据验证 应用成熟的建模模式(Pattern) 一定程度的抽象化，决定了未来模型的弹性 高质量的模型定义 重要关联关系需要强制建立 与概念模型保持一致 注意模型的版本管理 非常非常注意细节 数据库专家深度介入 占据整个数据建模80%以上时间 不要忽视属性的长度定义和约束定义 不要忽视属性的默认值(Default Value) 使用控制数据范围的域(Domain) 逻辑建模交付品的特点 要像一本书，而非一页纸 所有实体属性均需添加 实体间关系要清晰描述 使用术语表 遵循命名规范 采用CASE工具创建项目文件 对各个实体必须有清晰描述 对关键属性必须有清晰描述 物理模型物理建模小贴士1 使用CASE工具由逻辑模型自动生成 应用术语表自动转换生成字段名称 对表空间、索引、视图、物化视图、主键、外键等都有命名规则 逆规范化在逻辑层完成，而非本层 数据库DBA深度介入，需要DBA的评审(Peer Review) 和数据库的DDL保持一致 注意版本管理 注意开发、测试、生产三个不同版本的模型管理 注意性能 估算数据规模 考虑数据归档 充分考虑未来使用数据库的优点和缺点 物理建模交付品的特点 自动生成基础库表结构，之后适度手动调整 与未来要使用的数据库类型息息相关 生成数据字典并发布 可直接用于生成DDL DDL中注意注释的生成 如何进行高质量数据建模什么样的模型算是高质量数据模型? 对真实世界的抽象正确而完整 用建模语言表达清晰而准确 框架稳定且灵活，满足当下的需求并能够一定程度容纳未来的变化 根据需求尽可能减少数据冗余 充分考虑潜在的性能问题 从企业全局的视角出发构筑模型","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://shang.at/categories/数据仓库/"}],"tags":[]},{"title":"数据仓库学习笔记二-重要意义","slug":"数据仓库学习笔记二-重要意义","date":"2019-03-03T10:55:58.000Z","updated":"2019-03-03T11:36:09.787Z","comments":true,"path":"post/数据仓库学习笔记二-重要意义/","link":"","permalink":"https://shang.at/post/数据仓库学习笔记二-重要意义/","excerpt":"","text":"数据时代的演化DIKWdata数据 + information信息 + knowledge知识 + wisdom智慧 描述数据的数据被称为元数据(metadata) 信息（information）= 元数据（metadata）+数据（data） 什么是数据模型数据模型实际上就是为了装载数据，用元数据搭建起来的框子 数据模型是将数据元素以标准化的模式组织起来, 用来模拟现实世界的信息框架蓝图。 数据模型的要求: 直观地模拟世界 容易为人所理解 便于计算机实现 数据模型是整个数据应用的基石，牵一发而动全身。数据模型的小小改动将会导致上层数据应用的大幅度变化 建设高质量数据模型的意义低质量数据模型的十宗罪 没有准确的捕获到需求 数据模型不完整 各层模型与其扮演角色不匹配 数据结构不合理 抽象化不够，造成模型不灵活 没有或者不遵循命名规范 缺少数据模型的定义和描述 数据模型可读性差 元数据与数据不匹配 数据模型与企业标准不一致 低质量数据模型的影响 大量修改和重做 重复建设 知识丢失 下游开发困难 高成本 数据质量低下 新业务无法展开 意义","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://shang.at/categories/数据仓库/"}],"tags":[]},{"title":"数据仓库学习笔记一","slug":"数据仓库学习笔记一","date":"2019-03-03T10:24:23.000Z","updated":"2019-03-03T11:12:25.458Z","comments":true,"path":"post/数据仓库学习笔记一/","link":"","permalink":"https://shang.at/post/数据仓库学习笔记一/","excerpt":"","text":"学习路线： 高质量数据建模基础 经典数据仓库架构 EDW建模 维度建模 数据仓库生命周期","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://shang.at/categories/数据仓库/"}],"tags":[]},{"title":"数据结构学习笔记二-复杂度分析","slug":"数据结构学习笔记二-复杂度分析","date":"2019-03-03T10:22:47.000Z","updated":"2019-03-24T01:33:47.232Z","comments":true,"path":"post/数据结构学习笔记二-复杂度分析/","link":"","permalink":"https://shang.at/post/数据结构学习笔记二-复杂度分析/","excerpt":"","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://shang.at/categories/数据结构与算法/"}],"tags":[{"name":"复杂度分析","slug":"复杂度分析","permalink":"https://shang.at/tags/复杂度分析/"}]},{"title":"数据结构学习笔记一","slug":"数据结构学习笔记一","date":"2019-03-03T09:34:30.000Z","updated":"2019-08-03T02:17:49.592Z","comments":true,"path":"post/数据结构学习笔记一/","link":"","permalink":"https://shang.at/post/数据结构学习笔记一/","excerpt":"","text":"数组链表栈队列跳表散列表关键点 散列思想 散列表是利用了数组可以根据下标随机访问的特性，而产生的一种高性能的数据结构(查找的时间复杂度为O(1))。散列表其实就是数组的一种拓展，是由数组演化而来。 其关键的概念有 键-key、 将键映射到数组下标的方法-散列函数(哈希函数)、 散列函数计算来的值-散列值(哈希值) 散列函数 散列冲突 开放寻址 链表法 进阶：链表使用红黑树或者跳表实现 具体实现|打造一个工业级散列表 散列函数 装载因子 散列冲突解决方法 #### 二叉树红黑树递归数堆图Trie数AC自动机位图布隆过滤器B+数索引","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://shang.at/categories/数据结构与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://shang.at/tags/数据结构/"}]},{"title":"Python数据科学学习笔记一","slug":"Python数据科学学习笔记一","date":"2019-03-03T09:19:14.000Z","updated":"2019-08-03T11:51:48.061Z","comments":true,"path":"post/Python数据科学学习笔记一/","link":"","permalink":"https://shang.at/post/Python数据科学学习笔记一/","excerpt":"","text":"描述性统计和探索型数据分析变量类型 名义变量 等级变量 连续变量 描述名义变量的分布两个统计量 频数 百分比 可视化 柱状图","categories":[{"name":"Python数据分析","slug":"Python数据分析","permalink":"https://shang.at/categories/Python数据分析/"}],"tags":[{"name":"描述性统计和探索型数据分析","slug":"描述性统计和探索型数据分析","permalink":"https://shang.at/tags/描述性统计和探索型数据分析/"}]},{"title":"记一次线上JVM问题调试","slug":"记一次线上JVM问题调试","date":"2019-02-27T03:21:32.000Z","updated":"2019-03-01T00:40:58.622Z","comments":true,"path":"post/记一次线上JVM问题调试/","link":"","permalink":"https://shang.at/post/记一次线上JVM问题调试/","excerpt":"发现java进程 使用linux命令：ps ps -ef | grep prcessName[root@YZSJHL81-35 ~]# ps -ef | grep Bootstraproot 118271 1 99 00:10 ? 3-16:08:07 Bootstrap startroot 197682 197016 0 17:08 pts/0 00:00:00 grep Bootstrap 使用java自带的检测工具 jps [root@YZSJHL81-35 ~]# jps118271 Bootstrap197101 Jps","text":"发现java进程 使用linux命令：ps ps -ef | grep prcessName[root@YZSJHL81-35 ~]# ps -ef | grep Bootstraproot 118271 1 99 00:10 ? 3-16:08:07 Bootstrap startroot 197682 197016 0 17:08 pts/0 00:00:00 grep Bootstrap 使用java自带的检测工具 jps [root@YZSJHL81-35 ~]# jps118271 Bootstrap197101 Jps 检测java进程启动的时间 ps -p 118271 -o etimeps -p 118271 -o etime= 检测进程打开的文件数 lsof -n -p 118271 | wc -l 检测系统的进程 top top - 17:11:21 up 132 days, 2:14, 1 user, load average: 0.12, 0.21, 0.18Tasks: 298 total, 1 running, 297 sleeping, 0 stopped, 0 zombieCpu(s): 1.0%us, 0.6%sy, 0.0%ni, 98.0%id, 0.3%wa, 0.0%hi, 0.1%si, 0.0%stMem: 99009860k total, 90554384k used, 8455476k free, 333672k buffersSwap: 0k total, 0k used, 0k free, 81820024k cachedPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMANDq-退出1-显示所有的cpu及其状态 查看指定进程下所有线程的状态 top -Hp pid 查看JVM的GC状态jstat -gcutil -t pid 1000 100 ---查看pid进程的GC状态每隔1000ms一次，一共100次 ​ 查看JVM栈信息printf '%x\\n' tid -- 打印指定线程id的十六进制表示jstack pid | grep 'tid十六进制' -C20 -color -- 查看进程的栈信息jmap -histo:live pid --查看进程所有存活的实例jmap -dumap:format=b,file=dump.hprof pid --导出JVM的dump文件","categories":[{"name":"JVM","slug":"JVM","permalink":"https://shang.at/categories/JVM/"}],"tags":[{"name":"JVM问题调试","slug":"JVM问题调试","permalink":"https://shang.at/tags/JVM问题调试/"}]},{"title":"辨析 Sass 中的 Map 和 List","slug":"demo","date":"2015-10-21T02:34:12.000Z","updated":"2019-03-01T00:39:39.899Z","comments":true,"path":"post/demo/","link":"","permalink":"https://shang.at/post/demo/","excerpt":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。","text":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 min-width、max-width、font-size 和 line-height 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 $breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 $breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： @each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： @each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： $breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： $medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： @function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) == $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://shang.at/tags/css/"}]}]}